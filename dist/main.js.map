{"version":3,"file":"main.js","sources":["../node_modules/nullthrows/nullthrows.js","../node_modules/nuclide/nuclide-commons/getDisplayName.js","../node_modules/nuclide/nuclide-commons/UniversalDisposable.js","../node_modules/nuclide/nuclide-commons/promise.js","../node_modules/nuclide/nuclide-commons/performanceNow.js","../node_modules/nuclide/nuclide-commons/analytics.js","../node_modules/nuclide/nuclide-commons-atom/ProviderRegistry.js","../node_modules/nuclide/nuclide-commons/event.js","../node_modules/nuclide/nuclide-commons-atom/text-editor.js","../node_modules/nuclide/nuclide-commons-atom/go-to-location.js","../node_modules/nuclide/nuclide-commons-atom/text-edit.js","../node_modules/nuclide/nuclide-commons-atom/FileEventHandlers.js","../node_modules/nuclide/nuclide-commons-atom/ConfigManager.js","../node_modules/nuclide/nuclide-commons-atom/feature-config.js","../node_modules/vscode-uri/lib/index.js","../node_modules/nuclide/nuclide-commons/_shell-quote.js","../node_modules/nuclide/nuclide-commons/string.js","../node_modules/nuclide/nuclide-commons/nuclideUri.js","../node_modules/webidl-conversions/lib/index.js","../node_modules/domexception/lib/utils.js","../node_modules/domexception/lib/DOMException-impl.js","../node_modules/domexception/lib/DOMException.js","../node_modules/domexception/lib/public-api.js","../node_modules/event-target-shim/src/event.mjs","../node_modules/event-target-shim/src/event-target.mjs","../node_modules/nuclide/nuclide-commons/AbortController.js","../node_modules/nuclide/nuclide-commons/collection.js","../node_modules/nuclide/nuclide-commons/debounce.js","../node_modules/nuclide/nuclide-commons/observable.js","../../src/CodeFormatManager.ts","../../src/config.ts","../../src/main.ts","../../src/legacy-provider.ts"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {value: true});\n\nexports.default = function nullthrows(x) {\n  if (x != null) {\n    return x;\n  }\n  throw new Error('Got unexpected null or undefined');\n};\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nexport default function getDisplayName(\r\n  functionOrClass: Function | Class<*>,\r\n): string {\r\n  if (\r\n    typeof functionOrClass.displayName === 'string' &&\r\n    functionOrClass.displayName !== ''\r\n  ) {\r\n    return functionOrClass.displayName;\r\n  } else if (\r\n    typeof functionOrClass.name === 'string' &&\r\n    functionOrClass.name !== ''\r\n  ) {\r\n    return functionOrClass.name;\r\n  }\r\n\r\n  return 'Unknown';\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nexport type IDestructible = {\r\n  destroy(): void,\r\n  onDidDestroy(callback: () => mixed): IDisposable,\r\n};\r\n\r\nexport type AnyTeardown =\r\n  | (() => mixed)\r\n  | rxjs$ISubscription\r\n  | IDisposable\r\n  | IDestructible;\r\n\r\n/**\r\n * Like a CompositeDisposable, but in addition to Disposable instances it can\r\n * also accept plain functions and Rx subscriptions.\r\n */\r\nexport default class UniversalDisposable {\r\n  disposed: boolean;\r\n  teardowns: Set<AnyTeardown>;\r\n\r\n  constructor(...teardowns: Array<AnyTeardown>) {\r\n    this.teardowns = new Set();\r\n    this.disposed = false;\r\n    if (teardowns.length) {\r\n      this.add(...teardowns);\r\n    }\r\n  }\r\n\r\n  add(...teardowns: Array<AnyTeardown>): void {\r\n    if (this.disposed) {\r\n      throw new Error('Cannot add to an already disposed UniversalDisposable!');\r\n    }\r\n    for (let i = 0; i < teardowns.length; i++) {\r\n      assertTeardown(teardowns[i]);\r\n      this.teardowns.add(teardowns[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a list of teardowns but also ties them to the lifetime of `destructible`.\r\n   * When `destructible` is destroyed (or `this.dispose()` gets called, whichever comes first),\r\n   * all `teardowns` provided are also disposed.\r\n   *\r\n   * This is a subtle pattern to get right because of two factors:\r\n   * - we need to make sure that all teardowns are also removed on destroy\r\n   * - we also need to ensure that we don't leak the onDidDestroy disposable\r\n   */\r\n  addUntilDestroyed(\r\n    destructible: IDestructible,\r\n    ...teardowns: Array<AnyTeardown>\r\n  ) {\r\n    if (this.disposed) {\r\n      throw new Error('Cannot add to an already disposed UniversalDisposable!');\r\n    }\r\n    const destroyDisposable = new UniversalDisposable(\r\n      ...teardowns,\r\n      destructible.onDidDestroy(() => {\r\n        destroyDisposable.dispose();\r\n        this.remove(destroyDisposable);\r\n      }),\r\n    );\r\n    this.add(destroyDisposable);\r\n  }\r\n\r\n  remove(teardown: AnyTeardown): void {\r\n    if (!this.disposed) {\r\n      this.teardowns.delete(teardown);\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    if (!this.disposed) {\r\n      this.disposed = true;\r\n      this.teardowns.forEach(teardown => {\r\n        if (typeof teardown.dispose === 'function') {\r\n          teardown.dispose();\r\n        } else if (typeof teardown.unsubscribe === 'function') {\r\n          teardown.unsubscribe();\r\n        } else if (typeof teardown.destroy === 'function') {\r\n          teardown.destroy();\r\n        } else if (typeof teardown === 'function') {\r\n          teardown();\r\n        }\r\n      });\r\n      this.teardowns = (null: any);\r\n    }\r\n  }\r\n\r\n  unsubscribe(): void {\r\n    this.dispose();\r\n  }\r\n\r\n  clear(): void {\r\n    if (!this.disposed) {\r\n      this.teardowns.clear();\r\n    }\r\n  }\r\n}\r\n\r\nfunction assertTeardown(teardown: AnyTeardown): void {\r\n  if (\r\n    typeof teardown.dispose === 'function' ||\r\n    typeof teardown.unsubscribe === 'function' ||\r\n    typeof teardown.destroy === 'function' ||\r\n    typeof teardown === 'function'\r\n  ) {\r\n    return;\r\n  }\r\n  throw new TypeError(\r\n    'Arguments to UniversalDisposable.add must be disposable',\r\n  );\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\n\r\ntype RunReturn<T> =\r\n  | {\r\n      status: 'success',\r\n      result: T,\r\n    }\r\n  | {\r\n      status: 'outdated',\r\n    };\r\n\r\n/**\r\n * Allows a caller to ensure that the results it receives from consecutive\r\n * promise resolutions are never outdated. Usage:\r\n *\r\n * var requestSerializer = new RequestSerializer();\r\n *\r\n * // in some later loop:\r\n *\r\n * // note that you do not await the async function here -- you must pass the\r\n * // promise it returns to `run`\r\n * var result = await requestSerializer.run(someAsyncFunction())\r\n *\r\n * if (result.status === 'success') {\r\n *   ....\r\n *   result.result\r\n * } else if (result.status === 'outdated') {\r\n *   ....\r\n * }\r\n *\r\n * The contract is that the status is 'success' if and only if this was the most\r\n * recently dispatched call of 'run'. For example, if you call run(promise1) and\r\n * then run(promise2), and promise2 resolves first, the second callsite would\r\n * receive a 'success' status. If promise1 later resolved, the first callsite\r\n * would receive an 'outdated' status.\r\n */\r\nexport class RequestSerializer<T> {\r\n  _lastDispatchedOp: number;\r\n  _lastFinishedOp: number;\r\n  _latestPromise: Promise<T>;\r\n  _waitResolve: Function;\r\n\r\n  constructor() {\r\n    this._lastDispatchedOp = 0;\r\n    this._lastFinishedOp = 0;\r\n    this._latestPromise = new Promise((resolve, reject) => {\r\n      this._waitResolve = resolve;\r\n    });\r\n  }\r\n\r\n  async run(promise: Promise<T>): Promise<RunReturn<T>> {\r\n    const thisOp = this._lastDispatchedOp + 1;\r\n    this._lastDispatchedOp = thisOp;\r\n    this._latestPromise = promise;\r\n    this._waitResolve();\r\n    const result = await promise;\r\n    if (this._lastFinishedOp < thisOp) {\r\n      this._lastFinishedOp = thisOp;\r\n      return {\r\n        status: 'success',\r\n        result,\r\n      };\r\n    } else {\r\n      return {\r\n        status: 'outdated',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a Promise that resolves to the last result of `run`,\r\n   * as soon as there are no more outstanding `run` calls.\r\n   */\r\n  async waitForLatestResult(): Promise<T> {\r\n    let lastPromise = null;\r\n    let result: any = null;\r\n    while (lastPromise !== this._latestPromise) {\r\n      lastPromise = this._latestPromise;\r\n      // Wait for the current last know promise to resolve, or a next run have started.\r\n      // eslint-disable-next-line no-await-in-loop\r\n      result = await new Promise((resolve, reject) => {\r\n        this._waitResolve = resolve;\r\n        this._latestPromise.then(resolve);\r\n      });\r\n    }\r\n    return (result: T);\r\n  }\r\n\r\n  isRunInProgress(): boolean {\r\n    return this._lastDispatchedOp > this._lastFinishedOp;\r\n  }\r\n}\r\n\r\n/*\r\n * Returns a promise that will resolve after `milliSeconds` milli seconds.\r\n * this can be used to pause execution asynchronously.\r\n * e.g. await sleep(1000), pauses the async flow execution for 1 second.\r\n */\r\nexport function sleep(milliSeconds: number): Promise<void> {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, milliSeconds);\r\n  });\r\n}\r\n\r\nexport function nextTick(): Promise<void> {\r\n  return new Promise(resolve => {\r\n    process.nextTick(resolve);\r\n  });\r\n}\r\n\r\n/**\r\n * Executes a provided callback only if a promise takes longer than\r\n * `milliSeconds` milliseconds to resolve.\r\n *\r\n * @param `promise` the promise to wait on.\r\n * @param `milliSeconds` max amount of time that `promise` can take to resolve\r\n * before timeoutFn is fired.\r\n * @param `timeoutFn` the function to execute when a promise takes longer than\r\n * `milliSeconds` ms to resolve.\r\n * @param `cleanupFn` the cleanup function to execute after the promise resolves.\r\n */\r\nexport async function triggerAfterWait<T>(\r\n  promise: Promise<T>,\r\n  milliSeconds: number,\r\n  timeoutFn: () => void,\r\n  cleanupFn?: () => void,\r\n): Promise<T> {\r\n  const timeout = setTimeout(timeoutFn, milliSeconds);\r\n  try {\r\n    return await promise;\r\n  } finally {\r\n    clearTimeout(timeout);\r\n    if (cleanupFn) {\r\n      cleanupFn();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown by `timeoutPromise` if the timer fires before the promise resolves/rejects.\r\n */\r\nexport class TimedOutError extends Error {\r\n  timeout: number;\r\n  constructor(milliseconds: number) {\r\n    super(`Timed out after ${String(milliseconds)} ms`);\r\n    this.timeout = milliseconds;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a Promise that resolves to the same value as the given promise, or rejects with\r\n * `TimedOutError` if it takes longer than `milliseconds` milliseconds.\r\n */\r\nexport function timeoutPromise<T>(\r\n  promise: Promise<T>,\r\n  milliseconds: number,\r\n): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    let timeout = setTimeout(() => {\r\n      timeout = null;\r\n      reject(new TimedOutError(milliseconds));\r\n      // This gives useless error.stack results.\r\n      // We could capture the stack pre-emptively at the start\r\n      // of this method if we wanted useful ones.\r\n    }, milliseconds);\r\n    promise\r\n      .then(value => {\r\n        if (timeout != null) {\r\n          clearTimeout(timeout);\r\n        }\r\n        resolve(value);\r\n      })\r\n      .catch(value => {\r\n        if (timeout != null) {\r\n          clearTimeout(timeout);\r\n        }\r\n        reject(value);\r\n      });\r\n  });\r\n}\r\n\r\n// An DeadlineRequest parameter to an async method is a way of *requesting* that\r\n// method to throw a TimedOutError if it doesn't complete in a certain time.\r\n// It's just a request -- the async method will typically honor the request\r\n// by passing the parameter on to ALL subsidiary async methods that it awaits,\r\n// or by calling expirePromise to enforce a timeout, or similar.\r\n//\r\n// In cases where a method supports DeadlineRequest but you don't trust it, do\r\n// `await timeoutAfterDeadline(deadline, untrusted.foo(deadline-1000))` so you\r\n// ask it nicely but if it doesn't give its own more-specific deadline message\r\n// within a 1000ms grace period then you force matters.\r\n//\r\n// Under the hood an DeadlineRequest is just a timestamp of the time by which\r\n// the operation should complete. This makes it compositional (better than\r\n// \"delay\" parameters) and safely remotable (better than \"CancellationToken\"\r\n// parameters) so long as clocks are in sync. In all other respects it's less\r\n// versatile than CancellationTokens.\r\nexport type DeadlineRequest = number;\r\n\r\nexport function createDeadline(delay: number): DeadlineRequest {\r\n  return Date.now() + delay;\r\n}\r\n\r\nexport function timeoutAfterDeadline<T>(\r\n  deadline: DeadlineRequest,\r\n  promise: Promise<T>,\r\n): Promise<T> {\r\n  const delay = deadline - Date.now();\r\n  return timeoutPromise(promise, delay < 0 ? 0 : delay);\r\n}\r\n\r\n/**\r\n * Call an async function repeatedly with a maximum number of trials limit,\r\n * until a valid result that's defined by a validation function.\r\n * A failed call can result from an async thrown exception, or invalid result.\r\n *\r\n * @param `retryFunction` the async logic that's wanted to be retried.\r\n * @param `validationFunction` the validation function that decides whether a response is valid.\r\n * @param `maximumTries` the number of times the `retryFunction` can fail to get a valid\r\n * response before the `retryLimit` is terminated reporting an error.\r\n * @param `retryIntervalMs` optional, the number of milliseconds to wait between trials, if wanted.\r\n *\r\n * If an exception is encountered on the last trial, the exception is thrown.\r\n * If no valid response is found, an exception is thrown.\r\n */\r\nexport async function retryLimit<T>(\r\n  retryFunction: () => Promise<T>,\r\n  validationFunction: (result: T) => boolean,\r\n  maximumTries: number,\r\n  retryIntervalMs?: number = 0,\r\n): Promise<T> {\r\n  let result = null;\r\n  let tries = 0;\r\n  let lastError = null;\r\n  while (tries === 0 || tries < maximumTries) {\r\n    try {\r\n      // eslint-disable-next-line no-await-in-loop\r\n      result = await retryFunction();\r\n      lastError = null;\r\n      if (validationFunction(result)) {\r\n        return result;\r\n      }\r\n    } catch (error) {\r\n      lastError = error;\r\n      result = null;\r\n    }\r\n\r\n    if (++tries < maximumTries && retryIntervalMs !== 0) {\r\n      // eslint-disable-next-line no-await-in-loop\r\n      await sleep(retryIntervalMs);\r\n    }\r\n  }\r\n  if (lastError != null) {\r\n    throw lastError;\r\n  } else if (tries === maximumTries) {\r\n    throw new Error('No valid response found!');\r\n  } else {\r\n    return ((result: any): T);\r\n  }\r\n}\r\n\r\n/**\r\n * Limits async function execution parallelism to only one at a time.\r\n * Hence, if a call is already running, it will wait for it to finish,\r\n * then start the next async execution, but if called again while not finished,\r\n * it will return the scheduled execution promise.\r\n *\r\n * Sample Usage:\r\n * ```\r\n * let i = 1;\r\n * const oneExecAtATime = oneParallelAsyncCall(() => {\r\n *   return next Promise((resolve, reject) => {\r\n *     setTimeout(200, () => resolve(i++));\r\n *   });\r\n * });\r\n *\r\n * const result1Promise = oneExecAtATime(); // Start an async, and resolve to 1 in 200 ms.\r\n * const result2Promise = oneExecAtATime(); // Schedule the next async, and resolve to 2 in 400 ms.\r\n * const result3Promise = oneExecAtATime(); // Reuse scheduled promise and resolve to 2 in 400 ms.\r\n * ```\r\n */\r\nexport function serializeAsyncCall<T>(\r\n  asyncFun: () => Promise<T>,\r\n): () => Promise<T> {\r\n  let scheduledCall = null;\r\n  let pendingCall = null;\r\n  const startAsyncCall = () => {\r\n    const resultPromise = asyncFun();\r\n    pendingCall = resultPromise.then(\r\n      () => (pendingCall = null),\r\n      () => (pendingCall = null),\r\n    );\r\n    return resultPromise;\r\n  };\r\n  const callNext = () => {\r\n    scheduledCall = null;\r\n    return startAsyncCall();\r\n  };\r\n  const scheduleNextCall = () => {\r\n    if (scheduledCall == null) {\r\n      invariant(pendingCall, 'pendingCall must not be null!');\r\n      scheduledCall = pendingCall.then(callNext, callNext);\r\n    }\r\n    return scheduledCall;\r\n  };\r\n  return () => {\r\n    if (pendingCall == null) {\r\n      return startAsyncCall();\r\n    } else {\r\n      return scheduleNextCall();\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Provides a promise along with methods to change its state. Our version of the non-standard\r\n * `Promise.defer()`.\r\n *\r\n * IMPORTANT: This should almost never be used!! Instead, use the Promise constructor. See\r\n *  <https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern>\r\n */\r\nexport class Deferred<T> {\r\n  promise: Promise<T>;\r\n  resolve: (value: T) => void;\r\n  reject: (error: Error) => void;\r\n\r\n  constructor() {\r\n    this.promise = new Promise((resolve, reject) => {\r\n      this.resolve = resolve;\r\n      this.reject = reject;\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a value derived asynchronously from an element in the items array.\r\n * The test function is applied sequentially to each element in items until\r\n * one returns a Promise that resolves to a non-null value. When this happens,\r\n * the Promise returned by this method will resolve to that non-null value. If\r\n * no such Promise is produced, then the Promise returned by this function\r\n * will resolve to null.\r\n *\r\n * @param items Array of elements that will be passed to test, one at a time.\r\n * @param test Will be called with each item and must return either:\r\n *     (1) A \"thenable\" (i.e, a Promise or promise-like object) that resolves\r\n *         to a derived value (that will be returned) or null.\r\n *     (2) null.\r\n *     In both cases where null is returned, test will be applied to the next\r\n *     item in the array.\r\n * @param thisArg Receiver that will be used when test is called.\r\n * @return Promise that resolves to an asynchronously derived value or null.\r\n */\r\nexport function asyncFind<T, U>(\r\n  items_: Array<T>,\r\n  test: (t: T) => ?Promise<?U>,\r\n  thisArg?: mixed,\r\n): Promise<?U> {\r\n  let items = items_;\r\n  return new Promise((resolve, reject) => {\r\n    // Create a local copy of items to defend against the caller modifying the\r\n    // array before this Promise is resolved.\r\n    items = items.slice();\r\n    const numItems = items.length;\r\n\r\n    const next = async function(index) {\r\n      if (index === numItems) {\r\n        resolve(null);\r\n        return;\r\n      }\r\n\r\n      const item = items[index];\r\n      const result = await test.call(thisArg, item);\r\n      if (result != null) {\r\n        resolve(result);\r\n      } else {\r\n        next(index + 1);\r\n      }\r\n    };\r\n\r\n    next(0);\r\n  });\r\n}\r\n\r\nexport function denodeify(\r\n  f: (...args: Array<any>) => any,\r\n): (...args: Array<any>) => Promise<any> {\r\n  return function(...args: Array<any>) {\r\n    return new Promise((resolve, reject) => {\r\n      function callback(error, result) {\r\n        if (error) {\r\n          reject(error);\r\n        } else {\r\n          resolve(result);\r\n        }\r\n      }\r\n      f.apply(this, args.concat([callback]));\r\n    });\r\n  };\r\n}\r\n\r\n/**\r\n * A Promise utility that runs a maximum of limit async operations at a time\r\n * iterating over an array and returning the result of executions.\r\n * e.g. to limit the number of file reads to 5,\r\n * replace the code:\r\n *    var fileContents = await Promise.all(filePaths.map(fsPromise.readFile))\r\n * with:\r\n *    var fileContents = await asyncLimit(filePaths, 5, fsPromise.readFile)\r\n *\r\n * This is particulrily useful to limit IO operations to a configurable maximum (to avoid\r\n * blocking), while enjoying the configured level of parallelism.\r\n *\r\n * @param array the array of items for iteration.\r\n * @param limit the configurable number of parallel async operations.\r\n * @param mappingFunction the async Promise function that could return a useful result.\r\n */\r\nexport function asyncLimit<T, V>(\r\n  array: Array<T>,\r\n  limit: number,\r\n  mappingFunction: (item: T) => Promise<V>,\r\n): Promise<Array<V>> {\r\n  const result: Array<V> = new Array(array.length);\r\n  let parallelPromises = 0;\r\n  let index = 0;\r\n\r\n  let parallelLimit = Math.min(limit, array.length) || 1;\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const runPromise = async () => {\r\n      if (index === array.length) {\r\n        if (parallelPromises === 0) {\r\n          resolve(result);\r\n        }\r\n        return;\r\n      }\r\n      ++parallelPromises;\r\n      const i = index++;\r\n      try {\r\n        result[i] = await mappingFunction(array[i]);\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n      --parallelPromises;\r\n      runPromise();\r\n    };\r\n\r\n    while (parallelLimit--) {\r\n      runPromise();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * `filter` Promise utility that allows filtering an array with an async Promise function.\r\n * It's an alternative to `Array.prototype.filter` that accepts an async function.\r\n * You can optionally configure a limit to set the maximum number of async operations at a time.\r\n *\r\n * Previously, with the `Promise.all` primitive, we can't set the parallelism limit and we have to\r\n * `filter`, so, we replace the old `filter` code:\r\n *     var existingFilePaths = [];\r\n *     await Promise.all(filePaths.map(async (filePath) => {\r\n *       if (await fsPromise.exists(filePath)) {\r\n *         existingFilePaths.push(filePath);\r\n *       }\r\n *     }));\r\n * with limit 5 parallel filesystem operations at a time:\r\n *    var existingFilePaths = await asyncFilter(filePaths, fsPromise.exists, 5);\r\n *\r\n * @param array the array of items for `filter`ing.\r\n * @param filterFunction the async `filter` function that returns a Promise that resolves to a\r\n *   boolean.\r\n * @param limit the configurable number of parallel async operations.\r\n */\r\nexport async function asyncFilter<T>(\r\n  array: Array<T>,\r\n  filterFunction: (item: T) => Promise<boolean>,\r\n  limit?: number,\r\n): Promise<Array<T>> {\r\n  const filteredList = [];\r\n  // flowlint-next-line sketchy-null-number:off\r\n  await asyncLimit(array, limit || array.length, async (item: T) => {\r\n    if (await filterFunction(item)) {\r\n      filteredList.push(item);\r\n    }\r\n  });\r\n  return filteredList;\r\n}\r\n\r\nexport async function asyncObjFilter<T>(\r\n  obj: {[key: string]: T},\r\n  filterFunction: (item: T, key: string) => Promise<boolean>,\r\n  limit?: number,\r\n): Promise<{[key: string]: T}> {\r\n  const keys = Object.keys(obj);\r\n  const filteredObj = {};\r\n  // flowlint-next-line sketchy-null-number:off\r\n  await asyncLimit(keys, limit || keys.length, async (key: string) => {\r\n    const item = obj[key];\r\n    if (await filterFunction(item, key)) {\r\n      filteredObj[key] = item;\r\n    }\r\n  });\r\n  return filteredObj;\r\n}\r\n\r\n/**\r\n * `some` Promise utility that allows `some` an array with an async Promise some function.\r\n * It's an alternative to `Array.prototype.some` that accepts an async some function.\r\n * You can optionally configure a limit to set the maximum number of async operations at a time.\r\n *\r\n * Previously, with the Promise.all primitive, we can't set the parallelism limit and we have to\r\n * `some`, so, we replace the old `some` code:\r\n *     var someFileExist = false;\r\n *     await Promise.all(filePaths.map(async (filePath) => {\r\n *       if (await fsPromise.exists(filePath)) {\r\n *         someFileExist = true;\r\n *       }\r\n *     }));\r\n * with limit 5 parallel filesystem operations at a time:\r\n *    var someFileExist = await asyncSome(filePaths, fsPromise.exists, 5);\r\n *\r\n * @param array the array of items for `some`ing.\r\n * @param someFunction the async `some` function that returns a Promise that resolves to a\r\n *   boolean.\r\n * @param limit the configurable number of parallel async operations.\r\n */\r\nexport async function asyncSome<T>(\r\n  array: Array<T>,\r\n  someFunction: (item: T) => Promise<boolean>,\r\n  limit?: number,\r\n): Promise<boolean> {\r\n  let resolved = false;\r\n  // flowlint-next-line sketchy-null-number:off\r\n  await asyncLimit(array, limit || array.length, async (item: T) => {\r\n    if (resolved) {\r\n      // We don't need to call the someFunction anymore or wait any longer.\r\n      return;\r\n    }\r\n    if (await someFunction(item)) {\r\n      resolved = true;\r\n    }\r\n  });\r\n  return resolved;\r\n}\r\n\r\n/**\r\n * Check if an object is Promise by testing if it has a `then` function property.\r\n */\r\nexport function isPromise(object: any): boolean {\r\n  return (\r\n    Boolean(object) &&\r\n    typeof object === 'object' &&\r\n    typeof object.then === 'function'\r\n  );\r\n}\r\n\r\n/**\r\n * We can't name a function 'finally', so use lastly instead.\r\n * fn() will be executed (and completed) after the provided promise resolves/rejects.\r\n */\r\nexport function lastly<T>(\r\n  promise: Promise<T>,\r\n  fn: () => Promise<mixed> | mixed,\r\n): Promise<T> {\r\n  return promise.then(\r\n    ret => {\r\n      return Promise.resolve(fn()).then(() => ret);\r\n    },\r\n    err => {\r\n      return Promise.resolve(fn()).then(() => Promise.reject(err));\r\n    },\r\n  );\r\n}\r\n\r\n/**\r\n * With a pure promise object, there's no way to tell synchronously\r\n * whether or not it has 'settled' (i.e. been fulfilled or rejected).\r\n * Here we provide a wrapper that provides that information.\r\n */\r\nexport type PromiseState<T> =\r\n  | {kind: 'pending'}\r\n  | {kind: 'fulfilled', value: T}\r\n  | {kind: 'rejected', error: any};\r\n\r\nexport class PromiseWithState<T> {\r\n  _promise: Promise<T>;\r\n  _state: PromiseState<T>;\r\n\r\n  constructor(promise: Promise<T>) {\r\n    this._state = {kind: 'pending'};\r\n    this._promise = promise.then(\r\n      value => {\r\n        this._state = {kind: 'fulfilled', value};\r\n        return value;\r\n      },\r\n      error => {\r\n        this._state = {kind: 'rejected', error};\r\n        throw error;\r\n      },\r\n    );\r\n  }\r\n\r\n  getPromise(): Promise<T> {\r\n    return this._promise;\r\n  }\r\n\r\n  getState(): PromiseState<T> {\r\n    return this._state;\r\n  }\r\n}\r\n\r\nexport function delayTime(ms: number): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\n/* global performance */\r\n\r\n/**\r\n * Polyfill for performance.now that works both on Atom (chrome) and node.\r\n * It returns a monotonically increasing timer in milliseconds.\r\n *\r\n * Usage:\r\n *   const now = performanceNow();\r\n *   // ... code you want to benchmark ...\r\n *   const timeItTookInMilliseconds = performanceNow() - now;\r\n */\r\n\r\nexport default (typeof performance !== 'undefined'\r\n  ? (): number => performance.now()\r\n  : (): number => {\r\n      const [seconds, nanoseconds] = process.hrtime();\r\n      return seconds * 1000 + nanoseconds / 1000000;\r\n    });\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport type {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport getDisplayName from './getDisplayName';\r\nimport UniversalDisposable from './UniversalDisposable';\r\nimport {isPromise} from './promise';\r\nimport performanceNow from './performanceNow';\r\n\r\nexport type SessionInfo = {\r\n  id: string,\r\n  start: number,\r\n};\r\n\r\nexport type RawAnalyticsService = {\r\n  track(\r\n    eventName: string,\r\n    values?: {[key: string]: mixed},\r\n    immediate?: boolean,\r\n  ): ?Promise<mixed>,\r\n  isTrackSupported: () => boolean,\r\n  setApplicationSessionObservable: (Observable<SessionInfo>) => void,\r\n};\r\n\r\nlet rawAnalyticsService: RawAnalyticsService = {\r\n  track(): ?Promise<mixed> {},\r\n  isTrackSupported: () => false,\r\n  setApplicationSessionObservable: (ob: Observable<SessionInfo>) => {},\r\n};\r\n\r\nexport type TrackingEvent = {\r\n  type: string,\r\n  data?: Object,\r\n};\r\n\r\nexport type TrackEvent = {\r\n  key: string,\r\n  values: {[key: string]: mixed},\r\n};\r\n\r\n/**\r\n * Track a set of values against a named event.\r\n * Analytics will be batched and processed asynchronously in the background.\r\n *\r\n * @param eventName Name of the event to be tracked.\r\n * @param values The object containing the data to track.\r\n */\r\nexport function track(\r\n  eventName: string,\r\n  values?: {[key: string]: mixed},\r\n): void {\r\n  rawAnalyticsService.track(eventName, values || {});\r\n}\r\n\r\nexport function isTrackSupported(): boolean {\r\n  return rawAnalyticsService.isTrackSupported();\r\n}\r\n\r\n/**\r\n * Same as `track`, except this is guaranteed to send immediately.\r\n * The returned promise will resolve when the request completes (or reject on failure).\r\n */\r\nexport function trackImmediate(\r\n  eventName: string,\r\n  values?: {[key: string]: mixed},\r\n): Promise<mixed> {\r\n  return (\r\n    rawAnalyticsService.track(eventName, values || {}, true) ||\r\n    Promise.resolve()\r\n  );\r\n}\r\n\r\n/**\r\n * An alternative interface for `track` that accepts a single event object. This is particularly\r\n * useful when dealing with streams (Observables).\r\n */\r\nexport function trackEvent(event: TrackingEvent): void {\r\n  track(event.type, event.data);\r\n}\r\n\r\n/**\r\n * Track each event in a stream of TrackingEvents.\r\n */\r\nexport function trackEvents(events: Observable<TrackingEvent>): IDisposable {\r\n  return new UniversalDisposable(events.subscribe(trackEvent));\r\n}\r\n\r\n/**\r\n * A sampled version of track that only tracks every 1/sampleRate calls.\r\n */\r\nexport function trackSampled(\r\n  eventName: string,\r\n  sampleRate: number,\r\n  values?: {[key: string]: mixed},\r\n): void {\r\n  if (Math.random() * sampleRate <= 1) {\r\n    rawAnalyticsService.track(eventName, {\r\n      ...values,\r\n      sample_rate: sampleRate,\r\n    });\r\n  }\r\n}\r\n\r\nconst PERFORMANCE_EVENT = 'performance';\r\nconst canMeasure = typeof performance !== 'undefined';\r\nexport class TimingTracker {\r\n  static eventCount = 0;\r\n\r\n  _eventName: string;\r\n  _startTime: number;\r\n  _startMark: string;\r\n  _values: {[key: string]: mixed};\r\n\r\n  constructor(eventName: string, values: {[key: string]: mixed}) {\r\n    this._eventName = eventName;\r\n    this._startMark = `${this._eventName}_${TimingTracker.eventCount++}_start`;\r\n    this._startTime = performanceNow();\r\n    this._values = values;\r\n    if (canMeasure) {\r\n      // eslint-disable-next-line no-undef\r\n      performance.mark(this._startMark);\r\n    }\r\n  }\r\n\r\n  onError(error: Error): void {\r\n    this._trackTimingEvent(error);\r\n  }\r\n\r\n  onCancel(): void {\r\n    this._trackTimingEvent(/* error */ null, true);\r\n  }\r\n\r\n  onSuccess(): void {\r\n    this._trackTimingEvent(/* error */ null);\r\n  }\r\n\r\n  _trackTimingEvent(exception: ?Error, canceled: boolean = false): void {\r\n    if (canMeasure) {\r\n      /* eslint-disable no-undef */\r\n      // call measure to add this information to the devtools timeline in the\r\n      // case the profiler is running.\r\n      performance.measure(this._eventName, this._startMark);\r\n      // then clear all the marks and measurements to avoid growing the\r\n      // performance entry buffer\r\n      performance.clearMarks(this._startMark);\r\n      performance.clearMeasures(this._eventName);\r\n      /* eslint-enable no-undef */\r\n    }\r\n\r\n    track(PERFORMANCE_EVENT, {\r\n      ...this._values,\r\n      duration: Math.round(performanceNow() - this._startTime).toString(),\r\n      eventName: this._eventName,\r\n      error: exception ? '1' : '0',\r\n      exception: exception ? exception.toString() : '',\r\n      canceled,\r\n    });\r\n  }\r\n}\r\n\r\nexport function startTracking(\r\n  eventName: string,\r\n  values?: {[key: string]: any} = {},\r\n): TimingTracker {\r\n  return new TimingTracker(eventName, values);\r\n}\r\n\r\n/**\r\n * Reports analytics including timing for a single operation.\r\n *\r\n * Usage:\r\n *\r\n * analytics.trackTiming('my-package-some-long-operation' () => doit());\r\n *\r\n * Returns (or throws) the result of the operation.\r\n */\r\nexport function trackTiming<T>(\r\n  eventName: string,\r\n  operation: () => T,\r\n  values?: {[key: string]: any} = {},\r\n): T {\r\n  const tracker = startTracking(eventName, values);\r\n\r\n  try {\r\n    const result = operation();\r\n\r\n    if (isPromise(result)) {\r\n      // Atom uses a different Promise implementation than Nuclide, so the following is not true:\r\n      // invariant(result instanceof Promise);\r\n\r\n      // For the method returning a Promise, track the time after the promise is resolved/rejected.\r\n      return (result: any).then(\r\n        value => {\r\n          tracker.onSuccess();\r\n          return value;\r\n        },\r\n        reason => {\r\n          tracker.onError(reason instanceof Error ? reason : new Error(reason));\r\n          return Promise.reject(reason);\r\n        },\r\n      );\r\n    } else {\r\n      tracker.onSuccess();\r\n      return result;\r\n    }\r\n  } catch (error) {\r\n    tracker.onError(error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport function decorateTrackTiming<U: Array<*>, T>(\r\n  fn: (...args: U) => T,\r\n  values?: {[key: string]: any} = {},\r\n): (...args: U) => T {\r\n  const name = getDisplayName(fn);\r\n  function decoratedTrackTiming(...args: U) {\r\n    return trackTiming(name, fn.bind(this, ...args), values);\r\n  }\r\n  decoratedTrackTiming.displayName = `trackTiming(${name})`;\r\n  return decoratedTrackTiming;\r\n}\r\n\r\n/**\r\n * A sampled version of trackTiming that only tracks every 1/sampleRate calls.\r\n */\r\nexport function trackTimingSampled<T>(\r\n  eventName: string,\r\n  operation: () => T,\r\n  sampleRate: number,\r\n  values?: {[key: string]: any} = {},\r\n): T {\r\n  if (Math.random() * sampleRate <= 1) {\r\n    return trackTiming(eventName, operation, {\r\n      ...values,\r\n      sample_rate: sampleRate,\r\n    });\r\n  }\r\n  return operation();\r\n}\r\n\r\nexport function decorateTrackTimingSampled<U: Array<*>, T>(\r\n  fn: (...args: U) => T,\r\n  sampleRate: number,\r\n  values?: {[key: string]: any} = {},\r\n): (...args: U) => T {\r\n  const name = getDisplayName(fn);\r\n  function decoratedTrackTimingSampled(...args: U) {\r\n    return trackTimingSampled(name, fn.bind(this, ...args), sampleRate, values);\r\n  }\r\n  decoratedTrackTimingSampled.displayName = `trackTimingSampled(${name})`;\r\n  return decoratedTrackTimingSampled;\r\n}\r\n\r\nexport function setRawAnalyticsService(\r\n  analyticsService: RawAnalyticsService,\r\n  ob: Observable<SessionInfo>,\r\n): void {\r\n  analyticsService.setApplicationSessionObservable(ob);\r\n  rawAnalyticsService = analyticsService;\r\n}\r\n\r\nexport default {\r\n  track,\r\n  trackSampled,\r\n  trackEvent,\r\n  trackTiming,\r\n  trackTimingSampled,\r\n  startTracking,\r\n  TimingTracker,\r\n  decorateTrackTiming,\r\n  decorateTrackTimingSampled,\r\n};\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport UniversalDisposable from '@atom-ide-community/nuclide-commons/UniversalDisposable';\r\n\r\nexport type Provider = {\r\n  // Providers with higher priorities will be preferred over lower ones.\r\n  priority: number,\r\n  // Omitting grammarScopes implies that the provider applies to all grammars.\r\n  +grammarScopes?: Array<string>,\r\n};\r\n\r\nexport default class ProviderRegistry<T: Provider> {\r\n  _providers: Array<T>;\r\n\r\n  constructor() {\r\n    this._providers = [];\r\n  }\r\n\r\n  addProvider(provider: T): IDisposable {\r\n    const index = this._providers.findIndex(\r\n      p => provider.priority > p.priority,\r\n    );\r\n    if (index === -1) {\r\n      this._providers.push(provider);\r\n    } else {\r\n      this._providers.splice(index, 0, provider);\r\n    }\r\n    return new UniversalDisposable(() => {\r\n      this.removeProvider(provider);\r\n    });\r\n  }\r\n\r\n  removeProvider(provider: T): void {\r\n    const index = this._providers.indexOf(provider);\r\n    if (index !== -1) {\r\n      this._providers.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  // TODO deprecate since there can be N providers.\r\n  getProviderForEditor(editor: atom$TextEditor): ?T {\r\n    const grammar = editor.getGrammar().scopeName;\r\n    return this.findProvider(grammar);\r\n  }\r\n\r\n  // TODO create an ordering or priority aware util to prefer instead.\r\n  getAllProvidersForEditor(editor: atom$TextEditor): Iterable<T> {\r\n    const grammar = editor.getGrammar().scopeName;\r\n    return this.findAllProviders(grammar);\r\n  }\r\n\r\n  findProvider(grammar: string): ?T {\r\n    for (const provider of this.findAllProviders(grammar)) {\r\n      return provider;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Iterates over all providers matching the grammar, in priority order.\r\n   */\r\n  *findAllProviders(grammar: string): Iterable<T> {\r\n    for (const provider of this._providers) {\r\n      if (\r\n        provider.grammarScopes == null ||\r\n        provider.grammarScopes.indexOf(grammar) !== -1\r\n      ) {\r\n        yield provider;\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport UniversalDisposable from './UniversalDisposable';\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\n/**\r\n * Add an event listener an return a disposable for removing it. Note that this function assumes\r\n * node EventEmitter semantics: namely, that adding the same combination of eventName and callback\r\n * adds a second listener.\r\n */\r\nexport function attachEvent(\r\n  emitter: events$EventEmitter,\r\n  eventName: string,\r\n  callback: Function,\r\n): IDisposable {\r\n  emitter.addListener(eventName, callback);\r\n  return new UniversalDisposable(() => {\r\n    emitter.removeListener(eventName, callback);\r\n  });\r\n}\r\n\r\ntype SubscribeCallback<T> = (item: T) => any;\r\ntype SubscribeFunction<T> = (\r\n  callback: SubscribeCallback<T>,\r\n) => IDisposable | (() => mixed);\r\n\r\nexport function observableFromSubscribeFunction<T>(\r\n  fn: SubscribeFunction<T>,\r\n): Observable<T> {\r\n  return Observable.create(\r\n    observer => new UniversalDisposable(fn(observer.next.bind(observer))),\r\n  );\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport type {NuclideUri} from '@atom-ide-community/nuclide-commons/nuclideUri';\r\n\r\nimport invariant from 'assert';\r\nimport {TextEditor} from 'atom';\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport {observableFromSubscribeFunction} from '@atom-ide-community/nuclide-commons/event';\r\n\r\n/**\r\n * Returns a text editor that has the given path open, or null if none exists. If there are multiple\r\n * text editors for this path, one is chosen arbitrarily.\r\n */\r\nexport function existingEditorForUri(path: NuclideUri): ?atom$TextEditor {\r\n  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a\r\n  // real problem. And if you have more than a few hundred you probably have bigger problems.\r\n  for (const editor of atom.workspace.getTextEditors()) {\r\n    if (editor.getPath() === path) {\r\n      return editor;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Returns a text editor that has the given buffer open, or null if none exists. If there are\r\n * multiple text editors for this buffer, one is chosen arbitrarily.\r\n */\r\nexport function existingEditorForBuffer(\r\n  buffer: atom$TextBuffer,\r\n): ?atom$TextEditor {\r\n  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a\r\n  // real problem. And if you have more than a few hundred you probably have bigger problems.\r\n  for (const editor of atom.workspace.getTextEditors()) {\r\n    if (editor.getBuffer() === buffer) {\r\n      return editor;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getViewOfEditor(\r\n  editor: atom$TextEditor,\r\n): atom$TextEditorElement {\r\n  return atom.views.getView(editor);\r\n}\r\n\r\nexport function getScrollTop(editor: atom$TextEditor): number {\r\n  return getViewOfEditor(editor).getScrollTop();\r\n}\r\n\r\nexport function setScrollTop(editor: atom$TextEditor, scrollTop: number): void {\r\n  getViewOfEditor(editor).setScrollTop(scrollTop);\r\n}\r\n\r\n/**\r\n * Does a best effort to set an editor pane to a given cursor position & scroll.\r\n * Does not ensure that the current cursor position is visible.\r\n *\r\n * Can be used with editor.getCursorBufferPosition() & getScrollTop() to restore\r\n * an editors cursor and scroll.\r\n */\r\nexport function setPositionAndScroll(\r\n  editor: atom$TextEditor,\r\n  position: atom$Point,\r\n  scrollTop: number,\r\n): void {\r\n  editor.setCursorBufferPosition(position, {autoscroll: false});\r\n  setScrollTop(editor, scrollTop);\r\n}\r\n\r\nexport function getCursorPositions(\r\n  editor: atom$TextEditor,\r\n): Observable<atom$Point> {\r\n  return Observable.defer(() => {\r\n    // This will behave strangely in the face of multiple cursors. Consider supporting multiple\r\n    // cursors in the future.\r\n    const cursor = editor.getCursors()[0];\r\n    invariant(cursor != null);\r\n    return Observable.merge(\r\n      Observable.of(cursor.getBufferPosition()),\r\n      observableFromSubscribeFunction(\r\n        cursor.onDidChangePosition.bind(cursor),\r\n      ).map(event => event.newBufferPosition),\r\n    );\r\n  });\r\n}\r\n\r\nexport function observeEditorDestroy(\r\n  editor: atom$TextEditor,\r\n): Observable<atom$TextEditor> {\r\n  return observableFromSubscribeFunction(editor.onDidDestroy.bind(editor))\r\n    .map(event => editor)\r\n    .take(1);\r\n}\r\n\r\n// Use atom readOnly attribute to set read-only state.\r\nexport function enforceReadOnlyEditor(\r\n  textEditor: atom$TextEditor,\r\n  readOnlyExceptions?: Array<string> = ['append', 'setText'],\r\n): IDisposable {\r\n  textEditor.getElement().setAttribute('readonly', '');\r\n  return {\r\n    dispose() {\r\n      textEditor.getElement().removeAttribute('readonly');\r\n    },\r\n  };\r\n}\r\n\r\n// Turn off soft wrap setting for these editors so diffs properly align.\r\n// Some text editor register sometimes override the set soft wrapping\r\n// after mounting an editor to the workspace - here, that's watched and reset to `false`.\r\nexport function enforceSoftWrap(\r\n  editor: atom$TextEditor,\r\n  enforcedSoftWrap: boolean,\r\n): IDisposable {\r\n  editor.setSoftWrapped(enforcedSoftWrap);\r\n  return editor.onDidChangeSoftWrapped(softWrapped => {\r\n    if (softWrapped !== enforcedSoftWrap) {\r\n      // Reset the overridden softWrap to `false` once the operation completes.\r\n      process.nextTick(() => {\r\n        if (!editor.isDestroyed()) {\r\n          editor.setSoftWrapped(enforcedSoftWrap);\r\n        }\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Checks if an object (typically an Atom pane) is a TextEditor.\r\n * Could be replaced with atom.workspace.isValidTextEditor,\r\n * but Flow doesn't support %checks in methods yet.\r\n */\r\nexport function isValidTextEditor(item: mixed): boolean %checks {\r\n  return item instanceof TextEditor;\r\n}\r\n\r\nexport function centerScrollToBufferLine(\r\n  textEditorElement: atom$TextEditorElement,\r\n  bufferLineNumber: number,\r\n): void {\r\n  const textEditor = textEditorElement.getModel();\r\n  const pixelPositionTop = textEditorElement.pixelPositionForBufferPosition([\r\n    bufferLineNumber,\r\n    0,\r\n  ]).top;\r\n  // Manually calculate the scroll location, instead of using\r\n  // `textEditor.scrollToBufferPosition([lineNumber, 0], {center: true})`\r\n  // because that API to wouldn't center the line if it was in the visible screen range.\r\n  const scrollTop =\r\n    pixelPositionTop +\r\n    textEditor.getLineHeightInPixels() / 2 -\r\n    textEditorElement.clientHeight / 2;\r\n  textEditorElement.setScrollTop(Math.max(scrollTop, 1));\r\n\r\n  textEditorElement.focus();\r\n\r\n  textEditor.setCursorBufferPosition([bufferLineNumber, 0], {\r\n    autoscroll: false,\r\n  });\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\nimport type {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport {getLogger} from 'log4js';\r\nimport {Subject} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\nimport invariant from 'assert';\r\n\r\nexport type GoToLocationOptions = {|\r\n  line?: number,\r\n  column?: number,\r\n  center?: boolean,\r\n  activateItem?: boolean,\r\n  activatePane?: boolean,\r\n  pending?: boolean,\r\n  moveCursor?: boolean,\r\n|};\r\n\r\n/**\r\n * Opens the given file.\r\n *\r\n * Optionally include a line and column to navigate to. If a line is given, by default it will\r\n * center it in the opened text editor.\r\n *\r\n * This should be preferred over `atom.workspace.open()` in typical cases. The motivations are:\r\n * - We call `atom.workspace.open()` with the `searchAllPanes` option. This looks in other panes for\r\n *   the current file, rather just opening a new copy in the current pane. People often forget this\r\n *   option which typically leads to a subpar experience for people who use multiple panes.\r\n * - When moving around in the current file, `goToLocation` explicitly publishes events that the nav\r\n *   stack uses.\r\n *\r\n * Currently, `atom.workspace.open()` should be used only in these cases:\r\n * - When the URI to open is not a file URI. For example, if we want to open some tool like find\r\n *   references in a pane.\r\n * - When we want to open an untitled file (providing no file argument). Currently, goToLocation\r\n *   requires a file to open.\r\n * - When we want to open a file as a pending pane item. Currently goToLocation cannot do this.\r\n *\r\n * In these cases, you may disable the lint rule against `atom.workspace.open` by adding the\r\n * following comment above its use:\r\n * // eslint-disable-next-line nuclide-internal/atom-apis\r\n */\r\nexport async function goToLocation(\r\n  file: string,\r\n  options?: ?GoToLocationOptions,\r\n): Promise<atom$TextEditor> {\r\n  const center = options?.center ?? true;\r\n  const moveCursor = options?.moveCursor ?? true;\r\n  const activatePane = options?.activatePane ?? true;\r\n  const activateItem = options?.activateItem;\r\n  const line = options?.line;\r\n  const column = options?.column;\r\n  const pending = options?.pending;\r\n\r\n  // Prefer going to the current editor rather than the leftmost editor.\r\n  const currentEditor = atom.workspace.getActiveTextEditor();\r\n  if (currentEditor != null && currentEditor.getPath() === file) {\r\n    const paneContainer = atom.workspace.paneContainerForItem(currentEditor);\r\n    invariant(paneContainer != null);\r\n    if (activatePane) {\r\n      paneContainer.activate();\r\n    }\r\n    if (line != null) {\r\n      goToLocationInEditor(currentEditor, {\r\n        line,\r\n        column: column == null ? 0 : column,\r\n        center,\r\n        moveCursor,\r\n      });\r\n    } else {\r\n      invariant(column == null, 'goToLocation: Cannot specify just column');\r\n    }\r\n    return currentEditor;\r\n  } else {\r\n    // Obviously, calling goToLocation isn't a viable alternative here :P\r\n    // eslint-disable-next-line nuclide-internal/atom-apis\r\n    const editor = await atom.workspace.open(file, {\r\n      initialLine: line,\r\n      initialColumn: column,\r\n      searchAllPanes: true,\r\n      activatePane,\r\n      activateItem,\r\n      pending,\r\n    });\r\n    // TODO(T28305560) Investigate offenders for this error\r\n    if (editor == null) {\r\n      const tmp = {};\r\n      Error.captureStackTrace(tmp);\r\n      const error = Error(`atom.workspace.open returned null on ${file}`);\r\n      getLogger('goToLocation').error(error);\r\n      throw error;\r\n    }\r\n\r\n    if (center && line != null) {\r\n      editor.scrollToBufferPosition([line, column], {center: true});\r\n    }\r\n    return editor;\r\n  }\r\n}\r\n\r\nconst goToLocationSubject = new Subject();\r\n\r\ntype GotoLocationInEditorOptions = {|\r\n  line: number,\r\n  column: number,\r\n  center?: boolean,\r\n  moveCursor?: boolean,\r\n|};\r\n\r\n// Scrolls to the given line/column at the given editor\r\n// broadcasts the editor instance on an observable (subject) available\r\n// through the getGoToLocation\r\nexport function goToLocationInEditor(\r\n  editor: atom$TextEditor,\r\n  options: GotoLocationInEditorOptions,\r\n): void {\r\n  const center = options.center == null ? true : options.center;\r\n  const moveCursor = options.moveCursor == null ? true : options.moveCursor;\r\n  const {line, column} = options;\r\n\r\n  if (moveCursor) {\r\n    editor.setCursorBufferPosition([line, column]);\r\n  }\r\n  if (center) {\r\n    editor.scrollToBufferPosition([line, column], {center: true});\r\n  }\r\n\r\n  goToLocationSubject.next(editor);\r\n}\r\n\r\nexport function observeNavigatingEditors(): Observable<atom$TextEditor> {\r\n  return goToLocationSubject;\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\nimport type {NuclideUri} from '@atom-ide-community/nuclide-commons/nuclideUri';\r\n\r\nimport invariant from 'assert';\r\nimport {getLogger} from 'log4js';\r\n\r\nimport {existingEditorForUri} from './text-editor';\r\nimport {goToLocation} from './go-to-location';\r\n\r\nexport type TextEdit = {\r\n  oldRange: atom$Range,\r\n  newText: string,\r\n  // If included, this will be used to verify that the edit still applies cleanly.\r\n  oldText?: string,\r\n};\r\n\r\n/**\r\n * Attempts to apply the given patches for multiple files. Accepts a Map as input\r\n * with file paths as keys and a corresponding array of TextEdits as values.\r\n *\r\n * It is an error to send overlapping text-edits. All text-edits describe changes\r\n * made to the initial document version. The order of the edits does not matter\r\n * as they will be sorted before they are applied.\r\n *\r\n * All changes will be applied to the buffers but not saved. If a file is not\r\n * currently open, it will be opened.\r\n *\r\n * If a change is undone (Cmd+Z), only the changes of the current\r\n * file will be undone. All of the changes for that file will be undone at once.\r\n *\r\n * Returns true if the application was successful, otherwise false. If any of\r\n * the changes fail, for ANY file, then none of the changes are applied.\r\n */\r\nexport async function applyTextEditsForMultipleFiles(\r\n  changes: Map<NuclideUri, Array<TextEdit>>,\r\n): Promise<boolean> {\r\n  const paths = Array.from(changes.keys());\r\n\r\n  // NOTE: There is a race here. If the file contents change while the\r\n  // editors are being opened, then the ranges of the TextEdits will be off.\r\n  // However, currently this is only used to applyEdits to open files.\r\n  const editors = await Promise.all(\r\n    paths.map(async path => goToLocation(path)),\r\n  );\r\n  const checkpoints = editors.map(editor => {\r\n    invariant(editor != null);\r\n    const buffer = editor.getBuffer();\r\n    return [buffer, buffer.createCheckpoint()];\r\n  });\r\n  const allOkay = paths.reduce((successSoFar, path) => {\r\n    const edits = changes.get(path);\r\n    return successSoFar && edits != null && applyTextEdits(path, ...edits);\r\n  }, true);\r\n  if (!allOkay) {\r\n    checkpoints.forEach(([buffer, checkPoint]) => {\r\n      buffer.revertToCheckpoint(checkPoint);\r\n      return false;\r\n    });\r\n  }\r\n  return allOkay;\r\n}\r\n\r\n/**\r\n * Attempts to apply the given patches to the given file.\r\n *\r\n * It is an error to send overlapping edits. The order of the edits does not\r\n * matter (they will be sorted before they are applied).\r\n *\r\n * The file must be currently open in Atom, and the changes will be applied to the buffer but not\r\n * saved.\r\n *\r\n * Returns true if the application was successful, otherwise false (e.g. if the oldText did not\r\n * match).\r\n */\r\nexport function applyTextEdits(\r\n  path: NuclideUri,\r\n  ...edits: Array<TextEdit>\r\n): boolean {\r\n  const sortedEdits = sortEdits(edits);\r\n  const editor = existingEditorForUri(path);\r\n  invariant(editor != null);\r\n  return applySortedTextEditsToBuffer(editor.getBuffer(), sortedEdits);\r\n}\r\n\r\nexport function applyTextEditsToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edits: Array<TextEdit>,\r\n): boolean {\r\n  return applySortedTextEditsToBuffer(buffer, sortEdits(edits));\r\n}\r\n\r\nfunction applySortedTextEditsToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edits: Array<TextEdit>,\r\n): boolean {\r\n  // For every edit, the start of its range will be after the end of the\r\n  // previous edit's range.\r\n  if (editsOverlap(edits)) {\r\n    getLogger('text-edit').warn(\r\n      'applyTextEdits was called with overlapping edits.',\r\n    );\r\n    return false;\r\n  }\r\n  // Special-case whole-buffer changes to minimize disruption.\r\n  if (edits.length === 1 && edits[0].oldRange.isEqual(buffer.getRange())) {\r\n    if (edits[0].oldText != null && edits[0].oldText !== buffer.getText()) {\r\n      return false;\r\n    }\r\n    buffer.setTextViaDiff(edits[0].newText);\r\n    return true;\r\n  }\r\n\r\n  const checkpoint = buffer.createCheckpoint();\r\n\r\n  // Iterate through in reverse order. Edits earlier in the file can move around text later in the\r\n  // file, so to avoid conflicts edits should be applied last first.\r\n  for (let i = edits.length - 1; i >= 0; i--) {\r\n    const edit = edits[i];\r\n    const success = applyToBuffer(buffer, edit);\r\n    if (!success) {\r\n      buffer.revertToCheckpoint(checkpoint);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  buffer.groupChangesSinceCheckpoint(checkpoint);\r\n  return true;\r\n}\r\n\r\nfunction applyToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edit: TextEdit,\r\n): boolean {\r\n  if (edit.oldRange.start.row === edit.oldRange.end.row) {\r\n    // A little extra validation when the old range spans only one line. In particular, this helps\r\n    // when the old range is empty so there is no old text for us to compare against. We can at\r\n    // least abort if the line isn't long enough.\r\n    const lineLength = buffer.lineLengthForRow(edit.oldRange.start.row);\r\n    if (edit.oldRange.end.column > lineLength) {\r\n      return false;\r\n    }\r\n  }\r\n  if (edit.oldText != null) {\r\n    const currentText = buffer.getTextInRange(edit.oldRange);\r\n    if (currentText !== edit.oldText) {\r\n      return false;\r\n    }\r\n  }\r\n  buffer.setTextInRange(edit.oldRange, edit.newText);\r\n  return true;\r\n}\r\n\r\n// Returns whether an array of sorted TextEdits contain an overlapping range.\r\nfunction editsOverlap(sortedEdits: Array<TextEdit>): boolean {\r\n  for (let i = 0; i < sortedEdits.length - 1; i++) {\r\n    if (\r\n      sortedEdits[i].oldRange.end.isGreaterThan(\r\n        sortedEdits[i + 1].oldRange.start,\r\n      )\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction sortEdits(edits: Array<TextEdit>): Array<TextEdit> {\r\n  // stable sort (preserve order of edits starting in the same location)\r\n  return edits\r\n    .map((edit, i) => [edit, i])\r\n    .sort(\r\n      ([e1, i1], [e2, i2]) =>\r\n        e1.oldRange.start.compare(e2.oldRange.start) ||\r\n        e1.oldRange.end.compare(e2.oldRange.end) ||\r\n        i1 - i2,\r\n    )\r\n    .map(([edit]) => edit);\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport type {Provider} from './ProviderRegistry';\r\nimport type {TextEdit} from './text-edit';\r\n\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\nimport {track} from '@atom-ide-community/nuclide-commons/analytics';\r\nimport ProviderRegistry from './ProviderRegistry';\r\nimport {applyTextEditsToBuffer} from './text-edit';\r\nimport UniversalDisposable from '@atom-ide-community/nuclide-commons/UniversalDisposable';\r\n\r\nexport type FileEventHandlersConfig = {|\r\n  supportsOnWillSave: boolean,\r\n  onWillSaveTimeout?: number,\r\n  onWillSavePriority?: number,\r\n|};\r\n\r\ntype OnWillSaveProvider = Provider & {\r\n  timeout: number,\r\n  callback: (e: atom$TextEditor) => Observable<TextEdit>,\r\n};\r\n\r\n// Timeouts if providers don't all finish in 5 seconds.\r\nconst GLOBAL_SAVE_TIMEOUT_MS = 5000;\r\nconst onWillSaveProviders: ProviderRegistry<\r\n  OnWillSaveProvider,\r\n> = new ProviderRegistry();\r\n\r\n// Returns an observable of booleans, each of which indicates whether the\r\n// formatting text edits from a given provider was successfully applied or not.\r\nfunction onWillSave(editor: atom$TextEditor): Observable<boolean> {\r\n  if (editor.getPath() == null) {\r\n    return Observable.empty();\r\n  }\r\n\r\n  const providers = Array.from(\r\n    onWillSaveProviders.getAllProvidersForEditor(editor),\r\n  );\r\n  // NOTE: concat() is used here to subscribe to providers sequentially and\r\n  // apply their text edits in order.\r\n  return Observable.concat(\r\n    ...providers.map((provider: OnWillSaveProvider) =>\r\n      provider\r\n        .callback(editor)\r\n        .toArray()\r\n        .race(Observable.of([]).delay(provider.timeout))\r\n        .map(edits => {\r\n          const success = applyTextEditsToBuffer(editor.getBuffer(), edits);\r\n          return success;\r\n        }),\r\n    ),\r\n  );\r\n}\r\n\r\n// HACK: intercept the real TextEditor.save and handle it ourselves.\r\n// Atom has no way of injecting content into the buffer asynchronously\r\n// before a save operation.\r\n// If we try to format after the save, and then save again,\r\n// it's a poor user experience (and also races the text buffer's reload).\r\nfunction patchEditorSave(editor: atom$TextEditor): IDisposable {\r\n  const realSave = editor.save;\r\n  const editor_ = (editor: any);\r\n  editor_.save = async () => {\r\n    const timeout = new Date();\r\n    timeout.setTime(timeout.getTime() + GLOBAL_SAVE_TIMEOUT_MS);\r\n    try {\r\n      await onWillSave(editor_)\r\n        .timeout(timeout)\r\n        .toPromise();\r\n    } catch (e) {\r\n      const providers = Array.from(\r\n        onWillSaveProviders.getAllProvidersForEditor(editor_),\r\n      );\r\n      track('timeout-on-save', {\r\n        uri: editor.getPath(),\r\n        providers,\r\n      });\r\n    } finally {\r\n      await realSave.call(editor);\r\n    }\r\n  };\r\n  return new UniversalDisposable(() => {\r\n    editor_.save = realSave;\r\n  });\r\n}\r\n\r\nexport function registerOnWillSave(provider: OnWillSaveProvider): IDisposable {\r\n  return onWillSaveProviders.addProvider(provider);\r\n}\r\n\r\nexport function observeTextEditors(): IDisposable {\r\n  const disposables = new UniversalDisposable();\r\n  disposables.add(\r\n    atom.workspace.observeTextEditors(editor => {\r\n      disposables.add(patchEditorSave(editor));\r\n    }),\r\n  );\r\n  return disposables;\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\n/**\r\n * A wrapper over the specified Atom's config functions.\r\n * Each individual loaded package's config is a subconfig of the root package.\r\n */\r\n\r\nexport default class ConfigManager {\r\n  _packageName: ?string;\r\n  _config: atom$Config;\r\n\r\n  constructor(config: atom$Config) {\r\n    this._config = config;\r\n  }\r\n\r\n  getConfig(): atom$Config {\r\n    return this._config;\r\n  }\r\n\r\n  /**\r\n   * Sets the root package name.\r\n   * This gets automatically called from FeatureLoader.\r\n   */\r\n  setPackageName(name: string): void {\r\n    this._packageName = name;\r\n  }\r\n\r\n  getPackageName(): string {\r\n    invariant(this._packageName != null, 'No package name available');\r\n    return this._packageName;\r\n  }\r\n\r\n  formatKeyPath(keyPath: string): string {\r\n    if (this._packageName == null) {\r\n      return keyPath;\r\n    }\r\n    return `${this._packageName}.${keyPath}`;\r\n  }\r\n\r\n  /*\r\n   * Returns the value of a setting for a Nuclide feature key. Takes and returns the same types as\r\n   * `atom.config.get` except `keyPath` is not optional. To get the entire config object, use\r\n   * `atom.config.get`.\r\n   *\r\n   * Note: This is intentionally typed as mixed, this way each call site has to\r\n   * first cast it as any and it is obvious that this is an area that is not safe\r\n   * and flow will not proceed if the callsite doesn't do it.\r\n   *\r\n   * Example:\r\n   *   const config: MyConfigType = (featureConfig.get('config-name'): any);\r\n   */\r\n  get(\r\n    keyPath: string,\r\n    options?: {\r\n      excludeSources?: Array<string>,\r\n      sources?: Array<string>,\r\n      scope?: atom$ScopeDescriptorLike,\r\n    },\r\n  ): mixed {\r\n    // atom.config.get will crash if the second arg is present and undefined.\r\n    // It does not crash if the second arg is missing.\r\n    return this._config.get(\r\n      this.formatKeyPath(keyPath),\r\n      ...(options == null ? [] : [options]),\r\n    );\r\n  }\r\n\r\n  getWithDefaults<T>(\r\n    keyPath: string,\r\n    defaults: T,\r\n    options?: {\r\n      excludeSources?: Array<string>,\r\n      sources?: Array<string>,\r\n      scope?: atom$ScopeDescriptorLike,\r\n    },\r\n  ): T {\r\n    const current: any = this.get(keyPath, options);\r\n    return current == null ? defaults : current;\r\n  }\r\n\r\n  /*\r\n   * Gets the schema of a setting for a Nuclide feature key. Takes and returns the same types as\r\n   * `atom.config.getSchema`.\r\n   */\r\n  getSchema(keyPath: string): atom$ConfigSchema {\r\n    return this._config.getSchema(this.formatKeyPath(keyPath));\r\n  }\r\n\r\n  /*\r\n   * Similar to `atom.config.observe` except arguments are required, and options cannot be given.\r\n   *\r\n   * To observe changes on the entire config, use `atom.config.observe`.\r\n   */\r\n  observe(\r\n    keyPath: string,\r\n    optionsOrCallback?:\r\n      | {scope?: atom$ScopeDescriptorLike}\r\n      | ((value: any) => mixed),\r\n    callback?: (value: any) => mixed,\r\n  ): IDisposable {\r\n    return this._config.observe(\r\n      this.formatKeyPath(keyPath),\r\n      ...Array.prototype.slice.call(arguments, 1),\r\n    );\r\n  }\r\n\r\n  /*\r\n   * Behaves similarly to the `observe` function, but returns a stream of values, rather\r\n   * than receiving a callback.\r\n   */\r\n  observeAsStream(\r\n    keyPath: string,\r\n    options?: {scope?: atom$ScopeDescriptorLike} = {},\r\n  ): Observable<mixed> {\r\n    return Observable.create(observer => {\r\n      const disposable = this.observe(\r\n        keyPath,\r\n        options,\r\n        observer.next.bind(observer),\r\n      );\r\n      return disposable.dispose.bind(disposable);\r\n    });\r\n  }\r\n\r\n  /*\r\n   * Takes and returns the same types as `atom.config.onDidChange` except `keyPath` is not optional.\r\n   * To listen to changes on all key paths, use `atom.config.onDidChange`.\r\n   */\r\n  onDidChange(\r\n    keyPath: string,\r\n    optionsOrCallback?:\r\n      | {scope?: atom$ScopeDescriptorLike}\r\n      | ((event: {oldValue: mixed, newValue: mixed}) => mixed),\r\n    callback?: (event: {oldValue: mixed, newValue: mixed}) => mixed,\r\n  ): IDisposable {\r\n    return this._config.onDidChange(\r\n      this.formatKeyPath(keyPath),\r\n      ...Array.prototype.slice.call(arguments, 1),\r\n    );\r\n  }\r\n\r\n  /*\r\n   * Sets the value of a setting for a Nuclide feature key. Takes and returns the same types as\r\n   * `atom.config.set`.\r\n   */\r\n  set(\r\n    keyPath: string,\r\n    value: ?mixed,\r\n    options?: {\r\n      scopeSelector?: string,\r\n      source?: string,\r\n    },\r\n  ): boolean {\r\n    return this._config.set(\r\n      this.formatKeyPath(keyPath),\r\n      ...Array.prototype.slice.call(arguments, 1),\r\n    );\r\n  }\r\n\r\n  /*\r\n   * Sets the schema of a setting for a Nuclide feature key. Takes and returns the same types as\r\n   * `atom.config.setSchema`.\r\n   */\r\n  setSchema(keyPath: string, schema: Object): void {\r\n    return this._config.setSchema(\r\n      this.formatKeyPath(keyPath),\r\n      ...Array.prototype.slice.call(arguments, 1),\r\n    );\r\n  }\r\n\r\n  /*\r\n   * Restores a setting for a Nuclide feature key to its default value. Takes and returns the same\r\n   * types as `atom.config.set`.\r\n   */\r\n  unset(\r\n    keyPath: string,\r\n    options?: {\r\n      scopeSelector?: string,\r\n      source?: string,\r\n    },\r\n  ): void {\r\n    return this._config.unset(\r\n      this.formatKeyPath(keyPath),\r\n      ...Array.prototype.slice.call(arguments, 1),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the feature with the given name is disabled either directly or because the\r\n   * container package itself is disabled.\r\n   */\r\n  isFeatureDisabled(name: string): boolean {\r\n    if (this._packageName == null) {\r\n      return atom.packages.isPackageDisabled(name);\r\n    }\r\n    return (\r\n      atom.packages.isPackageDisabled(this._packageName) ||\r\n      // $FlowFixMe flow doesn't register this._packageName as non-null here\r\n      !this._config.get(`${this._packageName}.use.${name}`)\r\n    );\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n/**\r\n * A wrapper over Atom's config functions for use with FeatureLoader.\r\n * Each individual loaded package's config is a subconfig of the root package.\r\n */\r\n\r\nimport ConfigManager from './ConfigManager';\r\n\r\nconst featureConfigManager = new ConfigManager(atom.config);\r\n\r\nexport default featureConfigManager;\r\n","(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function _encode(ch) {\n        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    function encodeURIComponent2(str) {\n        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);\n    }\n    function encodeNoop(str) {\n        return str.replace(/[#?]/, _encode);\n    }\n    /**\n     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n     * This class is a simple parser which creates the basic component paths\n     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n     * and encoding.\n     *\n     *       foo://example.com:8042/over/there?name=ferret#nose\n     *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n     *        |           |            |            |        |\n     *     scheme     authority       path        query   fragment\n     *        |   _____________________|__\n     *       / \\ /                        \\\n     *       urn:example:animal:ferret:nose\n     *\n     *\n     */\n    var URI = (function () {\n        function URI() {\n            this._scheme = URI._empty;\n            this._authority = URI._empty;\n            this._path = URI._empty;\n            this._query = URI._empty;\n            this._fragment = URI._empty;\n            this._formatted = null;\n            this._fsPath = null;\n        }\n        URI.isUri = function (thing) {\n            if (thing instanceof URI) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return typeof thing.authority === 'string'\n                && typeof thing.fragment === 'string'\n                && typeof thing.path === 'string'\n                && typeof thing.query === 'string'\n                && typeof thing.scheme === 'string';\n        };\n        Object.defineProperty(URI.prototype, \"scheme\", {\n            /**\n             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n             * The part before the first colon.\n             */\n            get: function () {\n                return this._scheme;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"authority\", {\n            /**\n             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n             * The part between the first double slashes and the next slash.\n             */\n            get: function () {\n                return this._authority;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"path\", {\n            /**\n             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._path;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"query\", {\n            /**\n             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._query;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"fragment\", {\n            /**\n             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._fragment;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"fsPath\", {\n            // ---- filesystem path -----------------------\n            /**\n             * Returns a string representing the corresponding file system path of this URI.\n             * Will handle UNC paths and normalize windows drive letters to lower-case. Also\n             * uses the platform specific path separator. Will *not* validate the path for\n             * invalid characters and semantics. Will *not* look at the scheme of this URI.\n             */\n            get: function () {\n                if (!this._fsPath) {\n                    var value;\n                    if (this._authority && this._path && this.scheme === 'file') {\n                        // unc path: file://shares/c$/far/boo\n                        value = \"//\" + this._authority + this._path;\n                    }\n                    else if (URI._driveLetterPath.test(this._path)) {\n                        // windows drive letter: file:///c:/far/boo\n                        value = this._path[1].toLowerCase() + this._path.substr(2);\n                    }\n                    else {\n                        // other path\n                        value = this._path;\n                    }\n                    if (isWindows) {\n                        value = value.replace(/\\//g, '\\\\');\n                    }\n                    this._fsPath = value;\n                }\n                return this._fsPath;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // ---- modify to new -------------------------\n        URI.prototype.with = function (change) {\n            if (!change) {\n                return this;\n            }\n            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;\n            if (scheme === void 0) {\n                scheme = this.scheme;\n            }\n            else if (scheme === null) {\n                scheme = '';\n            }\n            if (authority === void 0) {\n                authority = this.authority;\n            }\n            else if (authority === null) {\n                authority = '';\n            }\n            if (path === void 0) {\n                path = this.path;\n            }\n            else if (path === null) {\n                path = '';\n            }\n            if (query === void 0) {\n                query = this.query;\n            }\n            else if (query === null) {\n                query = '';\n            }\n            if (fragment === void 0) {\n                fragment = this.fragment;\n            }\n            else if (fragment === null) {\n                fragment = '';\n            }\n            if (scheme === this.scheme\n                && authority === this.authority\n                && path === this.path\n                && query === this.query\n                && fragment === this.fragment) {\n                return this;\n            }\n            var ret = new URI();\n            ret._scheme = scheme;\n            ret._authority = authority;\n            ret._path = path;\n            ret._query = query;\n            ret._fragment = fragment;\n            URI._validate(ret);\n            return ret;\n        };\n        // ---- parse & validate ------------------------\n        URI.parse = function (value) {\n            var ret = new URI();\n            var data = URI._parseComponents(value);\n            ret._scheme = data.scheme;\n            ret._authority = decodeURIComponent(data.authority);\n            ret._path = decodeURIComponent(data.path);\n            ret._query = decodeURIComponent(data.query);\n            ret._fragment = decodeURIComponent(data.fragment);\n            URI._validate(ret);\n            return ret;\n        };\n        URI.file = function (path) {\n            var ret = new URI();\n            ret._scheme = 'file';\n            // normalize to fwd-slashes on windows,\n            // on other systems bwd-slaches are valid\n            // filename character, eg /f\\oo/ba\\r.txt\n            if (isWindows) {\n                path = path.replace(/\\\\/g, URI._slash);\n            }\n            // check for authority as used in UNC shares\n            // or use the path as given\n            if (path[0] === URI._slash && path[0] === path[1]) {\n                var idx = path.indexOf(URI._slash, 2);\n                if (idx === -1) {\n                    ret._authority = path.substring(2);\n                }\n                else {\n                    ret._authority = path.substring(2, idx);\n                    ret._path = path.substring(idx);\n                }\n            }\n            else {\n                ret._path = path;\n            }\n            // Ensure that path starts with a slash\n            // or that it is at least a slash\n            if (ret._path[0] !== URI._slash) {\n                ret._path = URI._slash + ret._path;\n            }\n            URI._validate(ret);\n            return ret;\n        };\n        URI._parseComponents = function (value) {\n            var ret = {\n                scheme: URI._empty,\n                authority: URI._empty,\n                path: URI._empty,\n                query: URI._empty,\n                fragment: URI._empty,\n            };\n            var match = URI._regexp.exec(value);\n            if (match) {\n                ret.scheme = match[2] || ret.scheme;\n                ret.authority = match[4] || ret.authority;\n                ret.path = match[5] || ret.path;\n                ret.query = match[7] || ret.query;\n                ret.fragment = match[9] || ret.fragment;\n            }\n            return ret;\n        };\n        URI.from = function (components) {\n            return new URI().with(components);\n        };\n        URI._validate = function (ret) {\n            // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n            // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n            if (ret.scheme && !URI._schemePattern.test(ret.scheme)) {\n                throw new Error('[UriError]: Scheme contains illegal characters.');\n            }\n            // path, http://tools.ietf.org/html/rfc3986#section-3.3\n            // If a URI contains an authority component, then the path component\n            // must either be empty or begin with a slash (\"/\") character.  If a URI\n            // does not contain an authority component, then the path cannot begin\n            // with two slash characters (\"//\").\n            if (ret.path) {\n                if (ret.authority) {\n                    if (!URI._singleSlashStart.test(ret.path)) {\n                        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n                    }\n                }\n                else {\n                    if (URI._doubleSlashStart.test(ret.path)) {\n                        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n                    }\n                }\n            }\n        };\n        // ---- printing/externalize ---------------------------\n        /**\n         *\n         * @param skipEncoding Do not encode the result, default is `false`\n         */\n        URI.prototype.toString = function (skipEncoding) {\n            if (skipEncoding === void 0) { skipEncoding = false; }\n            if (!skipEncoding) {\n                if (!this._formatted) {\n                    this._formatted = URI._asFormatted(this, false);\n                }\n                return this._formatted;\n            }\n            else {\n                // we don't cache that\n                return URI._asFormatted(this, true);\n            }\n        };\n        URI._asFormatted = function (uri, skipEncoding) {\n            var encoder = !skipEncoding\n                ? encodeURIComponent2\n                : encodeNoop;\n            var parts = [];\n            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\n            if (scheme) {\n                parts.push(scheme, ':');\n            }\n            if (authority || scheme === 'file') {\n                parts.push('//');\n            }\n            if (authority) {\n                authority = authority.toLowerCase();\n                var idx = authority.indexOf(':');\n                if (idx === -1) {\n                    parts.push(encoder(authority));\n                }\n                else {\n                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\n                }\n            }\n            if (path) {\n                // lower-case windows drive letters in /C:/fff or C:/fff\n                var m = URI._upperCaseDrive.exec(path);\n                if (m) {\n                    if (m[1]) {\n                        path = '/' + m[2].toLowerCase() + path.substr(3); // \"/c:\".length === 3\n                    }\n                    else {\n                        path = m[2].toLowerCase() + path.substr(2); // // \"c:\".length === 2\n                    }\n                }\n                // encode every segement but not slashes\n                // make sure that # and ? are always encoded\n                // when occurring in paths - otherwise the result\n                // cannot be parsed back again\n                var lastIdx = 0;\n                while (true) {\n                    var idx = path.indexOf(URI._slash, lastIdx);\n                    if (idx === -1) {\n                        parts.push(encoder(path.substring(lastIdx)));\n                        break;\n                    }\n                    parts.push(encoder(path.substring(lastIdx, idx)), URI._slash);\n                    lastIdx = idx + 1;\n                }\n                ;\n            }\n            if (query) {\n                parts.push('?', encoder(query));\n            }\n            if (fragment) {\n                parts.push('#', encoder(fragment));\n            }\n            return parts.join(URI._empty);\n        };\n        URI.prototype.toJSON = function () {\n            var res = {\n                fsPath: this.fsPath,\n                external: this.toString(),\n                $mid: 1\n            };\n            if (this.path) {\n                res.path = this.path;\n            }\n            if (this.scheme) {\n                res.scheme = this.scheme;\n            }\n            if (this.authority) {\n                res.authority = this.authority;\n            }\n            if (this.query) {\n                res.query = this.query;\n            }\n            if (this.fragment) {\n                res.fragment = this.fragment;\n            }\n            return res;\n        };\n        URI.revive = function (data) {\n            var result = new URI();\n            result._scheme = data.scheme || URI._empty;\n            result._authority = data.authority || URI._empty;\n            result._path = data.path || URI._empty;\n            result._query = data.query || URI._empty;\n            result._fragment = data.fragment || URI._empty;\n            result._fsPath = data.fsPath;\n            result._formatted = data.external;\n            URI._validate(result);\n            return result;\n        };\n        return URI;\n    }());\n    URI._empty = '';\n    URI._slash = '/';\n    URI._regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    URI._driveLetterPath = /^\\/[a-zA-z]:/;\n    URI._upperCaseDrive = /^(\\/)?([A-Z]:)/;\n    URI._schemePattern = /^\\w[\\w\\d+.-]*$/;\n    URI._singleSlashStart = /^\\//;\n    URI._doubleSlashStart = /^\\/\\//;\n    exports.default = URI;\n    var isWindows;\n    if (typeof process === 'object') {\n        isWindows = process.platform === 'win32';\n    }\n    else if (typeof navigator === 'object') {\n        var userAgent = navigator.userAgent;\n        isWindows = userAgent.indexOf('Windows') >= 0;\n    }\n});\n","/**\r\nModified from https://github.com/substack/node-shell-quote/commit/72fb5a8.\r\nIncludes https://github.com/substack/node-shell-quote/pull/29, with minor\r\nmodifications to remove the unnecessary Array polyfills.\r\n\r\nUse the typed wrappers in ./string.js to access these functions.\r\n\r\nThe MIT License\r\n\r\nCopyright (c) 2013 James Halliday (mail@substack.net)\r\n\r\nPermission is hereby granted, free of charge,\r\nto any person obtaining a copy of this software and\r\nassociated documentation files (the \"Software\"), to\r\ndeal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify,\r\nmerge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom\r\nthe Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice\r\nshall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\r\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n@noflow\r\n*/\r\n\r\n/* eslint-disable */\r\n\r\nexports.quote = function (xs) {\r\n    return xs.map(function (s) {\r\n        if (s && typeof s === 'object') {\r\n            return s.op.replace(/(.)/g, '\\\\$1');\r\n        }\r\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\r\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\r\n        }\r\n        else if (/[\"'\\s]/.test(s)) {\r\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\r\n        }\r\n        else {\r\n            return String(s).replace(/([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '\\\\$1');\r\n        }\r\n    }).join(' ');\r\n};\r\n\r\nvar CONTROL = '(?:' + [\r\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '[&;()|<>]'\r\n].join('|') + ')';\r\nvar META = '|&;()<> \\\\t';\r\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\r\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\r\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\r\n\r\nvar TOKEN = '';\r\nfor (var i = 0; i < 4; i++) {\r\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\r\n}\r\n\r\nexports.parse = function (s, env, opts) {\r\n    var mapped = parse(s, env, opts);\r\n    if (typeof env !== 'function') return mapped;\r\n    return mapped.reduce(function (acc, s) {\r\n        if (typeof s === 'object') return acc.concat(s);\r\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\r\n        if (xs.length === 1) return acc.concat(xs[0]);\r\n        return acc.concat(xs.filter(Boolean).map(function (x) {\r\n            if (RegExp('^' + TOKEN).test(x)) {\r\n                return JSON.parse(x.split(TOKEN)[1]); }\r\n            else return x;\r\n        }));\r\n    }, []);\r\n};\r\n\r\nfunction parse (s, env, opts) {\r\n    var chunker = new RegExp([\r\n        '(' + CONTROL + ')', // control chars\r\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\r\n    ].join('|'), 'g');\r\n    var match = s.match(chunker).filter(Boolean);\r\n    var commented = false;\r\n\r\n    if (!match) return [];\r\n    if (!env) env = {};\r\n    if (!opts) opts = {};\r\n    return match.map(function (s, j) {\r\n        if (commented) {\r\n            return;\r\n        }\r\n        if (s.charAt(0) === '#') {\r\n            commented = true;\r\n            return { comment: s.substr(1) + match.slice(j+1).join(' ') };\r\n        }\r\n        if (RegExp('^' + CONTROL + '$').test(s)) {\r\n            return { op: s };\r\n        }\r\n\r\n        // Hand-written scanner/parser for Bash quoting rules:\r\n        //\r\n        //  1. inside single quotes, all characters are printed literally.\r\n        //  2. inside double quotes, all characters are printed literally\r\n        //     except variables prefixed by '$' and backslashes followed by\r\n        //     either a double quote or another backslash.\r\n        //  3. outside of any quotes, backslashes are treated as escape\r\n        //     characters and not printed (unless they are themselves escaped)\r\n        //  4. quote context can switch mid-token if there is no whitespace\r\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\r\n        //     \"allonetoken\")\r\n        var SQ = \"'\";\r\n        var DQ = '\"';\r\n        var DS = '$';\r\n        var BS = opts.escape || '\\\\';\r\n        var quote = false;\r\n        var esc = false;\r\n        var out = '';\r\n        var isGlob = false;\r\n\r\n        for (var i = 0, len = s.length; i < len; i++) {\r\n            var c = s.charAt(i);\r\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\r\n            if (esc) {\r\n                out += c;\r\n                esc = false;\r\n            }\r\n            else if (quote) {\r\n                if (c === quote) {\r\n                    quote = false;\r\n                }\r\n                else if (quote == SQ) {\r\n                    out += c;\r\n                }\r\n                else { // Double quote\r\n                    if (c === BS) {\r\n                        i += 1;\r\n                        c = s.charAt(i);\r\n                        if (c === DQ || c === BS || c === DS) {\r\n                            out += c;\r\n                        } else {\r\n                            out += BS + c;\r\n                        }\r\n                    }\r\n                    else if (c === DS) {\r\n                        out += parseEnvVar();\r\n                    }\r\n                    else {\r\n                        out += c;\r\n                    }\r\n                }\r\n            }\r\n            else if (c === DQ || c === SQ) {\r\n                quote = c;\r\n            }\r\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\r\n                return { op: s };\r\n            }\r\n            else if (c === BS) {\r\n                esc = true;\r\n            }\r\n            else if (c === DS) {\r\n                out += parseEnvVar();\r\n            }\r\n            else out += c;\r\n        }\r\n\r\n        if (isGlob) return {op: 'glob', pattern: out};\r\n\r\n        return out;\r\n\r\n        function parseEnvVar() {\r\n            i += 1;\r\n            var varend, varname;\r\n            //debugger\r\n            if (s.charAt(i) === '{') {\r\n                i += 1;\r\n                if (s.charAt(i) === '}') {\r\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\r\n                }\r\n                varend = s.indexOf('}', i);\r\n                if (varend < 0) {\r\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\r\n                }\r\n                varname = s.substr(i, varend - i);\r\n                i = varend;\r\n            }\r\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\r\n                varname = s.charAt(i);\r\n                i += 1;\r\n            }\r\n            else {\r\n                varend = s.substr(i).match(/[^\\w\\d_]/);\r\n                if (!varend) {\r\n                    varname = s.substr(i);\r\n                    i = s.length;\r\n                } else {\r\n                    varname = s.substr(i, varend.index);\r\n                    i += varend.index - 1;\r\n                }\r\n            }\r\n            return getVar(null, '', varname);\r\n        }\r\n    })\r\n    // finalize parsed aruments\r\n    .reduce(function(prev, arg){\r\n        if (arg === undefined){\r\n            return prev;\r\n        }\r\n        return prev.concat(arg);\r\n    },[]);\r\n\r\n    function getVar (_, pre, key) {\r\n        var r = typeof env === 'function' ? env(key) : env[key];\r\n        if (r === undefined) r = '';\r\n\r\n        if (typeof r === 'object') {\r\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\r\n        }\r\n        else return pre + r;\r\n    }\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\nimport {parse, quote} from './_shell-quote';\r\n\r\nexport function stringifyError(error: Error): string {\r\n  return `name: ${error.name}, message: ${error.message}, stack: ${\r\n    error.stack\r\n  }.`;\r\n}\r\n\r\n// As of Flow v0.28, Flow does not alllow implicit string coercion of null or undefined. Use this to\r\n// make it explicit.\r\nexport function maybeToString(str: ?string): string {\r\n  // We don't want to encourage the use of this function directly because it coerces anything to a\r\n  // string. We get stricter typechecking by using maybeToString, so it should generally be\r\n  // preferred.\r\n  return String(str);\r\n}\r\n\r\n/**\r\n * Originally adapted from https://github.com/azer/relative-date.\r\n * We're including it because of https://github.com/npm/npm/issues/12012\r\n */\r\nconst SECOND = 1000;\r\nconst MINUTE = 60 * SECOND;\r\nconst HOUR = 60 * MINUTE;\r\nconst DAY = 24 * HOUR;\r\nconst WEEK = 7 * DAY;\r\nconst YEAR = DAY * 365;\r\nconst MONTH = YEAR / 12;\r\n\r\nconst shortFormats = [\r\n  [0.7 * MINUTE, 'now'],\r\n  [1.5 * MINUTE, '1m'],\r\n  [60 * MINUTE, 'm', MINUTE],\r\n  [1.5 * HOUR, '1h'],\r\n  [DAY, 'h', HOUR],\r\n  [2 * DAY, '1d'],\r\n  [7 * DAY, 'd', DAY],\r\n  [1.5 * WEEK, '1w'],\r\n  [MONTH, 'w', WEEK],\r\n  [1.5 * MONTH, '1mo'],\r\n  [YEAR, 'mo', MONTH],\r\n  [1.5 * YEAR, '1y'],\r\n  [Number.MAX_VALUE, 'y', YEAR],\r\n];\r\n\r\nconst longFormats = [\r\n  [0.7 * MINUTE, 'just now'],\r\n  [1.5 * MINUTE, 'a minute ago'],\r\n  [60 * MINUTE, 'minutes ago', MINUTE],\r\n  [1.5 * HOUR, 'an hour ago'],\r\n  [DAY, 'hours ago', HOUR],\r\n  [2 * DAY, 'yesterday'],\r\n  [7 * DAY, 'days ago', DAY],\r\n  [1.5 * WEEK, 'a week ago'],\r\n  [MONTH, 'weeks ago', WEEK],\r\n  [1.5 * MONTH, 'a month ago'],\r\n  [YEAR, 'months ago', MONTH],\r\n  [1.5 * YEAR, 'a year ago'],\r\n  [Number.MAX_VALUE, 'years ago', YEAR],\r\n];\r\n\r\nconst longFormatsNumbers = [\r\n  [0.7 * MINUTE, 'just now'],\r\n  [1.5 * MINUTE, '1 minute ago'],\r\n  [60 * MINUTE, 'minutes ago', MINUTE],\r\n  [1.5 * HOUR, '1 hour ago'],\r\n  [DAY, 'hours ago', HOUR],\r\n  [2 * DAY, 'yesterday'],\r\n  [7 * DAY, 'days ago', DAY],\r\n  [1.5 * WEEK, '1 week ago'],\r\n  [MONTH, 'weeks ago', WEEK],\r\n  [1.5 * MONTH, '1 month ago'],\r\n  [YEAR, 'months ago', MONTH],\r\n  [1.5 * YEAR, '1 year ago'],\r\n  [Number.MAX_VALUE, 'years ago', YEAR],\r\n];\r\n\r\nexport function relativeDate(\r\n  input_: number | Date,\r\n  reference_?: number | Date,\r\n  useShortVariant?: boolean = false,\r\n  useNumbersOnly?: boolean = false,\r\n): string {\r\n  let input = input_;\r\n  let reference = reference_;\r\n  if (input instanceof Date) {\r\n    input = input.getTime();\r\n  }\r\n  // flowlint-next-line sketchy-null-number:off\r\n  if (!reference) {\r\n    reference = new Date().getTime();\r\n  }\r\n  if (reference instanceof Date) {\r\n    reference = reference.getTime();\r\n  }\r\n\r\n  const delta = reference - input;\r\n  const formats = useShortVariant\r\n    ? shortFormats\r\n    : useNumbersOnly\r\n      ? longFormatsNumbers\r\n      : longFormats;\r\n  for (const [limit, relativeFormat, remainder] of formats) {\r\n    if (delta < limit) {\r\n      if (typeof remainder === 'number') {\r\n        return (\r\n          Math.round(delta / remainder) +\r\n          (useShortVariant ? '' : ' ') +\r\n          relativeFormat\r\n        );\r\n      } else {\r\n        return relativeFormat;\r\n      }\r\n    }\r\n  }\r\n\r\n  throw new Error('This should never be reached.');\r\n}\r\n\r\n/**\r\n * Count the number of occurrences of `char` in `str`.\r\n * `char` must be a string of length 1.\r\n */\r\nexport function countOccurrences(haystack: string, char: string) {\r\n  invariant(char.length === 1, 'char must be a string of length 1');\r\n\r\n  let count = 0;\r\n  const code = char.charCodeAt(0);\r\n  for (let i = 0; i < haystack.length; i++) {\r\n    if (haystack.charCodeAt(i) === code) {\r\n      count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n * shell-quote's parse allows pipe operators and comments.\r\n * Generally users don't care about this, so throw if we encounter any operators.\r\n */\r\nexport function shellParse(str: string, env?: Object): Array<string> {\r\n  const result = parse(str, env);\r\n  for (let i = 0; i < result.length; i++) {\r\n    if (typeof result[i] !== 'string') {\r\n      if (result[i].op != null) {\r\n        throw new Error(\r\n          `Unexpected operator \"${result[i].op}\" provided to shellParse`,\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `Unexpected comment \"${result[i].comment}\" provided to shellParse`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * shell-quote's parse allows pipe operators and comments and globs\r\n * We treat glob patterns as normal strings. For the other operators, we throw.\r\n */\r\nexport function shellParseWithGlobs(str: string, env?: Object): Array<string> {\r\n  const result = parse(str, env);\r\n  for (let i = 0; i < result.length; i++) {\r\n    if (typeof result[i] !== 'string') {\r\n      if (result[i].op === 'glob') {\r\n        result[i] = result[i].pattern;\r\n      } else if (result[i].op != null) {\r\n        throw new Error(\r\n          `Unexpected operator \"${result[i].op}\" provided to shellParse`,\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `Unexpected comment \"${result[i].comment}\" provided to shellParse`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Technically you can pass in { operator: string } here,\r\n * but we don't use that in most APIs.\r\n */\r\nexport function shellQuote(args: Array<string>): string {\r\n  return quote(args);\r\n}\r\n\r\nexport function removeCommonPrefix(a: string, b: string): [string, string] {\r\n  let i = 0;\r\n  while (a[i] === b[i] && i < a.length && i < b.length) {\r\n    i++;\r\n  }\r\n  return [a.substring(i), b.substring(i)];\r\n}\r\n\r\nexport function removeCommonSuffix(a: string, b: string): [string, string] {\r\n  let i = 0;\r\n  while (\r\n    a[a.length - 1 - i] === b[b.length - 1 - i] &&\r\n    i < a.length &&\r\n    i < b.length\r\n  ) {\r\n    i++;\r\n  }\r\n  return [a.substring(0, a.length - i), b.substring(0, b.length - i)];\r\n}\r\n\r\nexport function shorten(\r\n  str: string,\r\n  maxLength: number,\r\n  suffix?: string,\r\n): string {\r\n  return str.length < maxLength\r\n    ? str\r\n    : str.slice(0, maxLength) + (suffix || '');\r\n}\r\n\r\n/**\r\n * Like String.split, but only splits once.\r\n */\r\nexport function splitOnce(str: string, separator: string): [string, ?string] {\r\n  const index = str.indexOf(separator);\r\n  return index === -1\r\n    ? [str, null]\r\n    : [str.slice(0, index), str.slice(index + separator.length)];\r\n}\r\n\r\n/**\r\n * Indents each line by the specified number of characters.\r\n */\r\nexport function indent(\r\n  str: string,\r\n  level: number = 2,\r\n  char: string = ' ',\r\n): string {\r\n  return str.replace(/^([^\\n])/gm, char.repeat(level) + '$1');\r\n}\r\n\r\nexport function pluralize(noun: string, count: number) {\r\n  return count === 1 ? noun : noun + 's';\r\n}\r\n\r\nexport function capitalize(str: string): string {\r\n  return str.length === 0\r\n    ? str\r\n    : str\r\n        .charAt(0)\r\n        .toUpperCase()\r\n        .concat(str.slice(1));\r\n}\r\n\r\ntype MatchRange = [/* start */ number, /* end */ number];\r\n\r\n/**\r\n * Returns a list of ranges where needle occurs in haystack.\r\n * This will *not* return overlapping matches; i.e. the returned list will be disjoint.\r\n * This makes it easier to use for e.g. highlighting matches in a UI.\r\n */\r\nexport function getMatchRanges(\r\n  haystack: string,\r\n  needle: string,\r\n): Array<MatchRange> {\r\n  if (needle === '') {\r\n    // Not really a valid use.\r\n    return [];\r\n  }\r\n\r\n  const ranges = [];\r\n  let matchIndex = 0;\r\n  while ((matchIndex = haystack.indexOf(needle, matchIndex)) !== -1) {\r\n    const prevRange = ranges[ranges.length - 1];\r\n    if (prevRange != null && prevRange[1] === matchIndex) {\r\n      prevRange[1] += needle.length;\r\n    } else {\r\n      ranges.push([matchIndex, matchIndex + needle.length]);\r\n    }\r\n    matchIndex += needle.length;\r\n  }\r\n  return ranges;\r\n}\r\n\r\nexport function escapeMarkdown(markdown: string): string {\r\n  // Which characters can be backslash-escaped?\r\n  // markdown:   ! #    ()*+ -.        [\\] _`{ }   https://daringfireball.net/projects/markdown/syntax#backslash\r\n  // commonMark: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~  https://spec.commonmark.org/0.28/#backslash-escapes\r\n  // We'll only backslash-escape the lowest common denominator.\r\n  const slashEscaped = markdown.replace(/[#!()*+\\-.[\\\\\\]_`{}]/g, '\\\\$&');\r\n  // And HTML tags need to be &lt; &gt; escaped.\r\n  return slashEscaped.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n}\r\n\r\n// Originally copied from:\r\n// http://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url\r\n// But adopted to match `www.` urls as well as `https?` urls\r\n// and `!` as acceptable url piece.\r\n// Then optimized with https://www.npmjs.com/package/regexp-tree.\r\n// Added a single matching group for use with String.split.\r\n// eslint-disable-next-line max-len\r\nexport const URL_REGEX = /(https?:\\/\\/(?:www\\.)?[-\\w@:%.+~#=]{2,256}\\.[a-z]{2,6}\\b[-\\w@:%+.~#?&/=!]*|www\\.[-\\w@:%.+~#=]{2,256}\\.[a-z]{2,6}\\b[-\\w@:%+.~#?&/=!]*)/;\r\n\r\nexport const ELLIPSIS_CHAR = '\\u2026';\r\nexport const ZERO_WIDTH_SPACE = '\\u200B';\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n// NuclideUri's are either a local file path, or a URI\r\n// of the form nuclide://<host><path>\r\n//\r\n// This package creates, queries and decomposes NuclideUris.\r\n\r\nimport LspUri from 'vscode-uri';\r\n\r\nexport type NuclideUri = string;\r\n\r\ntype ParsedUrl = {\r\n  hostname: ?string,\r\n  path: string,\r\n};\r\n\r\ntype ParsedRemoteUrl = {\r\n  hostname: string,\r\n  path: string,\r\n};\r\n\r\ntype ParsedPath = {\r\n  root: string,\r\n  dir: string,\r\n  base: string,\r\n  ext: string,\r\n  name: string,\r\n};\r\n\r\nimport invariant from 'assert';\r\n// eslint-disable-next-line nuclide-internal/prefer-nuclide-uri\r\nimport pathModule from 'path';\r\n\r\nimport os from 'os';\r\nimport {maybeToString} from './string';\r\n\r\nconst ARCHIVE_SEPARATOR = '!';\r\nconst KNOWN_ARCHIVE_EXTENSIONS = [];\r\n\r\nconst REMOTE_PATH_URI_PREFIX = 'nuclide://';\r\n// TODO(ljw): following regex is incorrect. A URI scheme must start with\r\n// [A-Za-z] not [0-9_-]. Also, not all schemes require // after them.\r\nconst URI_PREFIX_REGEX = /^[A-Za-z0-9_-]+:\\/\\/.*/;\r\n\r\nfunction isRemote(uri: NuclideUri): boolean {\r\n  return uri.startsWith(REMOTE_PATH_URI_PREFIX);\r\n}\r\n\r\n// Atom often puts its URIs in places where we'd expect to see Nuclide URIs (or plain paths)\r\nfunction isAtomUri(uri: NuclideUri): boolean {\r\n  return uri.startsWith('atom://');\r\n}\r\n\r\nfunction isUri(uri: string): boolean {\r\n  return URI_PREFIX_REGEX.test(uri);\r\n}\r\n\r\nfunction isLocal(uri: NuclideUri): boolean {\r\n  return !isRemote(uri) && !isUri(uri) && !isAtomUri(uri);\r\n}\r\n\r\nfunction createRemoteUri(hostname: string, remotePath: string): string {\r\n  invariant(\r\n    remotePath != null && remotePath !== '',\r\n    'NuclideUri must include a path.',\r\n  );\r\n  return `nuclide://${hostname}${remotePath}`;\r\n}\r\n\r\nfunction isInArchive(uri: NuclideUri): boolean {\r\n  if (isAtomUri(uri) || uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return false;\r\n  }\r\n  for (\r\n    let i = uri.indexOf(ARCHIVE_SEPARATOR);\r\n    i >= 0;\r\n    i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)\r\n  ) {\r\n    if (_isArchiveSeparator(uri, i)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction ancestorOutsideArchive(uri: NuclideUri): NuclideUri {\r\n  for (\r\n    let i = uri.indexOf(ARCHIVE_SEPARATOR);\r\n    i >= 0;\r\n    i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)\r\n  ) {\r\n    if (_isArchiveSeparator(uri, i)) {\r\n      return uri.substring(0, i);\r\n    }\r\n  }\r\n  return uri;\r\n}\r\n\r\n/**\r\n * Parses valid Nuclide URIs into the hostname and path components.\r\n * Throws an Error on invalid URIs. Invalid URIs are:\r\n *  1) Any URI that does not start with 'nuclide://' protocol.\r\n *  2) A URI starting with 'nuclide://' that doesn't contain either a hostname or a path\r\n *\r\n * Everything that does not contain a '://' is assumed to be a local path. Both POSIX and Windows\r\n * paths are legal\r\n */\r\nfunction parse(uri: NuclideUri): ParsedUrl {\r\n  if (uri.startsWith(REMOTE_PATH_URI_PREFIX)) {\r\n    const hostAndPath = uri.substr(REMOTE_PATH_URI_PREFIX.length);\r\n    const hostSep = hostAndPath.indexOf('/');\r\n\r\n    invariant(\r\n      hostSep !== -1,\r\n      `Remote URIs must contain a hostname and a path. Failed to parse ${uri}`,\r\n    );\r\n\r\n    const hostname = hostAndPath.substr(0, hostSep);\r\n    invariant(\r\n      hostname !== '',\r\n      `Remote URIs must contain a hostname. Failed to parse ${uri}`,\r\n    );\r\n\r\n    const path = hostAndPath.substr(hostSep);\r\n    invariant(\r\n      !_endsWithArchiveSeparator(uri),\r\n      `Path cannot end with archive separator. Failed to parse ${uri}`,\r\n    );\r\n    return {hostname, path};\r\n  }\r\n\r\n  invariant(\r\n    !_endsWithArchiveSeparator(uri),\r\n    `Path cannot end with archive separator. Failed to parse ${uri}`,\r\n  );\r\n  return {hostname: null, path: uri};\r\n}\r\n\r\nfunction parseRemoteUri(remoteUri: NuclideUri): ParsedRemoteUrl {\r\n  if (!isRemote(remoteUri)) {\r\n    throw new Error('Expected remote uri. Got ' + remoteUri);\r\n  }\r\n  const parsedUri = parse(remoteUri);\r\n  invariant(\r\n    // flowlint-next-line sketchy-null-string:off\r\n    parsedUri.hostname,\r\n    `Remote Nuclide URIs must contain hostnames, '${maybeToString(\r\n      parsedUri.hostname,\r\n    )}' found while parsing '${remoteUri}'`,\r\n  );\r\n\r\n  // Explicitly copying object properties appeases Flow's \"maybe\" type handling. Using the `...`\r\n  // operator causes null/undefined errors, and `Object.assign` bypasses type checking.\r\n  return {\r\n    hostname: parsedUri.hostname,\r\n    path: parsedUri.path,\r\n  };\r\n}\r\n\r\nfunction getPath(uri: NuclideUri): string {\r\n  return parse(uri).path;\r\n}\r\n\r\nfunction getHostname(remoteUri: NuclideUri): string {\r\n  return parseRemoteUri(remoteUri).hostname;\r\n}\r\n\r\nfunction getHostnameOpt(remoteUri: ?NuclideUri): ?string {\r\n  if (remoteUri == null || !isRemote(remoteUri)) {\r\n    return null;\r\n  }\r\n\r\n  return getHostname(remoteUri);\r\n}\r\n\r\nfunction join(uri: NuclideUri, ...relativePath: Array<string>): NuclideUri {\r\n  return joinArray(uri, relativePath);\r\n}\r\n\r\nfunction joinArray(uri: NuclideUri, relativePath: Array<string>): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    relativePath.splice(0, 0, path);\r\n    _archiveEncodeArrayInPlace(uriPathModule, relativePath);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      createRemoteUri(hostname, uriPathModule.join.apply(null, relativePath)),\r\n    );\r\n  } else {\r\n    relativePath.splice(0, 0, uri);\r\n    _archiveEncodeArrayInPlace(uriPathModule, relativePath);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.join.apply(null, relativePath),\r\n    );\r\n  }\r\n}\r\n\r\nfunction archiveJoin(uri: NuclideUri, path: string): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  if (!KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext))) {\r\n    throw new Error(`Cannot archiveJoin with non-archive ${uri} and ${path}`);\r\n  }\r\n  return uri + ARCHIVE_SEPARATOR + path;\r\n}\r\n\r\nfunction normalize(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    const normal = _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.normalize(_archiveEncode(uriPathModule, path)),\r\n    );\r\n    return createRemoteUri(hostname, normal);\r\n  } else {\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.normalize(_archiveEncode(uriPathModule, uri)),\r\n    );\r\n  }\r\n}\r\n\r\nfunction normalizeDir(uri: NuclideUri): NuclideUri {\r\n  return ensureTrailingSeparator(normalize(uri));\r\n}\r\n\r\nfunction getParent(uri: NuclideUri): NuclideUri {\r\n  // TODO: Is this different than dirname?\r\n  return normalize(join(uri, '..'));\r\n}\r\n\r\nfunction relative(uri: NuclideUri, other: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  const remote = isRemote(uri);\r\n  if (\r\n    remote !== isRemote(other) ||\r\n    (remote && getHostname(uri) !== getHostname(other))\r\n  ) {\r\n    throw new Error(\r\n      `Cannot relative urls on different hosts: ${uri} and ${other}`,\r\n    );\r\n  }\r\n  const uriEncode = _archiveEncode(uriPathModule, remote ? getPath(uri) : uri);\r\n  const otherEncode = _archiveEncode(\r\n    uriPathModule,\r\n    remote ? getPath(other) : other,\r\n  );\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.relative(\r\n      _matchTrailingArchive(uriEncode, otherEncode),\r\n      _matchTrailingArchive(otherEncode, uriEncode),\r\n    ),\r\n  );\r\n}\r\n\r\nfunction basename(uri: NuclideUri, ext: string = ''): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.basename(_archiveEncode(uriPathModule, getPath(uri)), ext),\r\n  );\r\n}\r\n\r\nfunction dirname(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    return createRemoteUri(\r\n      hostname,\r\n      _archiveDecode(\r\n        uriPathModule,\r\n        uriPathModule.dirname(_archiveEncode(uriPathModule, path)),\r\n      ),\r\n    );\r\n  } else {\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.dirname(_archiveEncode(uriPathModule, uri)),\r\n    );\r\n  }\r\n}\r\n\r\nfunction extname(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.extname(_archiveEncode(uriPathModule, getPath(uri))),\r\n  );\r\n}\r\n\r\nfunction stripExtension(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const ext = extname(uri);\r\n  if (ext.length === 0) {\r\n    return uri;\r\n  }\r\n\r\n  return uri.slice(0, -1 * ext.length);\r\n}\r\n\r\nfunction _isWindowsPath(path: string): boolean {\r\n  return _pathModuleFor(path) === pathModule.win32;\r\n}\r\n\r\nfunction _getWindowsPathFromWindowsFileUri(uri: string): ?string {\r\n  const prefix = 'file://';\r\n  if (!uri.startsWith(prefix)) {\r\n    return null;\r\n  }\r\n\r\n  const path = uri.substr(prefix.length);\r\n  return _isWindowsPath(path) ? path : null;\r\n}\r\n\r\n/**\r\n * uri is either a file: uri, or a nuclide: uri.\r\n * must convert file: uri's to just a path for atom.\r\n *\r\n * Returns null if not a valid file: URI.\r\n */\r\nfunction uriToNuclideUri(uri: string): ?string {\r\n  // file:// URIs should never normally contain Windows backslashes:\r\n  // e.g. vscode-uri escapes C:\\abc to file:///c:/abc.\r\n  // This just handles any hacky users that simply prepended 'file://'.\r\n  // (vscode-uri does not know how to handle file://C:\\abc.)\r\n  const windowsPathFromUri = _getWindowsPathFromWindowsFileUri(uri);\r\n  if (windowsPathFromUri != null) {\r\n    return windowsPathFromUri;\r\n  }\r\n\r\n  const lspUri = LspUri.parse(uri);\r\n  if (lspUri.scheme === 'file' && lspUri.path) {\r\n    // only handle real files for now.\r\n    return lspUri.fsPath;\r\n  } else if (isRemote(uri)) {\r\n    return uri;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Converts local paths to file: URI's. Leaves remote URI's alone.\r\n */\r\nfunction nuclideUriToUri(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  if (isRemote(uri)) {\r\n    return uri;\r\n  } else {\r\n    return LspUri.file(uri).toString();\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if child is equal to, or is a proper descendant of parent.\r\n */\r\nfunction contains(parent: NuclideUri, child: NuclideUri): boolean {\r\n  _testForIllegalUri(parent);\r\n  _testForIllegalUri(child);\r\n\r\n  // Can't just do startsWith here. If this directory is \"www\" and you\r\n  // are trying to check \"www-base\", just using startsWith would return\r\n  // true, even though \"www-base\" is at the same level as \"Www\", not\r\n  // contained in it.\r\n  // Also, there's an issue with a trailing separator ambiguity. A path\r\n  // like /abc/ does contain /abc\r\n  // This function is used in some performance-sensitive parts, so we\r\n  // want to avoid doing unnecessary string copy, as those that would\r\n  // result from an ensureTrailingSeparator() call\r\n  //\r\n  // First we'll check the lengths.\r\n  // Then check startsWith. If so, then if the two path lengths are\r\n  // equal OR if the next character in the path to check is a path\r\n  // separator, then we know the checked path is in this path.\r\n\r\n  if (child.length < parent.length) {\r\n    // A strong indication of false\r\n    // It could be a matter of a trailing separator, though\r\n    if (child.length < parent.length - 1) {\r\n      // It must be more than just the separator\r\n      return false;\r\n    }\r\n\r\n    return (\r\n      parent.startsWith(child) &&\r\n      (endsWithSeparator(parent) || _isArchiveSeparator(child, parent.length))\r\n    );\r\n  }\r\n\r\n  if (!child.startsWith(parent)) {\r\n    return false;\r\n  }\r\n\r\n  if (endsWithSeparator(parent) || parent.length === child.length) {\r\n    return true;\r\n  }\r\n\r\n  const uriPathModule = _pathModuleFor(child);\r\n\r\n  return (\r\n    _isArchiveSeparator(child, parent.length) ||\r\n    child.slice(parent.length).startsWith(uriPathModule.sep)\r\n  );\r\n}\r\n\r\n/**\r\n * Filter an array of paths to contain only the collapsed root paths, e.g.\r\n * [a/b/c, a/, c/d/, c/d/e] collapses to [a/, c/d/]\r\n */\r\nfunction collapse(paths: Array<NuclideUri>): Array<NuclideUri> {\r\n  return paths.filter(p => !paths.some(fp => contains(fp, p) && fp !== p));\r\n}\r\n\r\nconst hostFormatters = [];\r\n\r\n// A formatter which may shorten hostnames.\r\n// Returns null if the formatter won't shorten the hostname.\r\nexport type HostnameFormatter = (uri: NuclideUri) => ?string;\r\n\r\n// Registers a host formatter for nuclideUriToDisplayString\r\nfunction registerHostnameFormatter(formatter: HostnameFormatter): IDisposable {\r\n  hostFormatters.push(formatter);\r\n  return {\r\n    dispose: () => {\r\n      const index = hostFormatters.indexOf(formatter);\r\n      if (index >= 0) {\r\n        hostFormatters.splice(index, 1);\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nfunction hostnameToDisplayHostname(hostname: string): string {\r\n  return hostFormatters.reduce((current, formatter) => {\r\n    const next = formatter(current);\r\n    if (next != null && next !== '') {\r\n      return next;\r\n    } else {\r\n      return current;\r\n    }\r\n  }, hostname);\r\n}\r\n\r\nfunction nuclideUriToDisplayHostname(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  return isRemote(uri) ? hostnameToDisplayHostname(getHostname(uri)) : uri;\r\n}\r\n\r\n/**\r\n * NuclideUris should never be shown to humans.\r\n * This function returns a human usable string.\r\n */\r\nfunction nuclideUriToDisplayString(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  return isRemote(uri)\r\n    ? `${nuclideUriToDisplayHostname(uri)}:${getPath(uri)}`\r\n    : uri;\r\n}\r\n\r\nfunction ensureTrailingSeparator(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (uri.endsWith(uriPathModule.sep)) {\r\n    return uri;\r\n  }\r\n\r\n  return uri + uriPathModule.sep;\r\n}\r\n\r\nfunction trimTrailingSeparator(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  let stripped = uri;\r\n\r\n  while (stripped.endsWith(uriPathModule.sep) && !isRoot(stripped)) {\r\n    stripped = stripped.slice(0, -1 * uriPathModule.sep.length);\r\n  }\r\n\r\n  return stripped;\r\n}\r\n\r\nfunction endsWithSeparator(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return uri.endsWith(uriPathModule.sep);\r\n}\r\n\r\nfunction endsWithEdenDir(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return uri.endsWith('.eden');\r\n}\r\n\r\nfunction isAbsolute(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  if (isRemote(uri)) {\r\n    return true;\r\n  } else {\r\n    const uriPathModule = _pathModuleFor(uri);\r\n    return uriPathModule.isAbsolute(uri);\r\n  }\r\n}\r\n\r\nfunction resolve(uri: NuclideUri, ...paths: Array<string>): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    paths.splice(0, 0, path);\r\n    _archiveEncodeArrayInPlace(uriPathModule, paths);\r\n    return createRemoteUri(\r\n      hostname,\r\n      _archiveDecode(uriPathModule, uriPathModule.resolve.apply(null, paths)),\r\n    );\r\n  } else {\r\n    paths.splice(0, 0, uri);\r\n    _archiveEncodeArrayInPlace(uriPathModule, paths);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.resolve.apply(null, paths),\r\n    );\r\n  }\r\n}\r\n\r\nfunction isHomeRelative(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return uri.startsWith('~');\r\n}\r\n\r\nfunction expandHomeDir(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n\r\n  // Do not expand non home relative uris\r\n  if (!uri.startsWith('~')) {\r\n    return uri;\r\n  }\r\n\r\n  // \"home\" on Windows is %UserProfile%. Note that Windows environment variables\r\n  // are NOT case sensitive, but process.env is a magic object that wraps GetEnvironmentVariableW\r\n  // on Windows, so asking for any case is expected to work.\r\n  const {HOME, UserProfile} = process.env;\r\n\r\n  const isWindows = !isRemote(uri) && os.platform() === 'win32';\r\n  const homePath = isWindows ? UserProfile : HOME;\r\n  invariant(homePath != null);\r\n\r\n  if (uri === '~') {\r\n    return homePath;\r\n  }\r\n\r\n  // Uris like ~abc should not be expanded\r\n  if (!uri.startsWith('~/') && (!isWindows || !uri.startsWith('~\\\\'))) {\r\n    return uri;\r\n  }\r\n\r\n  return pathModule.resolve(homePath, uri.replace('~', '.'));\r\n}\r\n\r\n/**\r\n * Splits a string containing local paths by an OS-specific path delimiter\r\n * Useful for splitting env variables such as PATH\r\n *\r\n * Since remote URI might contain the delimiter, only local paths are allowed.\r\n */\r\nfunction splitPathList(paths: string): Array<NuclideUri> {\r\n  invariant(\r\n    paths.indexOf(REMOTE_PATH_URI_PREFIX) < 0,\r\n    'Splitting remote URIs is not supported',\r\n  );\r\n  const uriPathModule = _pathModuleFor(paths);\r\n\r\n  return paths.split(uriPathModule.delimiter);\r\n}\r\n\r\n/**\r\n * Joins an array of local paths with an OS-specific path delimiter into a single string.\r\n * Useful for constructing env variables such as PATH\r\n *\r\n * Since remote URI might contain the delimiter, only local paths are allowed.\r\n */\r\nfunction joinPathList(paths: Array<NuclideUri>): string {\r\n  if (paths.length === 0) {\r\n    return '';\r\n  }\r\n\r\n  invariant(\r\n    paths.every(path => !isRemote(path)),\r\n    'Joining of remote URIs is not supported',\r\n  );\r\n\r\n  const uriPathModule = _pathModuleFor(paths[0]);\r\n  return paths.join(uriPathModule.delimiter);\r\n}\r\n\r\n/**\r\n * This function prepends the given relative path with a \"current-folder\" prefix\r\n * which is `./` on *nix and .\\ on Windows\r\n */\r\nfunction ensureLocalPrefix(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n\r\n  invariant(!isRemote(uri), 'Local prefix can not be added to a remote path');\r\n  invariant(\r\n    !isAbsolute(uri),\r\n    'Local prefix can not be added to an absolute path',\r\n  );\r\n\r\n  const localPrefix = `.${uriPathModule.sep}`;\r\n  if (uri.startsWith(localPrefix)) {\r\n    return uri;\r\n  }\r\n\r\n  return localPrefix + uri;\r\n}\r\n\r\nfunction isRoot(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return dirname(uri) === uri;\r\n}\r\n\r\nfunction parsePath(uri: NuclideUri): ParsedPath {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  const parsed = uriPathModule.parse(\r\n    _archiveEncode(uriPathModule, getPath(uri)),\r\n  );\r\n  return {\r\n    root: _archiveDecode(uriPathModule, parsed.root),\r\n    dir: _archiveDecode(uriPathModule, parsed.dir),\r\n    base: _archiveDecode(uriPathModule, parsed.base),\r\n    ext: _archiveDecode(uriPathModule, parsed.ext),\r\n    name: _archiveDecode(uriPathModule, parsed.name),\r\n  };\r\n}\r\n\r\nfunction pathSeparatorFor(uri: NuclideUri): string {\r\n  return _pathModuleFor(uri).sep;\r\n}\r\n\r\nfunction split(uri: NuclideUri): Array<string> {\r\n  const parts = [];\r\n  let current = uri;\r\n  let parent = dirname(current);\r\n\r\n  while (current !== parent) {\r\n    parts.push(basename(current));\r\n\r\n    current = parent;\r\n    parent = dirname(current);\r\n  }\r\n\r\n  if (isAbsolute(uri)) {\r\n    parts.push(parent);\r\n  }\r\n  parts.reverse();\r\n  return parts;\r\n}\r\n\r\nfunction hasKnownArchiveExtension(uri: NuclideUri): boolean {\r\n  return KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext));\r\n}\r\n\r\nfunction _pathModuleFor(uri: NuclideUri): typeof pathModule {\r\n  invariant(\r\n    !_endsWithArchiveSeparator(uri),\r\n    `Path cannot end with archive separator. Failed to determine path module for ${uri}`,\r\n  );\r\n  if (uri.startsWith(pathModule.posix.sep)) {\r\n    return pathModule.posix;\r\n  }\r\n  if (uri.indexOf('://') > -1) {\r\n    return pathModule.posix;\r\n  }\r\n  if (uri[1] === ':' && uri[2] === pathModule.win32.sep) {\r\n    return pathModule.win32;\r\n  }\r\n\r\n  // This little russian roulette here is blocking T29990593. I didn't\r\n  // clean it because we might see posix paths on windows and vice versa.\r\n  if (\r\n    uri.split(pathModule.win32.sep).length >\r\n    uri.split(pathModule.posix.sep).length\r\n  ) {\r\n    return pathModule.win32;\r\n  } else {\r\n    return pathModule.posix;\r\n  }\r\n}\r\n\r\n// Runs _archiveEncode in-place on array, and returns argument for convenience.\r\nfunction _archiveEncodeArrayInPlace(\r\n  uriPathModule: typeof pathModule,\r\n  array: Array<NuclideUri>,\r\n): Array<NuclideUri> {\r\n  array.forEach((uri, i, a) => (a[i] = _archiveEncode(uriPathModule, uri)));\r\n  return array;\r\n}\r\n\r\n// This adds a native separator after every archive separator\r\n// so that the native path handling code sees them.\r\nfunction _archiveEncode(\r\n  uriPathModule: typeof pathModule,\r\n  uri: NuclideUri,\r\n): NuclideUri {\r\n  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return uri;\r\n  }\r\n  return KNOWN_ARCHIVE_EXTENSIONS.reduce(\r\n    (acc, ext) =>\r\n      acc.replace(\r\n        `${ext}${ARCHIVE_SEPARATOR}`,\r\n        `${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`,\r\n      ),\r\n    uri,\r\n  );\r\n}\r\n\r\n// This is the inverse of `encodeArchiveSeparators()` to put things\r\n// back after the native path handler has run.\r\nfunction _archiveDecode(\r\n  uriPathModule: typeof pathModule,\r\n  uri: NuclideUri,\r\n): NuclideUri {\r\n  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return uri;\r\n  }\r\n  return _trimArchiveSuffix(\r\n    KNOWN_ARCHIVE_EXTENSIONS.reduce(\r\n      (acc, ext) =>\r\n        acc.replace(\r\n          `${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`,\r\n          `${ext}${ARCHIVE_SEPARATOR}`,\r\n        ),\r\n      uri,\r\n    ),\r\n  );\r\n}\r\n\r\n// When working with encoded uri's, the archive separator is part of the name\r\n// so we can manipulate paths with uriPathModule.  However, in `relative` if\r\n// one uri contains the other, we need the names seen by uriPathModule to agree\r\n// on whether there is an archive separator or not.  E.g. if we have:\r\n//    /etc/file.zip\r\n//    /etc/file.zip!abc\r\n// When we encode these, we get:\r\n//    /etc/file.zip\r\n//    /etc/file.zip!/abc\r\n// We need to add a trailing '!' to the first one so uriPathModule can see that\r\n// the first contains the second.\r\nfunction _matchTrailingArchive(uri: string, other: string): string {\r\n  if (\r\n    uri.length < other.length &&\r\n    other.startsWith(uri) &&\r\n    _isArchiveSeparator(other, uri.length)\r\n  ) {\r\n    return uri + ARCHIVE_SEPARATOR;\r\n  } else {\r\n    return uri;\r\n  }\r\n}\r\n\r\nfunction _trimArchiveSuffix(path: string): string {\r\n  if (_endsWithArchiveSeparator(path)) {\r\n    return path.substring(0, path.length - ARCHIVE_SEPARATOR.length);\r\n  } else {\r\n    return path;\r\n  }\r\n}\r\n\r\nfunction _endsWithArchiveSeparator(path: string): boolean {\r\n  return _isArchiveSeparator(path, path.length - 1);\r\n}\r\n\r\nfunction _isArchiveSeparator(path: string, index: number): boolean {\r\n  return (\r\n    path.length > index &&\r\n    path.charAt(index) === ARCHIVE_SEPARATOR &&\r\n    KNOWN_ARCHIVE_EXTENSIONS.some(ext => {\r\n      const extStart = index - ext.length;\r\n      return path.indexOf(ext, extStart) === extStart;\r\n    })\r\n  );\r\n}\r\n\r\nfunction _testForIllegalUri(uri: ?NuclideUri): void {\r\n  if (uri != null) {\r\n    if (_endsWithArchiveSeparator(uri)) {\r\n      throw new Error(\r\n        `Path operation invoked on URI ending with ${ARCHIVE_SEPARATOR}: ${uri}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nconst NUCLIDE_URI_TYPE_NAME = 'NuclideUri';\r\n\r\n// If mustBeRemote is present then remote-ness must match, otherwise remote-ness\r\n// is ignored.\r\nfunction validate(uri: NuclideUri, mustBeRemote?: boolean): void {\r\n  // Be a little extra paranoid to catch places where the type system may be weak.\r\n  invariant(uri != null, 'Unexpected null NuclideUri');\r\n  invariant(\r\n    typeof uri === 'string',\r\n    `Unexpected NuclideUri type: ${String(uri)}`,\r\n  );\r\n\r\n  if (isRemote(uri)) {\r\n    parse(uri);\r\n    invariant(mustBeRemote !== false, 'Expected remote NuclideUri');\r\n  } else {\r\n    invariant(uri !== '', 'NuclideUri must contain a non-empty path');\r\n    invariant(mustBeRemote !== true, 'Expected local NuclideUri');\r\n  }\r\n}\r\n\r\nconst IMAGE_EXTENSIONS = new Set([\r\n  '.bmp',\r\n  '.gif',\r\n  '.ico',\r\n  '.jpeg',\r\n  '.jpg',\r\n  '.png',\r\n  '.webp',\r\n]);\r\n\r\n/**\r\n * Returns true if this filename looks like an image that Nuclide can open; otherwise false.\r\n */\r\nfunction looksLikeImageUri(uri: NuclideUri): boolean {\r\n  const ext = extname(uri).toLowerCase();\r\n  return IMAGE_EXTENSIONS.has(ext);\r\n}\r\n\r\nexport default {\r\n  basename,\r\n  dirname,\r\n  extname,\r\n  stripExtension,\r\n  isRemote,\r\n  isLocal,\r\n  createRemoteUri,\r\n  isInArchive,\r\n  ancestorOutsideArchive,\r\n  parse,\r\n  parseRemoteUri,\r\n  validate,\r\n  getPath,\r\n  getHostname,\r\n  getHostnameOpt,\r\n  join,\r\n  joinArray,\r\n  archiveJoin,\r\n  relative,\r\n  looksLikeImageUri,\r\n  normalize,\r\n  normalizeDir,\r\n  getParent,\r\n  uriToNuclideUri,\r\n  nuclideUriToUri,\r\n  contains,\r\n  collapse,\r\n  nuclideUriToDisplayString,\r\n  nuclideUriToDisplayHostname,\r\n  hostnameToDisplayHostname,\r\n  registerHostnameFormatter,\r\n  ensureTrailingSeparator,\r\n  trimTrailingSeparator,\r\n  endsWithSeparator,\r\n  endsWithEdenDir,\r\n  isAbsolute,\r\n  isHomeRelative,\r\n  resolve,\r\n  expandHomeDir,\r\n  splitPathList,\r\n  joinPathList,\r\n  ensureLocalPrefix,\r\n  isRoot,\r\n  parsePath,\r\n  split,\r\n  pathSeparatorFor,\r\n  hasKnownArchiveExtension,\r\n  ARCHIVE_SEPARATOR,\r\n  KNOWN_ARCHIVE_EXTENSIONS,\r\n  NUCLIDE_URI_TYPE_NAME,\r\n};\r\n\r\nexport const __TEST__ = {\r\n  _pathModuleFor,\r\n};\r\n","\"use strict\";\n\nfunction _(message, opts) {\n    return `${opts && opts.context ? opts.context : \"Value\"} ${message}.`;\n}\n\nfunction type(V) {\n    if (V === null) {\n        return \"Null\";\n    }\n    switch (typeof V) {\n        case \"undefined\":\n            return \"Undefined\";\n        case \"boolean\":\n            return \"Boolean\";\n        case \"number\":\n            return \"Number\";\n        case \"string\":\n            return \"String\";\n        case \"symbol\":\n            return \"Symbol\";\n        case \"object\":\n            // Falls through\n        case \"function\":\n            // Falls through\n        default:\n            // Per ES spec, typeof returns an implemention-defined value that is not any of the existing ones for\n            // uncallable non-standard exotic objects. Yet Type() which the Web IDL spec depends on returns Object for\n            // such cases. So treat the default case as an object.\n            return \"Object\";\n    }\n}\n\n// Round x to the nearest integer, choosing the even integer if it lies halfway between two.\nfunction evenRound(x) {\n    // There are four cases for numbers with fractional part being .5:\n    //\n    // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\n    //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\n    //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\n    //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\n    //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\n    // (where n is a non-negative integer)\n    //\n    // Branch here for cases 1 and 4\n    if ((x > 0 && (x % 1) === +0.5 && (x & 1) === 0) ||\n        (x < 0 && (x % 1) === -0.5 && (x & 1) === 1)) {\n        return censorNegativeZero(Math.floor(x));\n    }\n\n    return censorNegativeZero(Math.round(x));\n}\n\nfunction integerPart(n) {\n    return censorNegativeZero(Math.trunc(n));\n}\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction modulo(x, y) {\n    // https://tc39.github.io/ecma262/#eqn-modulo\n    // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos\n    const signMightNotMatch = x % y;\n    if (sign(y) !== sign(signMightNotMatch)) {\n        return signMightNotMatch + y;\n    }\n    return signMightNotMatch;\n}\n\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\n\nfunction createIntegerConversion(bitLength, typeOpts) {\n    const isSigned = !typeOpts.unsigned;\n\n    let lowerBound;\n    let upperBound;\n    if (bitLength === 64) {\n        upperBound = Math.pow(2, 53) - 1;\n        lowerBound = !isSigned ? 0 : -Math.pow(2, 53) + 1;\n    } else if (!isSigned) {\n        lowerBound = 0;\n        upperBound = Math.pow(2, bitLength) - 1;\n    } else {\n        lowerBound = -Math.pow(2, bitLength - 1);\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n    }\n\n    const twoToTheBitLength = Math.pow(2, bitLength);\n    const twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);\n\n    return (V, opts) => {\n        if (opts === undefined) {\n            opts = {};\n        }\n\n        let x = +V;\n        x = censorNegativeZero(x); // Spec discussion ongoing: https://github.com/heycam/webidl/issues/306\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(_(\"is not a finite number\", opts));\n            }\n\n            x = integerPart(x);\n\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(_(\n                    `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, opts));\n            }\n\n            return x;\n        }\n\n        if (!Number.isNaN(x) && opts.clamp) {\n            x = Math.min(Math.max(x, lowerBound), upperBound);\n            x = evenRound(x);\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n        x = integerPart(x);\n\n        // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if\n        // possible. Hopefully it's an optimization for the non-64-bitLength cases too.\n        if (x >= lowerBound && x <= upperBound) {\n            return x;\n        }\n\n        // These will not work great for bitLength of 64, but oh well. See the README for more details.\n        x = modulo(x, twoToTheBitLength);\n        if (isSigned && x >= twoToOneLessThanTheBitLength) {\n            return x - twoToTheBitLength;\n        }\n        return x;\n    };\n}\n\nexports.any = V => {\n    return V;\n};\n\nexports.void = function () {\n    return undefined;\n};\n\nexports.boolean = function (val) {\n    return !!val;\n};\n\nexports.byte = createIntegerConversion(8, { unsigned: false });\nexports.octet = createIntegerConversion(8, { unsigned: true });\n\nexports.short = createIntegerConversion(16, { unsigned: false });\nexports[\"unsigned short\"] = createIntegerConversion(16, { unsigned: true });\n\nexports.long = createIntegerConversion(32, { unsigned: false });\nexports[\"unsigned long\"] = createIntegerConversion(32, { unsigned: true });\n\nexports[\"long long\"] = createIntegerConversion(64, { unsigned: false });\nexports[\"unsigned long long\"] = createIntegerConversion(64, { unsigned: true });\n\nexports.double = (V, opts) => {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(_(\"is not a finite floating-point value\", opts));\n    }\n\n    return x;\n};\n\nexports[\"unrestricted double\"] = V => {\n    const x = +V;\n\n    return x;\n};\n\nexports.float = (V, opts) => {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(_(\"is not a finite floating-point value\", opts));\n    }\n\n    if (Object.is(x, -0)) {\n        return x;\n    }\n\n    const y = Math.fround(x);\n\n    if (!Number.isFinite(y)) {\n        throw new TypeError(_(\"is outside the range of a single-precision floating-point value\", opts));\n    }\n\n    return y;\n};\n\nexports[\"unrestricted float\"] = V => {\n    const x = +V;\n\n    if (isNaN(x)) {\n        return x;\n    }\n\n    if (Object.is(x, -0)) {\n        return x;\n    }\n\n    return Math.fround(x);\n};\n\nexports.DOMString = function (V, opts) {\n    if (opts === undefined) {\n        opts = {};\n    }\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    if (typeof V === \"symbol\") {\n        throw new TypeError(_(\"is a symbol, which cannot be converted to a string\", opts));\n    }\n\n    return String(V);\n};\n\nexports.ByteString = (V, opts) => {\n    const x = exports.DOMString(V, opts);\n    let c;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(_(\"is not a valid ByteString\", opts));\n        }\n    }\n\n    return x;\n};\n\nexports.USVString = (V, opts) => {\n    const S = exports.DOMString(V, opts);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else if (i === n - 1) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            const d = S.charCodeAt(i + 1);\n            if (0xDC00 <= d && d <= 0xDFFF) {\n                const a = c & 0x3FF;\n                const b = d & 0x3FF;\n                U.push(String.fromCodePoint((2 << 15) + ((2 << 9) * a) + b));\n                ++i;\n            } else {\n                U.push(String.fromCodePoint(0xFFFD));\n            }\n        }\n    }\n\n    return U.join(\"\");\n};\n\nexports.object = (V, opts) => {\n    if (type(V) !== \"Object\") {\n        throw new TypeError(_(\"is not an object\", opts));\n    }\n\n    return V;\n};\n\n// Not exported, but used in Function and VoidFunction.\n\n// Neither Function nor VoidFunction is defined with [TreatNonObjectAsNull], so\n// handling for that is omitted.\nfunction convertCallbackFunction(V, opts) {\n    if (typeof V !== \"function\") {\n        throw new TypeError(_(\"is not a function\", opts));\n    }\n    return V;\n}\n\n[\n    Error,\n    ArrayBuffer, // The IsDetachedBuffer abstract operation is not exposed in JS\n    DataView, Int8Array, Int16Array, Int32Array, Uint8Array,\n    Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array\n].forEach(func => {\n    const name = func.name;\n    const article = /^[AEIOU]/.test(name) ? \"an\" : \"a\";\n    exports[name] = (V, opts) => {\n        if (!(V instanceof func)) {\n            throw new TypeError(_(`is not ${article} ${name} object`, opts));\n        }\n\n        return V;\n    };\n});\n\n// Common definitions\n\nexports.ArrayBufferView = (V, opts) => {\n    if (!ArrayBuffer.isView(V)) {\n        throw new TypeError(_(\"is not a view on an ArrayBuffer object\", opts));\n    }\n\n    return V;\n};\n\nexports.BufferSource = (V, opts) => {\n    if (!(ArrayBuffer.isView(V) || V instanceof ArrayBuffer)) {\n        throw new TypeError(_(\"is not an ArrayBuffer object or a view on one\", opts));\n    }\n\n    return V;\n};\n\nexports.DOMTimeStamp = exports[\"unsigned long long\"];\n\nexports.Function = convertCallbackFunction;\n\nexports.VoidFunction = convertCallbackFunction;\n","\"use strict\";\n\n// Returns \"Type(value) is Object\" in ES terminology.\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n\nfunction getReferenceToBytes(bufferSource) {\n  // Node.js' Buffer does not allow subclassing for now, so we can get away with a prototype object check for perf.\n  if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {\n    return bufferSource;\n  }\n  if (bufferSource instanceof ArrayBuffer) {\n    return Buffer.from(bufferSource);\n  }\n  return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);\n}\n\nfunction getCopyToBytes(bufferSource) {\n  return Buffer.from(getReferenceToBytes(bufferSource));\n}\n\nfunction mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n}\n\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\nconst sameObjectCaches = Symbol(\"SameObject caches\");\n\nfunction getSameObject(wrapper, prop, creator) {\n  if (!wrapper[sameObjectCaches]) {\n    wrapper[sameObjectCaches] = Object.create(null);\n  }\n\n  if (prop in wrapper[sameObjectCaches]) {\n    return wrapper[sameObjectCaches][prop];\n  }\n\n  wrapper[sameObjectCaches][prop] = creator();\n  return wrapper[sameObjectCaches][prop];\n}\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n}\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n}\n\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n}\n\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n}\n\nconst iterInternalSymbol = Symbol(\"internal\");\nconst IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\nmodule.exports = exports = {\n  isObject,\n  getReferenceToBytes,\n  getCopyToBytes,\n  mixin,\n  wrapperSymbol,\n  implSymbol,\n  getSameObject,\n  wrapperForImpl,\n  implForWrapper,\n  tryWrapperForImpl,\n  tryImplForWrapper,\n  iterInternalSymbol,\n  IteratorPrototype\n};\n","\"use strict\";\nconst legacyErrorCodes = require(\"./legacy-error-codes.json\");\nconst idlUtils = require(\"./utils.js\");\n\nexports.implementation = class DOMExceptionImpl {\n  constructor([message, name]) {\n    this.name = name;\n    this.message = message;\n  }\n\n  get code() {\n    return legacyErrorCodes[this.name] || 0;\n  }\n};\n\n// A proprietary V8 extension that causes the stack property to appear.\nexports.init = impl => {\n  if (Error.captureStackTrace) {\n    const wrapper = idlUtils.wrapperForImpl(impl);\n    Error.captureStackTrace(wrapper, wrapper.constructor);\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst impl = utils.implSymbol;\n\nfunction DOMException() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n\n  if (args[0] !== undefined) {\n    args[0] = conversions[\"DOMString\"](args[0], { context: \"Failed to construct 'DOMException': parameter 1\" });\n  } else {\n    args[0] = \"\";\n  }\n\n  if (args[1] !== undefined) {\n    args[1] = conversions[\"DOMString\"](args[1], { context: \"Failed to construct 'DOMException': parameter 2\" });\n  } else {\n    args[1] = \"Error\";\n  }\n\n  iface.setup(this, args);\n}\n\nObject.defineProperty(DOMException, \"prototype\", {\n  value: DOMException.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nObject.defineProperty(DOMException.prototype, \"name\", {\n  get() {\n    return this[impl][\"name\"];\n  },\n\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(DOMException.prototype, \"message\", {\n  get() {\n    return this[impl][\"message\"];\n  },\n\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(DOMException.prototype, \"code\", {\n  get() {\n    return this[impl][\"code\"];\n  },\n\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(DOMException, \"INDEX_SIZE_ERR\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"INDEX_SIZE_ERR\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"DOMSTRING_SIZE_ERR\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"DOMSTRING_SIZE_ERR\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"HIERARCHY_REQUEST_ERR\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"HIERARCHY_REQUEST_ERR\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"WRONG_DOCUMENT_ERR\", {\n  value: 4,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"WRONG_DOCUMENT_ERR\", {\n  value: 4,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"INVALID_CHARACTER_ERR\", {\n  value: 5,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"INVALID_CHARACTER_ERR\", {\n  value: 5,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"NO_DATA_ALLOWED_ERR\", {\n  value: 6,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"NO_DATA_ALLOWED_ERR\", {\n  value: 6,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"NO_MODIFICATION_ALLOWED_ERR\", {\n  value: 7,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"NO_MODIFICATION_ALLOWED_ERR\", {\n  value: 7,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"NOT_FOUND_ERR\", {\n  value: 8,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"NOT_FOUND_ERR\", {\n  value: 8,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"NOT_SUPPORTED_ERR\", {\n  value: 9,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"NOT_SUPPORTED_ERR\", {\n  value: 9,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"INUSE_ATTRIBUTE_ERR\", {\n  value: 10,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"INUSE_ATTRIBUTE_ERR\", {\n  value: 10,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"INVALID_STATE_ERR\", {\n  value: 11,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"INVALID_STATE_ERR\", {\n  value: 11,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"SYNTAX_ERR\", {\n  value: 12,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"SYNTAX_ERR\", {\n  value: 12,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"INVALID_MODIFICATION_ERR\", {\n  value: 13,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"INVALID_MODIFICATION_ERR\", {\n  value: 13,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"NAMESPACE_ERR\", {\n  value: 14,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"NAMESPACE_ERR\", {\n  value: 14,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"INVALID_ACCESS_ERR\", {\n  value: 15,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"INVALID_ACCESS_ERR\", {\n  value: 15,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"VALIDATION_ERR\", {\n  value: 16,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"VALIDATION_ERR\", {\n  value: 16,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"TYPE_MISMATCH_ERR\", {\n  value: 17,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"TYPE_MISMATCH_ERR\", {\n  value: 17,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"SECURITY_ERR\", {\n  value: 18,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"SECURITY_ERR\", {\n  value: 18,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"NETWORK_ERR\", {\n  value: 19,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"NETWORK_ERR\", {\n  value: 19,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"ABORT_ERR\", {\n  value: 20,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"ABORT_ERR\", {\n  value: 20,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"URL_MISMATCH_ERR\", {\n  value: 21,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"URL_MISMATCH_ERR\", {\n  value: 21,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"QUOTA_EXCEEDED_ERR\", {\n  value: 22,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"QUOTA_EXCEEDED_ERR\", {\n  value: 22,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"TIMEOUT_ERR\", {\n  value: 23,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"TIMEOUT_ERR\", {\n  value: 23,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"INVALID_NODE_TYPE_ERR\", {\n  value: 24,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"INVALID_NODE_TYPE_ERR\", {\n  value: 24,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException, \"DATA_CLONE_ERR\", {\n  value: 25,\n  enumerable: true\n});\nObject.defineProperty(DOMException.prototype, \"DATA_CLONE_ERR\", {\n  value: 25,\n  enumerable: true\n});\n\nObject.defineProperty(DOMException.prototype, Symbol.toStringTag, {\n  value: \"DOMException\",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  convert(obj, { context = \"The provided value\" } = {}) {\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n    throw new TypeError(`${context} is not of type 'DOMException'.`);\n  },\n\n  create(constructorArgs, privateData) {\n    let obj = Object.create(DOMException.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(DOMException.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {},\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(constructorArgs, privateData),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    obj[impl][utils.wrapperSymbol] = obj;\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n  },\n  interface: DOMException,\n  expose: {\n    Window: { DOMException },\n    Worker: { DOMException }\n  }\n}; // iface\nmodule.exports = iface;\n\nconst Impl = require(\".//DOMException-impl.js\");\n","\"use strict\";\n\nmodule.exports = require(\"./DOMException\").interface;\n\nObject.setPrototypeOf(module.exports.prototype, Error.prototype);\n","/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event)\n    return retv\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        const data = pd(this)\n        if (data.passiveListener != null) {\n            console.warn(\"Event#preventDefault() was called from a passive listener:\", data.passiveListener)\n            return\n        }\n        if (!data.event.cancelable) {\n            return\n        }\n\n        data.canceled = true\n        if (typeof data.event.preventDefault === \"function\") {\n            data.event.preventDefault()\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", { value: Event, configurable: true, writable: true })\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = (typeof descriptor.value === \"function\")\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the stopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).stopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import { isStopped, setCurrentTarget, setEventPhase, setPassiveListener, wrapEvent } from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\")\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    }\n                    else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    }\n                    else {\n                        listeners.delete(eventName)\n                    }\n                }\n                else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                }\n                else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName))\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: { value: CustomEventTarget, configurable: true, writable: true },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n * \n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n * \n * For example:\n * \n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {boolean} `true` if the listener was added actually.\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return false\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options)\n        const listenerType = (capture ? CAPTURE : BUBBLE)\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return true\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return false\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n        return true\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {boolean} `true` if the listener was removed actually.\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return false\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options)\n        const listenerType = (capture ? CAPTURE : BUBBLE)\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next\n                }\n                else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                }\n                else {\n                    listeners.delete(eventName)\n                }\n                return true\n            }\n\n            prev = node\n            node = node.next\n        }\n\n        return false\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError(\"\\\"event.type\\\" should be a string.\")\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                }\n                else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                }\n                else {\n                    listeners.delete(eventName)\n                }\n            }\n            else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(wrappedEvent, (node.passive ? node.listener : null))\n            if (typeof node.listener === \"function\") {\n                node.listener.call(this, wrappedEvent)\n            }\n            else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", { value: EventTarget, configurable: true, writable: true })\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\n/**\r\n * This implements polyfills for AbortSignal and AbortController\r\n * from the whatwg spec: https://dom.spec.whatwg.org/#aborting-ongoing-activities\r\n * These will become available in Chrome 66.\r\n */\r\n\r\n// Shim of EventTarget usable in Node.\r\n// Note that even in Chrome, EventTarget also isn't instantiable until version 64.\r\nimport {\r\n  EventTarget as EventTargetShim,\r\n  defineEventAttribute,\r\n} from 'event-target-shim';\r\n\r\nexport class AbortSignal extends (EventTargetShim: typeof EventTarget) {\r\n  aborted: boolean = false;\r\n  // Defined via defineEventAttribute below.\r\n  onabort: ?(event: Event) => mixed;\r\n\r\n  // $FlowIssue: Computed properties are not supported\r\n  get [Symbol.toStringTag]() {\r\n    return 'AbortSignal';\r\n  }\r\n}\r\n\r\ndefineEventAttribute(AbortSignal.prototype, 'abort');\r\n\r\nexport default class AbortController {\r\n  signal = new AbortSignal();\r\n\r\n  abort() {\r\n    // From whatwg spec, section 3.2:\r\n    // If signal’s aborted flag is set, then return.\r\n    if (this.signal.aborted) {\r\n      return;\r\n    }\r\n    // Set signal’s aborted flag.\r\n    this.signal.aborted = true;\r\n    // Fire an event named abort at signal.\r\n    // Note: event-target-shim converts objects to Events.\r\n    this.signal.dispatchEvent(({type: 'abort'}: any));\r\n  }\r\n\r\n  // $FlowIssue: Computed properties are not supported\r\n  get [Symbol.toStringTag]() {\r\n    return 'AbortController';\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\n\r\nexport function ensureArray<T>(x: Array<T> | T): Array<T> {\r\n  return Array.isArray(x) ? x : [x];\r\n}\r\n\r\nexport function arrayRemove<T>(array: Array<T>, element: T): void {\r\n  const index = array.indexOf(element);\r\n  if (index >= 0) {\r\n    array.splice(index, 1);\r\n  }\r\n}\r\n\r\nexport function arrayEqual<T>(\r\n  array1: $ReadOnlyArray<T>,\r\n  array2: $ReadOnlyArray<T>,\r\n  equalComparator?: (a: T, b: T) => boolean,\r\n): boolean {\r\n  if (array1 === array2) {\r\n    return true;\r\n  }\r\n  if (array1.length !== array2.length) {\r\n    return false;\r\n  }\r\n  const equalFunction = equalComparator || ((a: T, b: T) => a === b);\r\n  return array1.every((item1, i) => equalFunction(item1, array2[i]));\r\n}\r\n\r\n/**\r\n * Returns a copy of the input Array with all `null` and `undefined` values filtered out.\r\n * Allows Flow to typecheck the common `filter(x => x != null)` pattern.\r\n */\r\nexport function arrayCompact<T>(array: $ReadOnlyArray<?T>): Array<T> {\r\n  const result = [];\r\n  for (const elem of array) {\r\n    if (elem != null) {\r\n      result.push(elem);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Flattens an Array<Array<T>> into just an Array<T>\r\n */\r\nexport function arrayFlatten<T>(\r\n  array: $ReadOnlyArray<$ReadOnlyArray<T>>,\r\n): Array<T> {\r\n  const result = [];\r\n  for (const subArray of array) {\r\n    for (const element of subArray) {\r\n      result.push(element);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Removes duplicates from Array<T>.\r\n * Uses SameValueZero for equality purposes, which is like '===' except it deems\r\n * two NaNs equal. http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero\r\n */\r\nexport function arrayUnique<T>(array: $ReadOnlyArray<T>): Array<T> {\r\n  return Array.from(new Set(array));\r\n}\r\n\r\n/**\r\n * Returns the last index in the input array that matches the predicate.\r\n * Returns -1 if no match is found.\r\n */\r\nexport function arrayFindLastIndex<T>(\r\n  array: $ReadOnlyArray<T>,\r\n  predicate: (elem: T, index: number, array: $ReadOnlyArray<T>) => boolean,\r\n  thisArg?: any,\r\n): number {\r\n  for (let i = array.length - 1; i >= 0; i--) {\r\n    if (predicate.call(thisArg, array[i], i, array)) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\n/**\r\n * Return the first index in array where subarray is equal to the next\r\n * subarray-sized slice of array. Return -1 if no match is found.\r\n */\r\nexport function findSubArrayIndex<T>(\r\n  array: $ReadOnlyArray<T>,\r\n  subarr: $ReadOnlyArray<T>,\r\n): number {\r\n  return array.findIndex((_, offset) =>\r\n    arrayEqual(array.slice(offset, offset + subarr.length), subarr),\r\n  );\r\n}\r\n\r\n/**\r\n * Separates an array into two subarrays -- the first contains all elements that\r\n * match the predicate and the latter contains all the rest that fail.\r\n */\r\nexport function arrayPartition<T>(\r\n  array: $ReadOnlyArray<T>,\r\n  predicate: (elem: T) => boolean,\r\n): [Array<T>, Array<T>] {\r\n  const pass = [];\r\n  const fail = [];\r\n  array.forEach(elem => (predicate(elem) ? pass.push(elem) : fail.push(elem)));\r\n  return [pass, fail];\r\n}\r\n\r\n/**\r\n * Merges a given arguments of maps into one Map, with the latest maps\r\n * overriding the values of the prior maps.\r\n */\r\nexport function mapUnion<T, X>(...maps: $ReadOnlyArray<Map<T, X>>): Map<T, X> {\r\n  const unionMap = new Map();\r\n  for (const map of maps) {\r\n    for (const [key, value] of map) {\r\n      unionMap.set(key, value);\r\n    }\r\n  }\r\n  return unionMap;\r\n}\r\n\r\nexport function mapCompact<T, X>(map: Map<T, ?X>): Map<T, X> {\r\n  const selected = new Map();\r\n  for (const [key, value] of map) {\r\n    if (value != null) {\r\n      selected.set(key, value);\r\n    }\r\n  }\r\n  return selected;\r\n}\r\n\r\nexport function mapFilter<T, X>(\r\n  map: Map<T, X>,\r\n  selector: (key: T, value: X) => boolean,\r\n): Map<T, X> {\r\n  const selected = new Map();\r\n  for (const [key, value] of map) {\r\n    if (selector(key, value)) {\r\n      selected.set(key, value);\r\n    }\r\n  }\r\n  return selected;\r\n}\r\n\r\nexport function mapTransform<T, V1, V2>(\r\n  src: Map<T, V1>,\r\n  transform: (value: V1, key: T) => V2,\r\n): Map<T, V2> {\r\n  const result = new Map();\r\n  for (const [key, value] of src) {\r\n    result.set(key, transform(value, key));\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function mapEqual<T, X>(\r\n  map1: Map<T, X>,\r\n  map2: Map<T, X>,\r\n  equalComparator?: (val1: X, val2: X, key?: T) => boolean,\r\n) {\r\n  if (map1.size !== map2.size) {\r\n    return false;\r\n  }\r\n  const equalFunction = equalComparator || ((a: X, b: X) => a === b);\r\n  for (const [key, value1] of map1) {\r\n    if (!map2.has(key) || !equalFunction(value1, (map2.get(key): any))) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function mapGetWithDefault<K, V>(\r\n  map: Map<K, V>,\r\n  key: K,\r\n  default_: V,\r\n): V {\r\n  if (map.has(key)) {\r\n    // Cast through `any` since map.get's return is a maybe type. We can't just get the value and\r\n    // check it against `null`, since null/undefined may inhabit V. We know this is safe since we\r\n    // just checked that the map has the key.\r\n    return (map.get(key): any);\r\n  } else {\r\n    return default_;\r\n  }\r\n}\r\n\r\nexport function areSetsEqual<T>(a: Set<T>, b: Set<T>): boolean {\r\n  return a.size === b.size && every(a, element => b.has(element));\r\n}\r\n\r\n// Array.every but for any iterable.\r\nexport function every<T>(\r\n  values: Iterable<T>,\r\n  predicate: (element: T) => boolean,\r\n): boolean {\r\n  for (const element of values) {\r\n    if (!predicate(element)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function setIntersect<T>(a: Set<T>, b: Set<T>): Set<T> {\r\n  return setFilter(a, e => b.has(e));\r\n}\r\n\r\nfunction setUnionTwo<T>(a: Set<T>, b: Set<T>): Set<T> {\r\n  // Avoids the extra Array allocations that `new Set([...a, ...b])` would incur. Some quick tests\r\n  // indicate it would be about 60% slower.\r\n  const result = new Set(a);\r\n  b.forEach(x => {\r\n    result.add(x);\r\n  });\r\n  return result;\r\n}\r\n\r\nexport function setUnion<T>(...sets: $ReadOnlyArray<Set<T>>): Set<T> {\r\n  if (sets.length < 1) {\r\n    return new Set();\r\n  }\r\n\r\n  const setReducer = (accumulator: Set<T>, current: Set<T>): Set<T> => {\r\n    return setUnionTwo(accumulator, current);\r\n  };\r\n\r\n  return sets.reduce(setReducer);\r\n}\r\n\r\nexport function setDifference<T>(\r\n  a: Set<T>,\r\n  b: Set<T>,\r\n  hash_?: (v: T) => any,\r\n): Set<T> {\r\n  if (a.size === 0) {\r\n    return new Set();\r\n  } else if (b.size === 0) {\r\n    return new Set(a);\r\n  }\r\n  const result = new Set();\r\n  const hash = hash_ || (x => x);\r\n  const bHashes = hash_ == null ? b : new Set(Array.from(b.values()).map(hash));\r\n  a.forEach(value => {\r\n    if (!bHashes.has(hash(value))) {\r\n      result.add(value);\r\n    }\r\n  });\r\n  return result;\r\n}\r\n\r\nexport function setFilter<T>(\r\n  set: Set<T>,\r\n  predicate: (value: T) => boolean,\r\n): Set<T> {\r\n  const out = new Set();\r\n  for (const item of set) {\r\n    if (predicate(item)) {\r\n      out.add(item);\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * O(1)-check if a given object is empty (has no properties, inherited or not)\r\n */\r\nexport function isEmpty(obj: Object): boolean {\r\n  for (const key in obj) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Constructs an enumeration with keys equal to their value.\r\n * e.g. keyMirror({a: null, b: null}) => {a: 'a', b: 'b'}\r\n *\r\n * Based off the equivalent function in www.\r\n */\r\nexport function keyMirror<T: Object>(obj: T): $ObjMapi<T, <K>(k: K) => K> {\r\n  const ret = {};\r\n  Object.keys(obj).forEach(key => {\r\n    ret[key] = key;\r\n  });\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Given an array of [key, value] pairs, construct a map where the values for\r\n * each key are collected into an array of values, in order.\r\n */\r\nexport function collect<K, V>(pairs: $ReadOnlyArray<[K, V]>): Map<K, Array<V>> {\r\n  const result = new Map();\r\n  for (const pair of pairs) {\r\n    const [k, v] = pair;\r\n    let list = result.get(k);\r\n    if (list == null) {\r\n      list = [];\r\n      result.set(k, list);\r\n    }\r\n    list.push(v);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function objectFromPairs<T: string, U>(\r\n  iterable: Iterable<[T, U]>,\r\n): {[T]: U} {\r\n  const result = {};\r\n  for (const [key, value] of iterable) {\r\n    result[key] = value;\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function objectMapValues<T, U, V>(\r\n  object: {[T: string]: U},\r\n  project: (value: U, key: T) => V,\r\n): {[T]: V} {\r\n  const result = {};\r\n  Object.keys(object).forEach(key => {\r\n    result[key] = project(object[key], ((key: any): T));\r\n  });\r\n  return result;\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  // Invariant: no empty sets. They should be removed instead.\r\n  _map: Map<K, Set<V>>;\r\n\r\n  // TODO may be worth defining a getter but no setter, to mimic Map. But please just behave and\r\n  // don't mutate this from outside this class.\r\n  //\r\n  // Invariant: equal to the sum of the sizes of all the sets contained in this._map\r\n  /* The total number of key-value bindings contained */\r\n  size: number;\r\n\r\n  constructor() {\r\n    this._map = new Map();\r\n    this.size = 0;\r\n  }\r\n\r\n  /*\r\n   * Returns the set of values associated with the given key. Do not mutate the given set. Copy it\r\n   * if you need to store it past the next operation on this MultiMap.\r\n   */\r\n  get(key: K): Set<V> {\r\n    const set = this._map.get(key);\r\n    if (set == null) {\r\n      return new Set();\r\n    }\r\n    return set;\r\n  }\r\n\r\n  /*\r\n   * Mimics the Map.prototype.set interface. Deliberately did not choose \"set\" as the name since the\r\n   * implication is that it removes the previous binding.\r\n   */\r\n  add(key: K, value: V): MultiMap<K, V> {\r\n    let set = this._map.get(key);\r\n    if (set == null) {\r\n      set = new Set();\r\n      this._map.set(key, set);\r\n    }\r\n    if (!set.has(value)) {\r\n      set.add(value);\r\n      this.size++;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /*\r\n   * Mimics the Map.prototype.set interface. Replaces the previous binding with new values.\r\n   */\r\n  set(key: K, values: Iterable<V>): void {\r\n    this.deleteAll(key);\r\n    const newSet = new Set(values);\r\n    if (newSet.size !== 0) {\r\n      this._map.set(key, newSet);\r\n      this.size += newSet.size;\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Deletes a single binding. Returns true iff the binding existed.\r\n   */\r\n  delete(key: K, value: V): boolean {\r\n    const set = this.get(key);\r\n    const didRemove = set.delete(value);\r\n    if (set.size === 0) {\r\n      this._map.delete(key);\r\n    }\r\n    if (didRemove) {\r\n      this.size--;\r\n    }\r\n    return didRemove;\r\n  }\r\n\r\n  /*\r\n   * Deletes all bindings associated with the given key. Returns true iff any bindings were deleted.\r\n   */\r\n  deleteAll(key: K): boolean {\r\n    const set = this.get(key);\r\n    this.size -= set.size;\r\n    return this._map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this._map.clear();\r\n    this.size = 0;\r\n  }\r\n\r\n  has(key: K, value: V): boolean {\r\n    return this.get(key).has(value);\r\n  }\r\n\r\n  hasAny(key: K): boolean {\r\n    return this._map.has(key);\r\n  }\r\n\r\n  *values(): Iterable<V> {\r\n    for (const set of this._map.values()) {\r\n      yield* set;\r\n    }\r\n  }\r\n\r\n  forEach(callback: (value: V, key: K, obj: MultiMap<K, V>) => void): void {\r\n    this._map.forEach((values, key) =>\r\n      values.forEach(value => callback(value, key, this)),\r\n    );\r\n  }\r\n}\r\n\r\nexport function objectValues<T>(obj: {[key: string]: T}): Array<T> {\r\n  return Object.keys(obj).map(key => obj[key]);\r\n}\r\n\r\nexport function objectEntries<T>(obj: ?{[key: string]: T}): Array<[string, T]> {\r\n  if (obj == null) {\r\n    throw new TypeError();\r\n  }\r\n  const entries = [];\r\n  for (const key in obj) {\r\n    if (\r\n      obj.hasOwnProperty(key) &&\r\n      Object.prototype.propertyIsEnumerable.call(obj, key)\r\n    ) {\r\n      entries.push([key, obj[key]]);\r\n    }\r\n  }\r\n  return entries;\r\n}\r\n\r\nexport function objectFromMap<T>(map: Map<string, T>): {[key: string]: T} {\r\n  const obj = {};\r\n  map.forEach((v, k) => {\r\n    obj[k] = v;\r\n  });\r\n  return obj;\r\n}\r\n\r\nexport function* concatIterators<T>(\r\n  ...iterators: $ReadOnlyArray<Iterable<T>>\r\n): Iterator<T> {\r\n  for (const iterator of iterators) {\r\n    for (const element of iterator) {\r\n      yield element;\r\n    }\r\n  }\r\n}\r\n\r\nexport function someOfIterable<T>(\r\n  iterable: Iterable<T>,\r\n  predicate: (element: T) => boolean,\r\n): boolean {\r\n  for (const element of iterable) {\r\n    if (predicate(element)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function findInIterable<T>(\r\n  iterable: Iterable<T>,\r\n  predicate: (element: T) => boolean,\r\n): ?T {\r\n  for (const element of iterable) {\r\n    if (predicate(element)) {\r\n      return element;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function* filterIterable<T>(\r\n  iterable: Iterable<T>,\r\n  predicate: (element: T) => boolean,\r\n): Iterable<T> {\r\n  for (const element of iterable) {\r\n    if (predicate(element)) {\r\n      yield element;\r\n    }\r\n  }\r\n}\r\n\r\nexport function* mapIterable<T, M>(\r\n  iterable: Iterable<T>,\r\n  projectorFn: (element: T) => M,\r\n): Iterable<M> {\r\n  for (const element of iterable) {\r\n    yield projectorFn(element);\r\n  }\r\n}\r\n\r\nexport function* takeIterable<T>(\r\n  iterable: Iterable<T>,\r\n  limit: number,\r\n): Iterable<T> {\r\n  let i = 0;\r\n  for (const element of iterable) {\r\n    if (++i > limit) {\r\n      break;\r\n    }\r\n    yield element;\r\n  }\r\n}\r\n\r\n// Return an iterable of the numbers start (inclusive) through stop (exclusive)\r\nexport function* range(\r\n  start: number,\r\n  stop: number,\r\n  step?: number = 1,\r\n): Iterable<number> {\r\n  // We don't currently support negative step values.\r\n  invariant(step > 0);\r\n  for (let i = start; i < stop; i += step) {\r\n    yield i;\r\n  }\r\n}\r\n\r\nexport function firstOfIterable<T>(iterable: Iterable<T>): ?T {\r\n  return findInIterable(iterable, () => true);\r\n}\r\n\r\nexport function iterableIsEmpty<T>(iterable: Iterable<T>): boolean {\r\n  // eslint-disable-next-line no-unused-vars\r\n  for (const element of iterable) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function iterableContains<T>(iterable: Iterable<T>, value: T): boolean {\r\n  return !iterableIsEmpty(\r\n    filterIterable(iterable, element => element === value),\r\n  );\r\n}\r\n\r\nexport function count<T>(iterable: Iterable<T>): number {\r\n  let size = 0;\r\n  // eslint-disable-next-line no-unused-vars\r\n  for (const element of iterable) {\r\n    size++;\r\n  }\r\n  return size;\r\n}\r\n\r\nexport function isIterable(obj: any): boolean {\r\n  return typeof obj[Symbol.iterator] === 'function';\r\n}\r\n\r\n// Traverse an array from the inside out, starting at the specified index.\r\nexport function* insideOut<T>(\r\n  arr: $ReadOnlyArray<T>,\r\n  startingIndex?: number,\r\n): Iterable<[T, number]> {\r\n  if (arr.length === 0) {\r\n    return;\r\n  }\r\n\r\n  let i =\r\n    startingIndex == null\r\n      ? Math.floor(arr.length / 2)\r\n      : Math.min(arr.length, Math.max(0, startingIndex));\r\n  let j = i - 1;\r\n\r\n  while (i < arr.length || j >= 0) {\r\n    if (i < arr.length) {\r\n      yield [arr[i], i];\r\n      i++;\r\n    }\r\n    if (j >= 0) {\r\n      yield [arr[j], j];\r\n      j--;\r\n    }\r\n  }\r\n}\r\n\r\nexport function mapFromObject<T>(obj: {[key: string]: T}): Map<string, T> {\r\n  return new Map(objectEntries(obj));\r\n}\r\n\r\nexport function lastFromArray<T>(arr: $ReadOnlyArray<T>): T {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nexport function distinct<T>(array: T[], keyFn?: (t: T) => string): T[] {\r\n  if (keyFn == null) {\r\n    return Array.from(new Set(array));\r\n  }\r\n\r\n  const seenKeys = new Set();\r\n  return array.filter(elem => {\r\n    const key = keyFn(elem);\r\n    if (seenKeys.has(key)) {\r\n      return false;\r\n    }\r\n    seenKeys.add(key);\r\n    return true;\r\n  });\r\n}\r\n\r\nexport class DefaultMap<K, V> extends Map<K, V> {\r\n  _factory: K => V;\r\n\r\n  constructor(factory: K => V, iterable: ?Iterable<[K, V]>) {\r\n    super(iterable);\r\n    this._factory = factory;\r\n  }\r\n\r\n  get(key: K): V {\r\n    if (!this.has(key)) {\r\n      const value = this._factory(key);\r\n      this.set(key, value);\r\n      return value;\r\n    }\r\n    // If the key is present we must have a value of type V.\r\n    return (super.get(key): any);\r\n  }\r\n}\r\n\r\nexport class DefaultWeakMap<K: {}, V> extends WeakMap<K, V> {\r\n  _factory: K => V;\r\n\r\n  constructor(factory: K => V, iterable: ?Iterable<[K, V]>) {\r\n    super(iterable);\r\n    this._factory = factory;\r\n  }\r\n\r\n  get(key: K): V {\r\n    if (!this.has(key)) {\r\n      const value = this._factory(key);\r\n      this.set(key, value);\r\n      return value;\r\n    }\r\n    // If the key is present we must have a value of type V.\r\n    return (super.get(key): any);\r\n  }\r\n}\r\n\r\n/**\r\n * Return the highest ranked item in a list, according to the provided ranking function. A max rank\r\n * may optionally be provided so the whole list doesn't have to be iterated. Items with ranks of\r\n * zero or less are never returned.\r\n */\r\nexport function findTopRanked<T>(\r\n  items: Iterable<T>,\r\n  ranker: T => number,\r\n  maxRank?: number,\r\n): ?T {\r\n  let maxSeenRank = 0;\r\n  let maxRankedItem;\r\n  for (const item of items) {\r\n    const rank = ranker(item);\r\n    if (rank === maxRank) {\r\n      return item;\r\n    }\r\n    if (rank > 0 && rank > maxSeenRank) {\r\n      maxSeenRank = rank;\r\n      maxRankedItem = item;\r\n    }\r\n  }\r\n  return maxRankedItem;\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\n\r\nexport default function debounce<\r\n  T,\r\n  TArgs: Array<T>,\r\n  TReturn,\r\n  TFunc: (...TArgs) => TReturn, // eslint-disable-line space-before-function-paren\r\n>(\r\n  func: TFunc,\r\n  wait: number,\r\n  immediate?: boolean = false,\r\n): {\r\n  (...TArgs): TReturn | void,\r\n  dispose(): void,\r\n} {\r\n  // Taken from: https://github.com/jashkenas/underscore/blob/b10b2e6d72/underscore.js#L815.\r\n  let timeout: ?TimeoutID;\r\n  let args: ?TArgs;\r\n  let context: any;\r\n  let timestamp = 0;\r\n  let result: TReturn | void;\r\n\r\n  const later = function() {\r\n    const last = Date.now() - timestamp;\r\n\r\n    if (last < wait && last >= 0) {\r\n      timeout = setTimeout(later, wait - last);\r\n    } else {\r\n      timeout = null;\r\n      if (!immediate) {\r\n        invariant(args != null);\r\n        result = func.apply(context, args);\r\n        if (!timeout) {\r\n          context = args = null;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const debounced = function(...args_: TArgs): TReturn | void {\r\n    context = this;\r\n    args = args_;\r\n    timestamp = Date.now();\r\n    const callNow = immediate && !timeout;\r\n    if (!timeout) {\r\n      timeout = setTimeout(later, wait);\r\n    }\r\n    if (callNow) {\r\n      result = func.apply(context, args);\r\n      context = args = null;\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  debounced.dispose = () => {\r\n    if (timeout) {\r\n      clearTimeout(timeout);\r\n      timeout = context = args = null;\r\n    }\r\n  };\r\n\r\n  return debounced;\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\n/* global requestAnimationFrame, cancelAnimationFrame */\r\n\r\n// NOTE: Custom operators that require arguments should be written as higher-order functions. That\r\n// is, they should accept the arguments and return a function that accepts only an observable. This\r\n// allows a nice ergonomic way of using them with '.let()' (or a potential future pipe operator):\r\n//\r\n//     const makeExciting = (excitementLevel: number = 1) =>\r\n//       (source: Observable<string>) =>\r\n//         source.map(x => x + '!'.repeat(excitementLevel));\r\n//\r\n//     Observable.of('hey', 'everybody')\r\n//       .let(makeExciting())\r\n//       .subscribe(x => console.log(x));\r\n\r\nimport type {AbortSignal} from './AbortController';\r\n\r\nimport UniversalDisposable from './UniversalDisposable';\r\nimport invariant from 'assert';\r\n// Note: DOMException is usable in Chrome but not in Node.\r\nimport DOMException from 'domexception';\r\nimport {Observable, ReplaySubject, Subject, Subscription} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\nimport AbortController from './AbortController';\r\nimport {setDifference} from './collection';\r\nimport debounce from './debounce';\r\n\r\n/**\r\n * Splits a stream of strings on newlines.\r\n * Includes the newlines in the resulting stream (if includeNewlines is true).\r\n * Sends any non-newline terminated data before closing.\r\n * Does not ensure a trailing newline.\r\n */\r\nexport function splitStream(\r\n  input: Observable<string>,\r\n  includeNewlines?: boolean = true,\r\n): Observable<string> {\r\n  return Observable.create(observer => {\r\n    let current: string = '';\r\n\r\n    function onEnd() {\r\n      if (current !== '') {\r\n        observer.next(current);\r\n        current = '';\r\n      }\r\n    }\r\n\r\n    return input.subscribe(\r\n      value => {\r\n        const lines = value.split('\\n');\r\n        lines[0] = current + lines[0];\r\n        current = lines.pop();\r\n        if (includeNewlines) {\r\n          lines.forEach(line => observer.next(line + '\\n'));\r\n        } else {\r\n          lines.forEach(line => observer.next(line));\r\n        }\r\n      },\r\n      error => {\r\n        onEnd();\r\n        observer.error(error);\r\n      },\r\n      () => {\r\n        onEnd();\r\n        observer.complete();\r\n      },\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Buffers until the predicate matches an element, then opens a new buffer.\r\n *\r\n * @param stream - The observable to buffer\r\n * @param predicate - A function that will be called every time an element is emitted from the\r\n *     source. The predicate is passed the current element as well as the buffer at that point\r\n *     (which includes the element). IMPORTANT: DO NOT MUTATE THE BUFFER. It returns a boolean\r\n *     specifying whether to complete the buffer (and begin a new one).\r\n */\r\nexport function bufferUntil<T>(\r\n  condition: (item: T, buffer: Array<T>) => boolean,\r\n): (Observable<T>) => Observable<Array<T>> {\r\n  return (stream: Observable<T>) =>\r\n    Observable.create(observer => {\r\n      let buffer = null;\r\n      const flush = () => {\r\n        if (buffer != null) {\r\n          observer.next(buffer);\r\n          buffer = null;\r\n        }\r\n      };\r\n      return stream.subscribe(\r\n        x => {\r\n          if (buffer == null) {\r\n            buffer = [];\r\n          }\r\n          buffer.push(x);\r\n          if (condition(x, buffer)) {\r\n            flush();\r\n          }\r\n        },\r\n        err => {\r\n          flush();\r\n          observer.error(err);\r\n        },\r\n        () => {\r\n          flush();\r\n          observer.complete();\r\n        },\r\n      );\r\n    });\r\n}\r\n\r\n/**\r\n * Caches the latest element as long as there are subscribers. This is useful so that if consumers\r\n * unsubscribe and then subscribe much later, they do not get an ancient cached value.\r\n *\r\n * This is intended to be used with cold Observables. If you have a hot Observable, `cache(1)` will\r\n * be just fine because the hot Observable will continue producing values even when there are no\r\n * subscribers, so you can be assured that the cached values are up-to-date.\r\n */\r\nexport function cacheWhileSubscribed<T>(input: Observable<T>): Observable<T> {\r\n  return input.multicast(() => new ReplaySubject(1)).refCount();\r\n}\r\n\r\ntype Diff<T> = {\r\n  added: Set<T>,\r\n  removed: Set<T>,\r\n};\r\n\r\n/**\r\n * Given a stream of sets, return a stream of diffs.\r\n * **IMPORTANT:** These sets are assumed to be immutable by convention. Don't mutate them!\r\n */\r\nexport function diffSets<T>(\r\n  hash?: (v: T) => any,\r\n): (Observable<Set<T>>) => Observable<Diff<T>> {\r\n  return (sets: Observable<Set<T>>) =>\r\n    Observable.concat(\r\n      Observable.of(new Set()), // Always start with no items with an empty set\r\n      sets,\r\n    )\r\n      .pairwise()\r\n      .map(([previous, next]) => ({\r\n        added: setDifference(next, previous, hash),\r\n        removed: setDifference(previous, next, hash),\r\n      }))\r\n      .filter(diff => diff.added.size > 0 || diff.removed.size > 0);\r\n}\r\n\r\n/**\r\n * Give a stream of diffs, perform an action for each added item and dispose of the returned\r\n * disposable when the item is removed.\r\n */\r\nexport function reconcileSetDiffs<T>(\r\n  diffs: Observable<Diff<T>>,\r\n  addAction: (addedItem: T) => IDisposable,\r\n  hash_?: (v: T) => any,\r\n): IDisposable {\r\n  const hash = hash_ || (x => x);\r\n  const itemsToDisposables = new Map();\r\n  const disposeItem = item => {\r\n    const disposable = itemsToDisposables.get(hash(item));\r\n    invariant(disposable != null);\r\n    disposable.dispose();\r\n    itemsToDisposables.delete(item);\r\n  };\r\n  const disposeAll = () => {\r\n    itemsToDisposables.forEach(disposable => {\r\n      disposable.dispose();\r\n    });\r\n    itemsToDisposables.clear();\r\n  };\r\n\r\n  return new UniversalDisposable(\r\n    diffs.subscribe(diff => {\r\n      // For every item that got added, perform the add action.\r\n      diff.added.forEach(item => {\r\n        itemsToDisposables.set(hash(item), addAction(item));\r\n      });\r\n\r\n      // \"Undo\" the add action for each item that got removed.\r\n      diff.removed.forEach(disposeItem);\r\n    }),\r\n    disposeAll,\r\n  );\r\n}\r\n\r\n/**\r\n * Given a stream of sets, perform a side-effect whenever an item is added (i.e. is present in a\r\n * set but wasn't in the previous set in the stream), and a corresponding cleanup when it's removed.\r\n * **IMPORTANT:** These sets are assumed to be immutable by convention. Don't mutate them!\r\n *\r\n * Example:\r\n *\r\n *    const dogs = Observable.of(\r\n *      new Set([{name: 'Winston', id: 1}, {name: 'Penelope', id: 2}]),\r\n *      new Set([{name: 'Winston', id: 1}]),\r\n *    );\r\n *    const disposable = reconcileSets(\r\n *      dogs,\r\n *      dog => {\r\n *        const notification = atom.notifications.addSuccess(\r\n *          `${dog.name} was added!`,\r\n *          {dismissable: true},\r\n *        );\r\n *        return new Disposable(() => { notification.dismiss(); });\r\n *      },\r\n *      dog => dog.id,\r\n *    );\r\n *\r\n * The above code will first add notifications saying \"Winston was added!\" and \"Penelope was\r\n * added!\", then dismiss the \"Penelope\" notification. Since the Winston object is in the final set\r\n * of the dogs observable, his notification will remain until `disposable.dispose()` is called, at\r\n * which point the cleanup for all remaining items will be performed.\r\n */\r\nexport function reconcileSets<T>(\r\n  sets: Observable<Set<T>>,\r\n  addAction: (addedItem: T) => IDisposable,\r\n  hash?: (v: T) => any,\r\n): IDisposable {\r\n  const diffs = sets.let(diffSets(hash));\r\n  return reconcileSetDiffs(diffs, addAction, hash);\r\n}\r\n\r\nexport function toggle<T>(\r\n  toggler: Observable<boolean>,\r\n): (Observable<T>) => Observable<T> {\r\n  return (source: Observable<T>) =>\r\n    toggler\r\n      .distinctUntilChanged()\r\n      .switchMap(enabled => (enabled ? source : Observable.empty()));\r\n}\r\n\r\nexport function compact<T>(source: Observable<?T>): Observable<T> {\r\n  // Flow does not understand the semantics of `filter`\r\n  return (source.filter(x => x != null): any);\r\n}\r\n\r\n/**\r\n * Like `takeWhile`, but includes the first item that doesn't match the predicate.\r\n */\r\nexport function takeWhileInclusive<T>(\r\n  predicate: (value: T) => boolean,\r\n): (Observable<T>) => Observable<T> {\r\n  return (source: Observable<T>) =>\r\n    Observable.create(observer =>\r\n      source.subscribe(\r\n        x => {\r\n          observer.next(x);\r\n          if (!predicate(x)) {\r\n            observer.complete();\r\n          }\r\n        },\r\n        err => {\r\n          observer.error(err);\r\n        },\r\n        () => {\r\n          observer.complete();\r\n        },\r\n      ),\r\n    );\r\n}\r\n\r\n// Concatenate the latest values from each input observable into one big list.\r\n// Observables who have not emitted a value yet are treated as empty.\r\nexport function concatLatest<T>(\r\n  ...observables: Array<Observable<Array<T>>>\r\n): Observable<Array<T>> {\r\n  // First, tag all input observables with their index.\r\n  // Flow errors with ambiguity without the explicit annotation.\r\n  const tagged: Array<Observable<[Array<T>, number]>> = observables.map(\r\n    (observable, index) => observable.map(list => [list, index]),\r\n  );\r\n  return Observable.merge(...tagged)\r\n    .scan((accumulator, [list, index]) => {\r\n      accumulator[index] = list;\r\n      return accumulator;\r\n    }, observables.map(x => []))\r\n    .map(accumulator => [].concat(...accumulator));\r\n}\r\n\r\n// Use a sentinel so we can distinguish between when `null` is emitted and when\r\n// nothing is.\r\nconst NONE = {};\r\n\r\ntype ThrottleOptions = {|\r\n  leading?: boolean,\r\n|};\r\n\r\nexport function throttle<T>(\r\n  delay:\r\n    | number\r\n    | ((value: T) => Observable<any> | Promise<any>)\r\n    | Observable<any>\r\n    | Promise<any>,\r\n  options?: ThrottleOptions = {leading: true},\r\n): (observable: Observable<T>) => Observable<T> {\r\n  let getDelay: (value: T) => Observable<any> | Promise<any>;\r\n  switch (typeof delay) {\r\n    case 'number':\r\n      getDelay = () => Observable.timer(delay);\r\n      break;\r\n    case 'function':\r\n      getDelay = delay;\r\n      break;\r\n    case 'object':\r\n      getDelay = () => delay;\r\n      break;\r\n    default:\r\n      throw new Error(`Invalid delay: ${delay}`);\r\n  }\r\n\r\n  return function doThrottle(source: Observable<T>): Observable<T> {\r\n    return Observable.create(observer => {\r\n      const {leading = true} = options;\r\n      const timerStarts = new Subject();\r\n      let latestValue = NONE;\r\n      let latestValueIsLeading = false;\r\n      let shouldIgnore = false;\r\n\r\n      const checkShouldNext = () => {\r\n        if (!shouldIgnore && latestValue !== NONE) {\r\n          // At this point, latestValue must be of type T\r\n          latestValue = ((latestValue: any): T);\r\n\r\n          const valueToDispatch = latestValue;\r\n          shouldIgnore = true;\r\n\r\n          if (leading || !latestValueIsLeading) {\r\n            latestValue = NONE;\r\n            observer.next(valueToDispatch);\r\n          }\r\n          timerStarts.next(valueToDispatch);\r\n        }\r\n      };\r\n\r\n      const sub = new Subscription();\r\n      sub.add(\r\n        timerStarts\r\n          .switchMap(x => {\r\n            const timer = getDelay(x);\r\n            if (timer instanceof Observable) {\r\n              return timer.take(1);\r\n            } else {\r\n              return timer;\r\n            }\r\n          })\r\n          .subscribe(() => {\r\n            shouldIgnore = false;\r\n            latestValueIsLeading = false;\r\n            checkShouldNext();\r\n          }),\r\n      );\r\n      sub.add(\r\n        source.subscribe({\r\n          next: x => {\r\n            latestValue = x;\r\n            latestValueIsLeading = true;\r\n            checkShouldNext();\r\n          },\r\n          error: err => {\r\n            observer.error(err);\r\n          },\r\n          complete: () => {\r\n            // Ensure we don't hold a reference to the last value.\r\n            latestValue = NONE;\r\n            observer.complete();\r\n          },\r\n        }),\r\n      );\r\n\r\n      return sub;\r\n    });\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a new function which takes an `observable` and returns\r\n * `observable.switchMap(project)`, except that it completes\r\n * when the outer observable completes.\r\n *\r\n * Example:\r\n *\r\n *   Observable.of(1)\r\n *     .let(completingSwitchMap(x => Observable.never()))\r\n *\r\n * ends up returning an Observable that completes immediately.\r\n * With a regular switchMap, this would never terminate.\r\n */\r\nexport function completingSwitchMap<T, U>(\r\n  project: (input: T, index: number) => rxjs$ObservableInput<U>,\r\n): (Observable<T>) => Observable<U> {\r\n  // An alternative implementation is to materialize the input observable,\r\n  // but this avoids the creation of extra notifier objects.\r\n  const completedSymbol = Symbol('completed');\r\n  return (observable: Observable<T>) =>\r\n    Observable.concat(\r\n      observable,\r\n      Observable.of((completedSymbol: any)),\r\n    ).switchMap((input, index) => {\r\n      if (input === completedSymbol) {\r\n        return Observable.empty();\r\n      }\r\n      return project(input, index);\r\n    });\r\n}\r\n\r\n/**\r\n * Returns a new observable consisting of the merged values from the passed\r\n * observables and completes when the first inner observable completes.\r\n */\r\nexport function mergeUntilAnyComplete<T>(\r\n  ...observables: Array<Observable<T>>\r\n): Observable<T> {\r\n  const notifications = Observable.merge(\r\n    ...observables.map(o => o.materialize()),\r\n  );\r\n  // $FlowFixMe add dematerialize to rxjs Flow types\r\n  return notifications.dematerialize();\r\n}\r\n\r\n/**\r\n * RxJS's debounceTime is actually fairly inefficient:\r\n * on each event, it always clears its interval and [creates a new one][1].\r\n * Until this is fixed, this uses our debounce implementation which\r\n * reuses a timeout and just sets a timestamp when possible.\r\n *\r\n * This may seem like a micro-optimization but we often use debounces\r\n * for very hot events, like keypresses. Exceeding the frame budget can easily lead\r\n * to increased key latency!\r\n *\r\n * [1]: https://github.com/ReactiveX/rxjs/blob/master/src/operators/debounceTime.ts#L106\r\n */\r\nexport function fastDebounce<T>(\r\n  delay: number,\r\n): (Observable<T>) => Observable<T> {\r\n  return (observable: Observable<T>) =>\r\n    Observable.create(observer => {\r\n      const debouncedNext = debounce((x: T) => observer.next(x), delay);\r\n      const subscription = observable.subscribe(\r\n        debouncedNext,\r\n        observer.error.bind(observer),\r\n        observer.complete.bind(observer),\r\n      );\r\n      return new UniversalDisposable(subscription, debouncedNext);\r\n    });\r\n}\r\n\r\nexport const microtask = Observable.create(observer => {\r\n  process.nextTick(() => {\r\n    observer.next();\r\n    observer.complete();\r\n  });\r\n});\r\n\r\nexport const macrotask = Observable.create(observer => {\r\n  const timerId = setImmediate(() => {\r\n    observer.next();\r\n    observer.complete();\r\n  });\r\n  return () => {\r\n    clearImmediate(timerId);\r\n  };\r\n});\r\n\r\nexport const nextAnimationFrame = Observable.create(observer => {\r\n  if (typeof requestAnimationFrame === 'undefined') {\r\n    throw new Error('This util can only be used in Atom');\r\n  }\r\n  const id = requestAnimationFrame(() => {\r\n    observer.next();\r\n    observer.complete();\r\n  });\r\n  return () => {\r\n    cancelAnimationFrame(id);\r\n  };\r\n});\r\n\r\n/**\r\n * Creates an Observable around an abortable promise.\r\n * Unsubscriptions are forwarded to the AbortController as an `abort()`.\r\n * Example usage (with an abortable fetch):\r\n *\r\n *   fromPromise(signal => fetch(url, {...options, signal}))\r\n *     .switchMap(....)\r\n *\r\n * Note that this can take a normal `() => Promise<T>` too\r\n * (in which case this acts as just a plain `Observable.defer`).\r\n */\r\nexport function fromAbortablePromise<T>(\r\n  func: (signal: AbortSignal) => Promise<T>,\r\n): Observable<T> {\r\n  return Observable.create(observer => {\r\n    let completed = false;\r\n    const abortController = new AbortController();\r\n    func(abortController.signal).then(\r\n      value => {\r\n        completed = true;\r\n        observer.next(value);\r\n        observer.complete();\r\n      },\r\n      error => {\r\n        completed = true;\r\n        observer.error(error);\r\n      },\r\n    );\r\n    return () => {\r\n      if (!completed) {\r\n        abortController.abort();\r\n        // If the promise adheres to the spec, it should throw.\r\n        // The error will be captured above but go into the void.\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Converts an observable + AbortSignal into a cancellable Promise,\r\n * which rejects with an AbortError DOMException on abort.\r\n * Useful when writing the internals of a cancellable promise.\r\n *\r\n * Usage:\r\n *\r\n *   function abortableFunction(arg1: blah, options?: {signal?: AbortSignal}): Promise {\r\n *     return toPromise(\r\n *       observableFunction(arg1, options),\r\n *       options && options.signal,\r\n *     );\r\n *   }\r\n *\r\n * Could eventually be replaced by Observable.first if\r\n * https://github.com/whatwg/dom/issues/544 goes through.\r\n *\r\n * It's currently unclear if this should be usable with let/pipe:\r\n * https://github.com/ReactiveX/rxjs/issues/3445\r\n */\r\nexport function toAbortablePromise<T>(\r\n  observable: Observable<T>,\r\n  signal?: ?AbortSignal,\r\n): Promise<T> {\r\n  if (signal == null) {\r\n    return observable.toPromise();\r\n  }\r\n  if (signal.aborted) {\r\n    return Promise.reject(DOMException('Aborted', 'AbortError'));\r\n  }\r\n  return observable\r\n    .race(\r\n      Observable.fromEvent(signal, 'abort').map(() => {\r\n        throw new DOMException('Aborted', 'AbortError');\r\n      }),\r\n    )\r\n    .toPromise();\r\n}\r\n\r\n/**\r\n * When using Observables with AbortSignals, be sure to use this -\r\n * it's really easy to miss the case when the signal is already aborted!\r\n * Recommended to use this with let/pipe:\r\n *\r\n *   myObservable\r\n *     .let(takeUntilAbort(signal))\r\n */\r\nexport function takeUntilAbort<T>(\r\n  signal: AbortSignal,\r\n): (Observable<T>) => Observable<T> {\r\n  return observable =>\r\n    Observable.defer(() => {\r\n      if (signal.aborted) {\r\n        return Observable.empty();\r\n      }\r\n      return observable.takeUntil(Observable.fromEvent(signal, 'abort'));\r\n    });\r\n}\r\n\r\n// Executes tasks. Ensures that at most one task is running at a time.\r\n// This class is handy for expensive tasks like processes, provided\r\n// you never want the result of a previous task after a new task has started.\r\nexport class SingletonExecutor<T> {\r\n  _abortController: ?AbortController = null;\r\n\r\n  // Executes(subscribes to) the task.\r\n  // Will terminate(unsubscribe) to any previously executing task.\r\n  // Subsequent executes() will terminate this task if called before\r\n  // this task completes.\r\n  async execute(createTask: Observable<T>): Promise<T> {\r\n    // Kill any previously running processes\r\n    this.cancel();\r\n\r\n    // Start a new process\r\n    const controller = new AbortController();\r\n    this._abortController = controller;\r\n\r\n    // Wait for the process to complete or be canceled ...\r\n    try {\r\n      return await toAbortablePromise(createTask, controller.signal);\r\n    } finally {\r\n      // ... and always clean up if we haven't been canceled already.\r\n      if (controller === this._abortController) {\r\n        this._abortController = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  isExecuting(): boolean {\r\n    return this._abortController != null;\r\n  }\r\n\r\n  // Cancels any currently executing tasks.\r\n  cancel(): void {\r\n    if (this._abortController != null) {\r\n      this._abortController.abort();\r\n      this._abortController = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Repeatedly subscribe to an observable every `delay` milliseconds, waiting for the observable to\r\n * complete each time. This is preferable to, say, `Observable.interval(d).switchMap(() => source)`\r\n * because, in the case that `source` takes longer than `d` milliseconds to produce a value, that\r\n * formulation will never produce a value (while continuing to incur the overhead of subscribing to\r\n * source).\r\n *\r\n * Example:\r\n *\r\n *    // Ask what time it is every second until it's Friday.\r\n *    runCommand('date')\r\n *      .let(poll(1000))\r\n *      .filter(output => output.startsWith('Fri'))\r\n *      .take(1)\r\n *      .subscribe(() => {\r\n *        console.log(\"IT'S FRIDAY!!\")\r\n *      });\r\n *\r\n */\r\nexport function poll<T>(delay: number): (Observable<T>) => Observable<T> {\r\n  return (source: Observable<T>) =>\r\n    Observable.defer(() => {\r\n      const delays = new Subject();\r\n      return delays\r\n        .switchMap(n => Observable.timer(n))\r\n        .merge(Observable.of(null))\r\n        .switchMap(() => {\r\n          const subscribedAt = Date.now();\r\n          return source.do({\r\n            complete: () => {\r\n              const timeElapsed = Date.now() - subscribedAt;\r\n              delays.next(Math.max(0, delay - timeElapsed));\r\n            },\r\n          });\r\n        });\r\n    });\r\n}\r\n","import type { TextEditor, TextChange, Disposable } from \"atom\"\n// TODO add to @types/atom\ntype AggregatedTextChange = {\n  changes: Array<TextChange>\n}\nimport type { TextEdit } from \"@atom-ide-community/nuclide-commons-atom/text-edit\"\nimport type { BusySignalService } from \"atom-ide-base\"\nimport type {\n  FileCodeFormatProvider,\n  OnSaveCodeFormatProvider,\n  OnTypeCodeFormatProvider,\n  RangeCodeFormatProvider,\n} from \"./types\"\n\nimport nullthrows from \"nullthrows\"\nimport { registerOnWillSave } from \"@atom-ide-community/nuclide-commons-atom/FileEventHandlers\"\nimport { getFormatOnSave, getFormatOnType } from \"./config\"\nimport { Range } from \"atom\"\nimport { getLogger } from \"log4js\"\nimport ProviderRegistry from \"@atom-ide-community/nuclide-commons-atom/ProviderRegistry\"\nimport { applyTextEditsToBuffer } from \"@atom-ide-community/nuclide-commons-atom/text-edit\"\nimport { observeEditorDestroy } from \"@atom-ide-community/nuclide-commons-atom/text-editor\"\nimport { observableFromSubscribeFunction } from \"@atom-ide-community/nuclide-commons/event\"\nimport nuclideUri from \"@atom-ide-community/nuclide-commons/nuclideUri\"\nimport { completingSwitchMap, microtask } from \"@atom-ide-community/nuclide-commons/observable\"\nimport UniversalDisposable from \"@atom-ide-community/nuclide-commons/UniversalDisposable\"\nimport { Observable } from \"rxjs-compat/bundles/rxjs-compat.umd.min.js\"\nimport type { Subscription } from \"rxjs\"\n\n// Save events are critical, so don't allow providers to block them.\nexport const SAVE_TIMEOUT = 2500\n\ntype FormatEvent =\n  | {\n      type: \"command\" | \"save\" | \"new-save\"\n      editor: TextEditor\n    }\n  | {\n      type: \"type\"\n      editor: TextEditor\n      edit: AggregatedTextChange\n    }\n\nexport default class CodeFormatManager {\n  _subscriptions: UniversalDisposable\n  _rangeProviders: ProviderRegistry<RangeCodeFormatProvider>\n  _fileProviders: ProviderRegistry<FileCodeFormatProvider>\n  _onTypeProviders: ProviderRegistry<OnTypeCodeFormatProvider>\n  _onSaveProviders: ProviderRegistry<OnSaveCodeFormatProvider>\n  _busySignalService: BusySignalService | undefined | null\n\n  constructor() {\n    this._subscriptions = new UniversalDisposable(\n      this._subscribeToEvents(),\n      registerOnWillSave(this._onWillSaveProvider())\n    )\n    this._rangeProviders = new ProviderRegistry()\n    this._fileProviders = new ProviderRegistry()\n    this._onTypeProviders = new ProviderRegistry()\n    this._onSaveProviders = new ProviderRegistry()\n  }\n\n  /**\n   * Subscribe to all formatting events (commands, saves, edits) and dispatch formatters as necessary. By handling all\n   * events in a central location, we ensure that no buffer runs into race conditions with simultaneous formatters.\n   */\n  _subscribeToEvents(): Subscription {\n    // Events from the explicit Atom command.\n    const commandEvents = observableFromSubscribeFunction((callback) =>\n      atom.commands.add(\"atom-text-editor\", \"code-format:format-code\", callback)\n    ).switchMap(() => {\n      const editor = atom.workspace.getActiveTextEditor()\n      if (!editor) {\n        return Observable.empty()\n      }\n      return Observable.of({ type: \"command\", editor })\n    })\n\n    // Events from editor actions (saving, typing).\n    const editorEvents = observableFromSubscribeFunction((cb) => atom.workspace.observeTextEditors(cb)).mergeMap(\n      (editor) => _getEditorEventStream(editor)\n    )\n\n    return (\n      Observable.merge(commandEvents, editorEvents)\n        // Group events by buffer to prevent simultaneous formatting operations.\n        .groupBy(\n          (event) => event.editor.getBuffer(),\n          (event) => event,\n          (grouped) => observableFromSubscribeFunction((callback) => grouped.key.onDidDestroy(callback))\n        )\n        .mergeMap((events) =>\n          // Make sure we halt everything when the editor gets destroyed.\n          events.let(completingSwitchMap((event) => this._handleEvent(event)))\n        )\n        .subscribe()\n    )\n  }\n\n  _handleEvent(event: FormatEvent): Observable<unknown> {\n    const { editor } = event\n    switch (event.type) {\n      case \"command\":\n        return this._formatCodeInTextEditor(editor)\n          .do((edits) => {\n            applyTextEditsToBuffer(editor.getBuffer(), edits)\n          })\n          .map((result) => {\n            if (!result) {\n              throw new Error(\"No code formatting providers found!\")\n            }\n          })\n          .catch((err) => {\n            atom.notifications.addError(`Failed to format code: ${err.message}`, {\n              detail: err.detail,\n            })\n            return Observable.empty()\n          })\n      case \"type\":\n        return this._formatCodeOnTypeInTextEditor(editor, event.edit).catch((err) => {\n          getLogger(\"code-format\").warn(\"Failed to format code on type:\", err)\n          return Observable.empty()\n        })\n      default:\n        return Observable.throw(`unknown event type ${event.type}`)\n    }\n  }\n\n  // Return the text edits used to format code in the editor specified.\n  _formatCodeInTextEditor(editor: TextEditor, range?: Range): Observable<Array<TextEdit>> {\n    return Observable.defer(() => {\n      const buffer = editor.getBuffer()\n      const selectionRange = range || editor.getSelectedBufferRange()\n      const { start: selectionStart, end: selectionEnd } = selectionRange\n      let formatRange: Range\n      if (selectionRange.isEmpty()) {\n        // If no selection is done, then, the whole file is wanted to be formatted.\n        formatRange = buffer.getRange()\n      } else {\n        // Format selections should start at the beginning of the line,\n        // and include the last selected line end.\n        // (If the user has already selected complete rows, then depending on how they\n        // did it, their caret might be either (1) at the end of their last selected line\n        // or (2) at the first column of the line AFTER their selection. In both cases\n        // we snap the formatRange to end at the first column of the line after their\n        // selection.)\n        formatRange = new Range(\n          [selectionStart.row, 0],\n          selectionEnd.column === 0 ? selectionEnd : [selectionEnd.row + 1, 0]\n        )\n      }\n      const rangeProviders = [...this._rangeProviders.getAllProvidersForEditor(editor)]\n      const fileProviders = [...this._fileProviders.getAllProvidersForEditor(editor)]\n      const contents = editor.getText()\n      const rangeEdits = Observable.defer(() =>\n        this._reportBusy(editor, Promise.all(rangeProviders.map((p) => p.formatCode(editor, formatRange))))\n      ).switchMap((allEdits) => {\n        const firstNonEmpty = allEdits.find((edits) => edits.length > 0)\n        if (firstNonEmpty == null) {\n          return Observable.empty()\n        } else {\n          return Observable.of(firstNonEmpty)\n        }\n      })\n      const fileEdits = Observable.defer(() =>\n        this._reportBusy(editor, Promise.all(fileProviders.map((p) => p.formatEntireFile(editor, formatRange))))\n      )\n        .switchMap((allResults) => {\n          const firstNonNull = allResults.find((result) => result != null)\n          if (firstNonNull == null) {\n            return Observable.empty()\n          } else {\n            return Observable.of(firstNonNull)\n          }\n        })\n        .map(({ formatted }) => {\n          return [\n            {\n              oldRange: editor.getBuffer().getRange(),\n              newText: formatted,\n              oldText: contents,\n            },\n          ]\n        })\n      // When formatting the entire file, prefer file-based providers.\n      const preferFileEdits = formatRange.isEqual(buffer.getRange())\n      const edits = preferFileEdits ? fileEdits.concat(rangeEdits) : rangeEdits.concat(fileEdits)\n      return edits.first(Boolean, [])\n    })\n  }\n\n  _formatCodeOnTypeInTextEditor(\n    editor: TextEditor,\n    aggregatedEvent: AggregatedTextChange\n  ): Observable<Array<TextEdit>> {\n    return Observable.defer(() => {\n      // Don't try to format changes with multiple cursors.\n      if (aggregatedEvent.changes.length !== 1) {\n        return Observable.empty()\n      }\n      const event = aggregatedEvent.changes[0]\n      // This also ensures the non-emptiness of event.newText for below.\n      if (!shouldFormatOnType(event) || !getFormatOnType()) {\n        return Observable.empty()\n      }\n      // In the case of bracket-matching, we use the last character because that's\n      // the character that will usually cause a reformat (i.e. `}` instead of `{`).\n      const character = event.newText[event.newText.length - 1]\n\n      const providers = [...this._onTypeProviders.getAllProvidersForEditor(editor)]\n      if (providers.length === 0) {\n        return Observable.empty()\n      }\n\n      const contents = editor.getText()\n      const cursorPosition = editor.getCursorBufferPosition().copy()\n\n      // The bracket-matching package basically overwrites\n      //\n      //     editor.insertText('{');\n      //\n      // with\n      //\n      //     editor.insertText('{}');\n      //     cursor.moveLeft();\n      //\n      // We want to wait until the cursor has actually moved before we issue a\n      // format request, so that we format at the right position (and potentially\n      // also let any other event handlers have their go).\n      return microtask\n        .switchMap(() =>\n          Promise.all(providers.map((p) => p.formatAtPosition(editor, editor.getCursorBufferPosition(), character)))\n        )\n        .switchMap((allEdits) => {\n          const firstNonEmptyIndex = allEdits.findIndex((edits) => edits.length > 0)\n          if (firstNonEmptyIndex === -1) {\n            return Observable.empty()\n          } else {\n            return Observable.of({\n              edits: nullthrows(allEdits[firstNonEmptyIndex]),\n              provider: providers[firstNonEmptyIndex],\n            })\n          }\n        })\n        .do(({ edits, provider }) => {\n          if (edits.length === 0) {\n            return\n          }\n          _checkContentsAreSame(contents, editor.getText())\n          // Note that this modification is not in a transaction, so it applies as a\n          // separate editing event than the character typing. This means that you\n          // can undo just the formatting by attempting to undo once, and then undo\n          // your actual code by undoing again.\n          if (!applyTextEditsToBuffer(editor.getBuffer(), edits)) {\n            throw new Error(\"Could not apply edits to text buffer.\")\n          }\n\n          if (provider.keepCursorPosition) {\n            editor.setCursorBufferPosition(cursorPosition)\n          }\n        })\n        .map(({ edits }) => edits)\n    })\n  }\n\n  _onWillSaveProvider() {\n    return {\n      priority: 0,\n      timeout: SAVE_TIMEOUT,\n      callback: this._formatCodeOnSaveInTextEditor.bind(this),\n    }\n  }\n\n  _formatCodeOnSaveInTextEditor(editor: TextEditor): Observable<TextEdit> {\n    const saveProviders = [...this._onSaveProviders.getAllProvidersForEditor(editor)]\n    if (saveProviders.length > 0) {\n      return Observable.defer(() =>\n        this._reportBusy(editor, Promise.all(saveProviders.map((p) => p.formatOnSave(editor))), false)\n      )\n        .switchMap((allEdits) => {\n          const firstNonEmpty = allEdits.find((edits) => edits.length > 0)\n          if (firstNonEmpty == null) {\n            return Observable.empty()\n          } else {\n            return Observable.of(firstNonEmpty)\n          }\n        })\n        .flatMap((edits) => Observable.of(...edits))\n    } else if (getFormatOnSave(editor)) {\n      return this._formatCodeInTextEditor(editor, editor.getBuffer().getRange()).flatMap((edits) =>\n        Observable.of(...edits)\n      )\n    }\n    return Observable.empty()\n  }\n\n  _reportBusy<T>(editor: TextEditor, promise: Promise<T>, revealTooltip: boolean = true): Promise<T> {\n    const busySignalService = this._busySignalService\n    if (busySignalService != null) {\n      const path = editor.getPath()\n      const displayPath = path != null ? nuclideUri.basename(path) : \"<untitled>\"\n      return busySignalService.reportBusyWhile(`Formatting code in ${displayPath}`, () => promise, { revealTooltip })\n    }\n    return promise\n  }\n\n  addRangeProvider(provider: RangeCodeFormatProvider): Disposable {\n    return this._rangeProviders.addProvider(provider)\n  }\n\n  addFileProvider(provider: FileCodeFormatProvider): Disposable {\n    return this._fileProviders.addProvider(provider)\n  }\n\n  addOnTypeProvider(provider: OnTypeCodeFormatProvider): Disposable {\n    return this._onTypeProviders.addProvider(provider)\n  }\n\n  addOnSaveProvider(provider: OnSaveCodeFormatProvider): Disposable {\n    return this._onSaveProviders.addProvider(provider)\n  }\n\n  consumeBusySignal(busySignalService: BusySignalService): Disposable {\n    this._busySignalService = busySignalService\n    return new UniversalDisposable(() => {\n      this._busySignalService = null\n    })\n  }\n\n  dispose() {\n    this._subscriptions.dispose()\n  }\n}\n\nfunction shouldFormatOnType(event: TextChange): boolean {\n  // There's not a direct way to figure out what caused this edit event. There\n  // are three cases that we want to pay attention to:\n  //\n  // 1) The user typed a character.\n  // 2) The user typed a character, and bracket-matching kicked in, causing\n  //    there to be two characters typed.\n  // 3) The user pasted a string.\n  //\n  // We only want to trigger autoformatting in the first two cases. However,\n  // we can only look at what new string was inserted, and not what actually\n  // caused the event, so we just use some heuristics to determine which of\n  // these the event probably was depending on what was typed. This means, for\n  // example, we may issue spurious format requests when the user pastes a\n  // single character, but this is acceptable.\n  if (event.oldText !== \"\") {\n    // We either just deleted something or replaced a selection. For the time\n    // being, we're not going to issue a reformat in that case.\n    return false\n  } else if (event.oldText === \"\" && event.newText === \"\") {\n    // Not sure what happened here; why did we get an event in this case? Bail\n    // for safety.\n    return false\n  } else if (event.newText.length > 1 && !isBracketPair(event.newText)) {\n    return false\n  }\n  return true\n}\n\n/**\n * We can't tell the difference between a paste and the bracket-matcher package inserting an extra bracket, so we just\n * assume that any pair of brackets that bracket-matcher recognizes was a pair matched by the package.\n */\nfunction isBracketPair(typedText: string): boolean {\n  if (atom.packages.getActivePackage(\"bracket-matcher\") == null) {\n    return false\n  }\n  const validBracketPairs: Array<string> = atom.config.get(\"bracket-matcher.autocompleteCharacters\") as any\n  return validBracketPairs.includes(typedText)\n}\n\n// Checks whether contents are same in the buffer post-format, throwing if\n// anything has changed.\nfunction _checkContentsAreSame(before: string, after: string): void {\n  if (before !== after) {\n    throw new Error(\"The file contents were changed before formatting was complete.\")\n  }\n}\n\n/** Returns a stream of all typing and saving operations from the editor. */\nfunction _getEditorEventStream(editor: TextEditor): Observable<FormatEvent> {\n  const changeEvents = observableFromSubscribeFunction((callback) => editor.getBuffer().onDidChangeText(callback))\n\n  // We need to capture when editors are about to be destroyed in order to\n  // interrupt any pending formatting operations. (Otherwise, we may end up\n  // attempting to save a destroyed editor!)\n  const willDestroyEvents = observableFromSubscribeFunction((cb) => atom.workspace.onWillDestroyPaneItem(cb)).filter(\n    (event) => event.item === editor\n  )\n\n  return Observable.merge(changeEvents.map((edit) => ({ type: \"type\", editor, edit }))).takeUntil(\n    Observable.merge(observeEditorDestroy(editor), willDestroyEvents)\n  )\n}\n","import type { TextEditor } from \"atom\"\nimport featureConfig from \"@atom-ide-community/nuclide-commons-atom/feature-config\"\n\nexport function getFormatOnSave(editor: TextEditor): boolean {\n  const formatOnSave = featureConfig.get(\"atom-ide-code-format.formatOnSave\", {\n    scope: editor.getRootScopeDescriptor(),\n  }) as any\n  return formatOnSave == null ? false : formatOnSave\n}\n\nexport function getFormatOnType(): boolean {\n  return featureConfig.getWithDefaults(\"atom-ide-code-format.formatOnType\", false)\n}\n","import type { Disposable } from \"atom\"\nimport type { BusySignalService } from \"atom-ide-base\"\nimport type {\n  RangeCodeFormatProvider,\n  FileCodeFormatProvider,\n  OnTypeCodeFormatProvider,\n  OnSaveCodeFormatProvider,\n} from \"./types\"\n\nimport CodeFormatManager from \"./CodeFormatManager\"\n\nexport { default as config } from \"./config.json\"\n\nlet codeFormatManager: CodeFormatManager\n\nexport function activate() {\n  codeFormatManager = new CodeFormatManager()\n}\n\nexport function consumeRangeProvider(provider: RangeCodeFormatProvider): Disposable {\n  return codeFormatManager.addRangeProvider(provider)\n}\n\nexport function consumeFileProvider(provider: FileCodeFormatProvider): Disposable {\n  return codeFormatManager.addFileProvider(provider)\n}\n\nexport function consumeOnTypeProvider(provider: OnTypeCodeFormatProvider): Disposable {\n  return codeFormatManager.addOnTypeProvider(provider)\n}\n\nexport function consumeOnSaveProvider(provider: OnSaveCodeFormatProvider): Disposable {\n  return codeFormatManager.addOnSaveProvider(provider)\n}\n\nexport function consumeBusySignal(busySignalService: BusySignalService): Disposable {\n  return codeFormatManager.consumeBusySignal(busySignalService)\n}\n\nexport function deactivate() {\n  codeFormatManager.dispose()\n}\n\n// TODO remove\nexport { consumeLegacyProvider } from \"./legacy-provider\"\n","// TODO Remove\n\nimport type { Disposable } from \"atom\"\nimport { consumeRangeProvider, consumeFileProvider, consumeOnSaveProvider, consumeOnTypeProvider } from \"./main\"\nimport type { CodeFormatProvider } from \"./types\"\n\nexport function consumeLegacyProvider(provider: CodeFormatProvider): Disposable {\n  // Legacy providers used `selector` / `inclusionPriority`.\n  // @ts-ignore legacy API compatability.\n  provider.grammarScopes =\n    provider.grammarScopes ||\n    // @ts-ignore\n    (provider.selector != null ? provider.selector.split(\", \") : null)\n  provider.priority =\n    provider.priority != null\n      ? provider.priority\n      : // @ts-ignore\n      provider.inclusionPriority != null\n      ? // @ts-ignore\n        provider.inclusionPriority\n      : 0\n  if (\"formatCode\" in provider) {\n    return consumeRangeProvider(provider)\n  } else if (\"formatEntireFile\" in provider) {\n    return consumeFileProvider(provider)\n  } else if (\"formatAtPosition\" in provider) {\n    return consumeOnTypeProvider(provider)\n  } else if (\"formatOnSave\" in provider) {\n    return consumeOnSaveProvider(provider)\n  }\n  throw new Error(\"Invalid code format provider\")\n}\n"],"names":["Object","defineProperty","nullthrows","value","x","Error","functionOrClass","displayName","name","UniversalDisposable","constructor","teardowns","disposed","Set","length","add","this","i","assertTeardown","addUntilDestroyed","destructible","destroyDisposable","onDidDestroy","dispose","remove","teardown","delete","forEach","unsubscribe","destroy","clear","TypeError","Promise","resolve","process","nextTick","async","promise","milliSeconds","timeoutFn","cleanupFn","timeout","setTimeout","clearTimeout","delay","Date","now","deadline","timeoutPromise","retryFunction","validationFunction","maximumTries","retryIntervalMs","result","tries","lastError","error","sleep","asyncFun","scheduledCall","pendingCall","startAsyncCall","resultPromise","then","callNext","items_","test","thisArg","items","reject","slice","numItems","next","index","item","call","f","args","apply","concat","array","filterFunction","limit","filteredList","asyncLimit","push","obj","keys","filteredObj","key","someFunction","resolved","object","Boolean","fn","ret","err","ms","_lastDispatchedOp","_lastFinishedOp","_latestPromise","_waitResolve","thisOp","status","lastPromise","isRunInProgress","TimedOutError","milliseconds","String","catch","mappingFunction","Array","parallelPromises","parallelLimit","Math","min","runPromise","e","_promise","_state","kind","getPromise","getState","performance","seconds","nanoseconds","hrtime","rawAnalyticsService","isTrackSupported","eventName","values","track","events","subscribe","trackEvent","analyticsService","ob","setApplicationSessionObservable","event","type","data","trackSampled","sampleRate","random","sample_rate","canMeasure","TimingTracker","_eventName","_startTime","_startMark","_values","eventCount","mark","onError","_trackTimingEvent","onCancel","onSuccess","exception","canceled","measure","clearMarks","clearMeasures","duration","round","toString","startTracking","trackTiming","operation","tracker","reason","decorateTrackTiming","decoratedTrackTiming","bind","trackTimingSampled","decorateTrackTimingSampled","decoratedTrackTimingSampled","_providers","addProvider","provider","findIndex","p","priority","splice","removeProvider","indexOf","getProviderForEditor","editor","grammar","getGrammar","scopeName","findProvider","getAllProvidersForEditor","findAllProviders","grammarScopes","emitter","callback","addListener","removeListener","Observable","create","observer","path","atom","workspace","getTextEditors","getPath","buffer","getBuffer","getViewOfEditor","getScrollTop","position","scrollTop","setCursorBufferPosition","autoscroll","setScrollTop","defer","cursor","getCursors","merge","of","getBufferPosition","onDidChangePosition","map","newBufferPosition","take","textEditor","readOnlyExceptions","getElement","setAttribute","removeAttribute","enforcedSoftWrap","setSoftWrapped","onDidChangeSoftWrapped","softWrapped","isDestroyed","TextEditor","textEditorElement","bufferLineNumber","getModel","pixelPositionForBufferPosition","top","getLineHeightInPixels","clientHeight","max","focus","views","getView","file","options","center","moveCursor","activatePane","activateItem","line","column","pending","currentEditor","getActiveTextEditor","paneContainer","paneContainerForItem","activate","goToLocationInEditor","open","initialLine","initialColumn","searchAllPanes","tmp","captureStackTrace","scrollToBufferPosition","goToLocationSubject","Subject","changes","paths","from","checkpoints","all","createCheckpoint","allOkay","reduce","successSoFar","edits","get","applyTextEdits","checkPoint","revertToCheckpoint","applySortedTextEditsToBuffer","sortEdits","sortedEdits","oldRange","end","isGreaterThan","start","editsOverlap","warn","isEqual","getRange","oldText","getText","setTextViaDiff","newText","checkpoint","applyToBuffer","groupChangesSinceCheckpoint","edit","row","lineLength","lineLengthForRow","getTextInRange","setTextInRange","sort","e1","i1","e2","i2","compare","onWillSaveProviders","disposables","observeTextEditors","realSave","save","editor_","setTime","getTime","empty","providers","toArray","race","onWillSave","toPromise","uri","patchEditorSave","ProviderRegistry","config","_packageName","_config","getConfig","setPackageName","getPackageName","formatKeyPath","keyPath","getWithDefaults","defaults","current","getSchema","observe","optionsOrCallback","prototype","arguments","observeAsStream","disposable","onDidChange","set","setSchema","schema","unset","isFeatureDisabled","packages","isPackageDisabled","v","undefined","require","exports","_encode","ch","charCodeAt","toUpperCase","encodeURIComponent2","str","encodeURIComponent","replace","encodeNoop","isWindows","URI","_scheme","_empty","_authority","_path","_query","_fragment","_formatted","_fsPath","isUri","thing","authority","fragment","query","scheme","enumerable","configurable","_driveLetterPath","toLowerCase","substr","with","change","_validate","parse","_parseComponents","decodeURIComponent","_slash","idx","substring","match","_regexp","exec","components","_schemePattern","_singleSlashStart","_doubleSlashStart","skipEncoding","_asFormatted","encoder","parts","m","_upperCaseDrive","lastIdx","join","toJSON","res","fsPath","external","$mid","revive","default","platform","navigator","userAgent","factory","module","xs","s","op","CONTROL","BAREWORD","TOKEN","pow","env","opts","mapped","chunker","RegExp","filter","commented","j","charAt","comment","SQ","DQ","DS","BS","escape","quote","esc","out","isGlob","len","c","parseEnvVar","pattern","varend","varname","getVar","prev","arg","_","pre","r","JSON","stringify","acc","split","message","stack","input_","reference_","useShortVariant","useNumbersOnly","input","reference","delta","formats","shortFormats","longFormatsNumbers","longFormats","relativeFormat","remainder","haystack","char","count","code","a","b","maxLength","suffix","separator","level","repeat","noun","needle","ranges","matchIndex","prevRange","markdown","HOUR","DAY","WEEK","YEAR","MONTH","Number","MAX_VALUE","KNOWN_ARCHIVE_EXTENSIONS","URI_PREFIX_REGEX","isRemote","startsWith","isAtomUri","createRemoteUri","hostname","remotePath","hostAndPath","hostSep","_endsWithArchiveSeparator","parseRemoteUri","remoteUri","parsedUri","getHostname","relativePath","joinArray","_testForIllegalUri","uriPathModule","_pathModuleFor","_archiveEncodeArrayInPlace","_archiveDecode","normalize","_archiveEncode","basename","ext","dirname","extname","_getWindowsPathFromWindowsFileUri","prefix","pathModule","win32","_isWindowsPath","contains","parent","child","endsWithSeparator","_isArchiveSeparator","sep","hostFormatters","hostnameToDisplayHostname","formatter","nuclideUriToDisplayHostname","ensureTrailingSeparator","endsWith","isAbsolute","isRoot","posix","_matchTrailingArchive","other","some","extStart","IMAGE_EXTENSIONS","stripExtension","isLocal","isInArchive","ancestorOutsideArchive","validate","mustBeRemote","getHostnameOpt","archiveJoin","relative","remote","uriEncode","otherEncode","looksLikeImageUri","has","normalizeDir","getParent","uriToNuclideUri","windowsPathFromUri","lspUri","LspUri","nuclideUriToUri","collapse","fp","nuclideUriToDisplayString","registerHostnameFormatter","trimTrailingSeparator","stripped","endsWithEdenDir","isHomeRelative","expandHomeDir","HOME","UserProfile","os","homePath","splitPathList","delimiter","joinPathList","every","ensureLocalPrefix","localPrefix","parsePath","parsed","root","dir","base","reverse","pathSeparatorFor","hasKnownArchiveExtension","ARCHIVE_SEPARATOR","NUCLIDE_URI_TYPE_NAME","__TEST__","context","integerPart","n","censorNegativeZero","trunc","sign","createIntegerConversion","bitLength","typeOpts","isSigned","unsigned","lowerBound","upperBound","twoToTheBitLength","twoToOneLessThanTheBitLength","V","enforceRange","isFinite","isNaN","clamp","floor","evenRound","y","signMightNotMatch","modulo","convertCallbackFunction","val","is","fround","treatNullAsEmptyString","DOMString","codePointAt","S","U","fromCodePoint","d","ArrayBuffer","DataView","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Uint8ClampedArray","Float32Array","Float64Array","func","article","isView","getReferenceToBytes","bufferSource","getPrototypeOf","Buffer","byteOffset","byteLength","wrapperSymbol","Symbol","implSymbol","sameObjectCaches","wrapperForImpl","impl","implForWrapper","wrapper","iterInternalSymbol","IteratorPrototype","iterator","isObject","getCopyToBytes","mixin","target","source","getOwnPropertyNames","getOwnPropertyDescriptor","getSameObject","prop","creator","tryWrapperForImpl","tryImplForWrapper","legacyErrorCodes","idlUtils","require$$1","conversions","require$$0","utils","DOMException","iface","setup","writable","toStringTag","mixedInto","Impl","implementation","isImpl","convert","constructorArgs","privateData","createImpl","_internalSetup","init","interface","expose","Window","Worker","require$$2","setPrototypeOf","WeakMap","wrappers","pd","retv","console","assert","Event","eventTarget","eventPhase","currentTarget","stopped","passiveListener","timeStamp","defineRedirectDescriptor","defineCallDescriptor","getWrapper","proto","BaseEvent","CustomEvent","isFunc","defineWrapper","isStopped","setPassiveListener","composedPath","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","stopPropagation","stopImmediatePropagation","bubbles","cancelable","preventDefault","defaultPrevented","composed","window","listenersMap","getListeners","listeners","defineEventAttribute","eventTargetPrototype","node","listenerType","listener","newNode","passive","once","defineEventAttributeDescriptor","defineCustomEventTarget","eventNames","CustomEventTarget","EventTarget","isArray","types","Map","addEventListener","optionsIsObj","capture","removeEventListener","dispatchEvent","wrappedEvent","wrapEvent","handleEvent","setEventPhase","setCurrentTarget","AbortSignal","EventTargetShim","aborted","onabort","signal","abort","element","elem","subArray","predicate","subarr","offset","arrayEqual","pass","fail","maps","unionMap","selected","selector","src","transform","map1","map2","equalComparator","size","equalFunction","value1","default_","setFilter","sets","accumulator","setUnionTwo","hash_","hash","bHashes","pairs","pair","k","list","iterable","project","iterators","projectorFn","stop","step","findInIterable","iterableIsEmpty","filterIterable","arr","startingIndex","objectEntries","keyFn","seenKeys","ranker","maxRank","maxRankedItem","maxSeenRank","rank","array1","array2","item1","entries","hasOwnProperty","propertyIsEnumerable","_map","deleteAll","newSet","didRemove","hasAny","DefaultMap","_factory","super","DefaultWeakMap","wait","immediate","timestamp","later","last","debounced","args_","callNow","includeNewlines","onEnd","lines","pop","complete","condition","stream","flush","multicast","ReplaySubject","refCount","addAction","reconcileSetDiffs","let","diffSets","toggler","distinctUntilChanged","switchMap","enabled","observables","tagged","observable","scan","leading","getDelay","timer","timerStarts","latestValue","latestValueIsLeading","shouldIgnore","checkShouldNext","valueToDispatch","sub","Subscription","completedSymbol","o","materialize","dematerialize","debouncedNext","subscription","completed","abortController","AbortController","takeUntil","fromEvent","delays","subscribedAt","do","timeElapsed","pairwise","previous","added","removed","diff","diffs","itemsToDisposables","disposeItem","microtask","macrotask","timerId","setImmediate","clearImmediate","nextAnimationFrame","requestAnimationFrame","id","cancelAnimationFrame","toAbortablePromise","_abortController","createTask","cancel","controller","isExecuting","CodeFormatManager","_subscriptions","_subscribeToEvents","registerOnWillSave","_onWillSaveProvider","_rangeProviders","_fileProviders","_onTypeProviders","_onSaveProviders","commandEvents","observableFromSubscribeFunction","commands","editorEvents","cb","mergeMap","changeEvents","onDidChangeText","willDestroyEvents","onWillDestroyPaneItem","observeEditorDestroy","_getEditorEventStream","groupBy","grouped","completingSwitchMap","_handleEvent","_formatCodeInTextEditor","applyTextEditsToBuffer","notifications","addError","detail","_formatCodeOnTypeInTextEditor","getLogger","throw","range","selectionRange","getSelectedBufferRange","selectionStart","selectionEnd","formatRange","isEmpty","Range","rangeProviders","fileProviders","contents","rangeEdits","_reportBusy","formatCode","allEdits","firstNonEmpty","find","fileEdits","formatEntireFile","allResults","firstNonNull","formatted","first","aggregatedEvent","typedText","getActivePackage","includes","isBracketPair","shouldFormatOnType","featureConfig","character","cursorPosition","getCursorBufferPosition","copy","formatAtPosition","firstNonEmptyIndex","before","after","_checkContentsAreSame","keepCursorPosition","_formatCodeOnSaveInTextEditor","saveProviders","formatOnSave","flatMap","scope","getRootScopeDescriptor","getFormatOnSave","revealTooltip","busySignalService","_busySignalService","displayPath","nuclideUri","reportBusyWhile","addRangeProvider","addFileProvider","addOnTypeProvider","addOnSaveProvider","consumeBusySignal","codeFormatManager","consumeRangeProvider","consumeFileProvider","consumeOnTypeProvider","consumeOnSaveProvider","inclusionPriority"],"mappings":"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"}