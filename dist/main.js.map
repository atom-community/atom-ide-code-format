{"version":3,"file":"main.js","sources":["../node_modules/.pnpm/atom-ide-base@3.3.0/node_modules/atom-ide-base/src-commons-atom/ProviderRegistry.ts","../node_modules/nuclide/nuclide-commons/UniversalDisposable.js","../node_modules/nuclide/nuclide-commons/event.js","../node_modules/nuclide/nuclide-commons-atom/text-editor.js","../node_modules/nuclide/nuclide-commons-atom/go-to-location.js","../node_modules/nuclide/nuclide-commons-atom/text-edit.js","../node_modules/.pnpm/vscode-uri@1.0.1/node_modules/vscode-uri/lib/index.js","../node_modules/nuclide/nuclide-commons/_shell-quote.js","../node_modules/nuclide/nuclide-commons/string.js","../node_modules/nuclide/nuclide-commons/nuclideUri.js","../../src/CodeFormatManager.ts","../../src/config.ts","../../src/utils.ts","../../src/main.ts","../../src/legacy-provider.ts"],"sourcesContent":["import { Disposable, TextEditor } from \"atom\"\nimport { Provider as ProviderTypes, BusySignalProvider, FindReferencesProvider } from \"../types-packages/main.d\"\n\nexport class ProviderRegistry<Provider extends Exclude<ProviderTypes, BusySignalProvider | FindReferencesProvider>> {\n  private providers: Array<Provider>\n\n  constructor() {\n    this.providers = []\n  }\n\n  addProvider(provider: Provider): Disposable {\n    const index = this.providers.findIndex((p) => provider.priority > p.priority)\n    if (index === -1) {\n      this.providers.push(provider)\n    } else {\n      this.providers.splice(index, 0, provider)\n    }\n    return new Disposable(() => {\n      this.removeProvider(provider)\n    })\n  }\n\n  removeProvider(provider: Provider): void {\n    const index = this.providers.indexOf(provider)\n    if (index !== -1) {\n      this.providers.splice(index, 1)\n    }\n  }\n\n  // TODO deprecate since there can be N providers.\n  getProviderForEditor(editor: TextEditor): Provider | null {\n    const grammar = editor.getGrammar().scopeName\n    return this.findProvider(grammar)\n  }\n\n  // TODO create an ordering or priority aware util to prefer instead.\n  getAllProvidersForEditor(editor: TextEditor): Iterable<Provider> {\n    const grammar = editor.getGrammar().scopeName\n    return this.findAllProviders(grammar)\n  }\n\n  findProvider(grammar: string): Provider | null {\n    for (const provider of this.findAllProviders(grammar)) {\n      return provider\n    }\n    return null\n  }\n\n  /** Iterates over all providers matching the grammar, in priority order. */\n  *findAllProviders(grammar: string): Iterable<Provider> {\n    for (const provider of this.providers) {\n      if (provider.grammarScopes == null || provider.grammarScopes.indexOf(grammar) !== -1) {\n        yield provider\n      }\n    }\n  }\n}\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nexport type IDestructible = {\r\n  destroy(): void,\r\n  onDidDestroy(callback: () => mixed): IDisposable,\r\n};\r\n\r\nexport type AnyTeardown =\r\n  | (() => mixed)\r\n  | rxjs$ISubscription\r\n  | IDisposable\r\n  | IDestructible;\r\n\r\n/**\r\n * Like a CompositeDisposable, but in addition to Disposable instances it can\r\n * also accept plain functions and Rx subscriptions.\r\n */\r\nexport default class UniversalDisposable {\r\n  disposed: boolean;\r\n  teardowns: Set<AnyTeardown>;\r\n\r\n  constructor(...teardowns: Array<AnyTeardown>) {\r\n    this.teardowns = new Set();\r\n    this.disposed = false;\r\n    if (teardowns.length) {\r\n      this.add(...teardowns);\r\n    }\r\n  }\r\n\r\n  add(...teardowns: Array<AnyTeardown>): void {\r\n    if (this.disposed) {\r\n      throw new Error('Cannot add to an already disposed UniversalDisposable!');\r\n    }\r\n    for (let i = 0; i < teardowns.length; i++) {\r\n      assertTeardown(teardowns[i]);\r\n      this.teardowns.add(teardowns[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a list of teardowns but also ties them to the lifetime of `destructible`.\r\n   * When `destructible` is destroyed (or `this.dispose()` gets called, whichever comes first),\r\n   * all `teardowns` provided are also disposed.\r\n   *\r\n   * This is a subtle pattern to get right because of two factors:\r\n   * - we need to make sure that all teardowns are also removed on destroy\r\n   * - we also need to ensure that we don't leak the onDidDestroy disposable\r\n   */\r\n  addUntilDestroyed(\r\n    destructible: IDestructible,\r\n    ...teardowns: Array<AnyTeardown>\r\n  ) {\r\n    if (this.disposed) {\r\n      throw new Error('Cannot add to an already disposed UniversalDisposable!');\r\n    }\r\n    const destroyDisposable = new UniversalDisposable(\r\n      ...teardowns,\r\n      destructible.onDidDestroy(() => {\r\n        destroyDisposable.dispose();\r\n        this.remove(destroyDisposable);\r\n      }),\r\n    );\r\n    this.add(destroyDisposable);\r\n  }\r\n\r\n  remove(teardown: AnyTeardown): void {\r\n    if (!this.disposed) {\r\n      this.teardowns.delete(teardown);\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    if (!this.disposed) {\r\n      this.disposed = true;\r\n      this.teardowns.forEach(teardown => {\r\n        if (typeof teardown.dispose === 'function') {\r\n          teardown.dispose();\r\n        } else if (typeof teardown.unsubscribe === 'function') {\r\n          teardown.unsubscribe();\r\n        } else if (typeof teardown.destroy === 'function') {\r\n          teardown.destroy();\r\n        } else if (typeof teardown === 'function') {\r\n          teardown();\r\n        }\r\n      });\r\n      this.teardowns = (null: any);\r\n    }\r\n  }\r\n\r\n  unsubscribe(): void {\r\n    this.dispose();\r\n  }\r\n\r\n  clear(): void {\r\n    if (!this.disposed) {\r\n      this.teardowns.clear();\r\n    }\r\n  }\r\n}\r\n\r\nfunction assertTeardown(teardown: AnyTeardown): void {\r\n  if (\r\n    typeof teardown.dispose === 'function' ||\r\n    typeof teardown.unsubscribe === 'function' ||\r\n    typeof teardown.destroy === 'function' ||\r\n    typeof teardown === 'function'\r\n  ) {\r\n    return;\r\n  }\r\n  throw new TypeError(\r\n    'Arguments to UniversalDisposable.add must be disposable',\r\n  );\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport UniversalDisposable from './UniversalDisposable';\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\n/**\r\n * Add an event listener an return a disposable for removing it. Note that this function assumes\r\n * node EventEmitter semantics: namely, that adding the same combination of eventName and callback\r\n * adds a second listener.\r\n */\r\nexport function attachEvent(\r\n  emitter: events$EventEmitter,\r\n  eventName: string,\r\n  callback: Function,\r\n): IDisposable {\r\n  emitter.addListener(eventName, callback);\r\n  return new UniversalDisposable(() => {\r\n    emitter.removeListener(eventName, callback);\r\n  });\r\n}\r\n\r\ntype SubscribeCallback<T> = (item: T) => any;\r\ntype SubscribeFunction<T> = (\r\n  callback: SubscribeCallback<T>,\r\n) => IDisposable | (() => mixed);\r\n\r\nexport function observableFromSubscribeFunction<T>(\r\n  fn: SubscribeFunction<T>,\r\n): Observable<T> {\r\n  return Observable.create(\r\n    observer => new UniversalDisposable(fn(observer.next.bind(observer))),\r\n  );\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport type {NuclideUri} from '@atom-ide-community/nuclide-commons/nuclideUri';\r\n\r\nimport invariant from 'assert';\r\nimport {TextEditor} from 'atom';\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport {observableFromSubscribeFunction} from '@atom-ide-community/nuclide-commons/event';\r\n\r\n/**\r\n * Returns a text editor that has the given path open, or null if none exists. If there are multiple\r\n * text editors for this path, one is chosen arbitrarily.\r\n */\r\nexport function existingEditorForUri(path: NuclideUri): ?atom$TextEditor {\r\n  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a\r\n  // real problem. And if you have more than a few hundred you probably have bigger problems.\r\n  for (const editor of atom.workspace.getTextEditors()) {\r\n    if (editor.getPath() === path) {\r\n      return editor;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Returns a text editor that has the given buffer open, or null if none exists. If there are\r\n * multiple text editors for this buffer, one is chosen arbitrarily.\r\n */\r\nexport function existingEditorForBuffer(\r\n  buffer: atom$TextBuffer,\r\n): ?atom$TextEditor {\r\n  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a\r\n  // real problem. And if you have more than a few hundred you probably have bigger problems.\r\n  for (const editor of atom.workspace.getTextEditors()) {\r\n    if (editor.getBuffer() === buffer) {\r\n      return editor;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getViewOfEditor(\r\n  editor: atom$TextEditor,\r\n): atom$TextEditorElement {\r\n  return atom.views.getView(editor);\r\n}\r\n\r\nexport function getScrollTop(editor: atom$TextEditor): number {\r\n  return getViewOfEditor(editor).getScrollTop();\r\n}\r\n\r\nexport function setScrollTop(editor: atom$TextEditor, scrollTop: number): void {\r\n  getViewOfEditor(editor).setScrollTop(scrollTop);\r\n}\r\n\r\n/**\r\n * Does a best effort to set an editor pane to a given cursor position & scroll.\r\n * Does not ensure that the current cursor position is visible.\r\n *\r\n * Can be used with editor.getCursorBufferPosition() & getScrollTop() to restore\r\n * an editors cursor and scroll.\r\n */\r\nexport function setPositionAndScroll(\r\n  editor: atom$TextEditor,\r\n  position: atom$Point,\r\n  scrollTop: number,\r\n): void {\r\n  editor.setCursorBufferPosition(position, {autoscroll: false});\r\n  setScrollTop(editor, scrollTop);\r\n}\r\n\r\nexport function getCursorPositions(\r\n  editor: atom$TextEditor,\r\n): Observable<atom$Point> {\r\n  return Observable.defer(() => {\r\n    // This will behave strangely in the face of multiple cursors. Consider supporting multiple\r\n    // cursors in the future.\r\n    const cursor = editor.getCursors()[0];\r\n    invariant(cursor != null);\r\n    return Observable.merge(\r\n      Observable.of(cursor.getBufferPosition()),\r\n      observableFromSubscribeFunction(\r\n        cursor.onDidChangePosition.bind(cursor),\r\n      ).map(event => event.newBufferPosition),\r\n    );\r\n  });\r\n}\r\n\r\nexport function observeEditorDestroy(\r\n  editor: atom$TextEditor,\r\n): Observable<atom$TextEditor> {\r\n  return observableFromSubscribeFunction(editor.onDidDestroy.bind(editor))\r\n    .map(event => editor)\r\n    .take(1);\r\n}\r\n\r\n// Use atom readOnly attribute to set read-only state.\r\nexport function enforceReadOnlyEditor(\r\n  textEditor: atom$TextEditor,\r\n  readOnlyExceptions?: Array<string> = ['append', 'setText'],\r\n): IDisposable {\r\n  textEditor.getElement().setAttribute('readonly', '');\r\n  return {\r\n    dispose() {\r\n      textEditor.getElement().removeAttribute('readonly');\r\n    },\r\n  };\r\n}\r\n\r\n// Turn off soft wrap setting for these editors so diffs properly align.\r\n// Some text editor register sometimes override the set soft wrapping\r\n// after mounting an editor to the workspace - here, that's watched and reset to `false`.\r\nexport function enforceSoftWrap(\r\n  editor: atom$TextEditor,\r\n  enforcedSoftWrap: boolean,\r\n): IDisposable {\r\n  editor.setSoftWrapped(enforcedSoftWrap);\r\n  return editor.onDidChangeSoftWrapped(softWrapped => {\r\n    if (softWrapped !== enforcedSoftWrap) {\r\n      // Reset the overridden softWrap to `false` once the operation completes.\r\n      process.nextTick(() => {\r\n        if (!editor.isDestroyed()) {\r\n          editor.setSoftWrapped(enforcedSoftWrap);\r\n        }\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Checks if an object (typically an Atom pane) is a TextEditor.\r\n * Could be replaced with atom.workspace.isValidTextEditor,\r\n * but Flow doesn't support %checks in methods yet.\r\n */\r\nexport function isValidTextEditor(item: mixed): boolean %checks {\r\n  return item instanceof TextEditor;\r\n}\r\n\r\nexport function centerScrollToBufferLine(\r\n  textEditorElement: atom$TextEditorElement,\r\n  bufferLineNumber: number,\r\n): void {\r\n  const textEditor = textEditorElement.getModel();\r\n  const pixelPositionTop = textEditorElement.pixelPositionForBufferPosition([\r\n    bufferLineNumber,\r\n    0,\r\n  ]).top;\r\n  // Manually calculate the scroll location, instead of using\r\n  // `textEditor.scrollToBufferPosition([lineNumber, 0], {center: true})`\r\n  // because that API to wouldn't center the line if it was in the visible screen range.\r\n  const scrollTop =\r\n    pixelPositionTop +\r\n    textEditor.getLineHeightInPixels() / 2 -\r\n    textEditorElement.clientHeight / 2;\r\n  textEditorElement.setScrollTop(Math.max(scrollTop, 1));\r\n\r\n  textEditorElement.focus();\r\n\r\n  textEditor.setCursorBufferPosition([bufferLineNumber, 0], {\r\n    autoscroll: false,\r\n  });\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\nimport type {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport {getLogger} from 'log4js';\r\nimport {Subject} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\nimport invariant from 'assert';\r\n\r\nexport type GoToLocationOptions = {|\r\n  line?: number,\r\n  column?: number,\r\n  center?: boolean,\r\n  activateItem?: boolean,\r\n  activatePane?: boolean,\r\n  pending?: boolean,\r\n  moveCursor?: boolean,\r\n|};\r\n\r\n/**\r\n * Opens the given file.\r\n *\r\n * Optionally include a line and column to navigate to. If a line is given, by default it will\r\n * center it in the opened text editor.\r\n *\r\n * This should be preferred over `atom.workspace.open()` in typical cases. The motivations are:\r\n * - We call `atom.workspace.open()` with the `searchAllPanes` option. This looks in other panes for\r\n *   the current file, rather just opening a new copy in the current pane. People often forget this\r\n *   option which typically leads to a subpar experience for people who use multiple panes.\r\n * - When moving around in the current file, `goToLocation` explicitly publishes events that the nav\r\n *   stack uses.\r\n *\r\n * Currently, `atom.workspace.open()` should be used only in these cases:\r\n * - When the URI to open is not a file URI. For example, if we want to open some tool like find\r\n *   references in a pane.\r\n * - When we want to open an untitled file (providing no file argument). Currently, goToLocation\r\n *   requires a file to open.\r\n * - When we want to open a file as a pending pane item. Currently goToLocation cannot do this.\r\n *\r\n * In these cases, you may disable the lint rule against `atom.workspace.open` by adding the\r\n * following comment above its use:\r\n * // eslint-disable-next-line nuclide-internal/atom-apis\r\n */\r\nexport async function goToLocation(\r\n  file: string,\r\n  options?: ?GoToLocationOptions,\r\n): Promise<atom$TextEditor> {\r\n  const center = options?.center ?? true;\r\n  const moveCursor = options?.moveCursor ?? true;\r\n  const activatePane = options?.activatePane ?? true;\r\n  const activateItem = options?.activateItem;\r\n  const line = options?.line;\r\n  const column = options?.column;\r\n  const pending = options?.pending;\r\n\r\n  // Prefer going to the current editor rather than the leftmost editor.\r\n  const currentEditor = atom.workspace.getActiveTextEditor();\r\n  if (currentEditor != null && currentEditor.getPath() === file) {\r\n    const paneContainer = atom.workspace.paneContainerForItem(currentEditor);\r\n    invariant(paneContainer != null);\r\n    if (activatePane) {\r\n      paneContainer.activate();\r\n    }\r\n    if (line != null) {\r\n      goToLocationInEditor(currentEditor, {\r\n        line,\r\n        column: column == null ? 0 : column,\r\n        center,\r\n        moveCursor,\r\n      });\r\n    } else {\r\n      invariant(column == null, 'goToLocation: Cannot specify just column');\r\n    }\r\n    return currentEditor;\r\n  } else {\r\n    // Obviously, calling goToLocation isn't a viable alternative here :P\r\n    // eslint-disable-next-line nuclide-internal/atom-apis\r\n    const editor = await atom.workspace.open(file, {\r\n      initialLine: line,\r\n      initialColumn: column,\r\n      searchAllPanes: true,\r\n      activatePane,\r\n      activateItem,\r\n      pending,\r\n    });\r\n    // TODO(T28305560) Investigate offenders for this error\r\n    if (editor == null) {\r\n      const tmp = {};\r\n      Error.captureStackTrace(tmp);\r\n      const error = Error(`atom.workspace.open returned null on ${file}`);\r\n      getLogger('goToLocation').error(error);\r\n      throw error;\r\n    }\r\n\r\n    if (center && line != null) {\r\n      editor.scrollToBufferPosition([line, column], {center: true});\r\n    }\r\n    return editor;\r\n  }\r\n}\r\n\r\nconst goToLocationSubject = new Subject();\r\n\r\ntype GotoLocationInEditorOptions = {|\r\n  line: number,\r\n  column: number,\r\n  center?: boolean,\r\n  moveCursor?: boolean,\r\n|};\r\n\r\n// Scrolls to the given line/column at the given editor\r\n// broadcasts the editor instance on an observable (subject) available\r\n// through the getGoToLocation\r\nexport function goToLocationInEditor(\r\n  editor: atom$TextEditor,\r\n  options: GotoLocationInEditorOptions,\r\n): void {\r\n  const center = options.center == null ? true : options.center;\r\n  const moveCursor = options.moveCursor == null ? true : options.moveCursor;\r\n  const {line, column} = options;\r\n\r\n  if (moveCursor) {\r\n    editor.setCursorBufferPosition([line, column]);\r\n  }\r\n  if (center) {\r\n    editor.scrollToBufferPosition([line, column], {center: true});\r\n  }\r\n\r\n  goToLocationSubject.next(editor);\r\n}\r\n\r\nexport function observeNavigatingEditors(): Observable<atom$TextEditor> {\r\n  return goToLocationSubject;\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\nimport type {NuclideUri} from '@atom-ide-community/nuclide-commons/nuclideUri';\r\n\r\nimport invariant from 'assert';\r\nimport {getLogger} from 'log4js';\r\n\r\nimport {existingEditorForUri} from './text-editor';\r\nimport {goToLocation} from './go-to-location';\r\n\r\nexport type TextEdit = {\r\n  oldRange: atom$Range,\r\n  newText: string,\r\n  // If included, this will be used to verify that the edit still applies cleanly.\r\n  oldText?: string,\r\n};\r\n\r\n/**\r\n * Attempts to apply the given patches for multiple files. Accepts a Map as input\r\n * with file paths as keys and a corresponding array of TextEdits as values.\r\n *\r\n * It is an error to send overlapping text-edits. All text-edits describe changes\r\n * made to the initial document version. The order of the edits does not matter\r\n * as they will be sorted before they are applied.\r\n *\r\n * All changes will be applied to the buffers but not saved. If a file is not\r\n * currently open, it will be opened.\r\n *\r\n * If a change is undone (Cmd+Z), only the changes of the current\r\n * file will be undone. All of the changes for that file will be undone at once.\r\n *\r\n * Returns true if the application was successful, otherwise false. If any of\r\n * the changes fail, for ANY file, then none of the changes are applied.\r\n */\r\nexport async function applyTextEditsForMultipleFiles(\r\n  changes: Map<NuclideUri, Array<TextEdit>>,\r\n): Promise<boolean> {\r\n  const paths = Array.from(changes.keys());\r\n\r\n  // NOTE: There is a race here. If the file contents change while the\r\n  // editors are being opened, then the ranges of the TextEdits will be off.\r\n  // However, currently this is only used to applyEdits to open files.\r\n  const editors = await Promise.all(\r\n    paths.map(async path => goToLocation(path)),\r\n  );\r\n  const checkpoints = editors.map(editor => {\r\n    invariant(editor != null);\r\n    const buffer = editor.getBuffer();\r\n    return [buffer, buffer.createCheckpoint()];\r\n  });\r\n  const allOkay = paths.reduce((successSoFar, path) => {\r\n    const edits = changes.get(path);\r\n    return successSoFar && edits != null && applyTextEdits(path, ...edits);\r\n  }, true);\r\n  if (!allOkay) {\r\n    checkpoints.forEach(([buffer, checkPoint]) => {\r\n      buffer.revertToCheckpoint(checkPoint);\r\n      return false;\r\n    });\r\n  }\r\n  return allOkay;\r\n}\r\n\r\n/**\r\n * Attempts to apply the given patches to the given file.\r\n *\r\n * It is an error to send overlapping edits. The order of the edits does not\r\n * matter (they will be sorted before they are applied).\r\n *\r\n * The file must be currently open in Atom, and the changes will be applied to the buffer but not\r\n * saved.\r\n *\r\n * Returns true if the application was successful, otherwise false (e.g. if the oldText did not\r\n * match).\r\n */\r\nexport function applyTextEdits(\r\n  path: NuclideUri,\r\n  ...edits: Array<TextEdit>\r\n): boolean {\r\n  const sortedEdits = sortEdits(edits);\r\n  const editor = existingEditorForUri(path);\r\n  invariant(editor != null);\r\n  return applySortedTextEditsToBuffer(editor.getBuffer(), sortedEdits);\r\n}\r\n\r\nexport function applyTextEditsToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edits: Array<TextEdit>,\r\n): boolean {\r\n  return applySortedTextEditsToBuffer(buffer, sortEdits(edits));\r\n}\r\n\r\nfunction applySortedTextEditsToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edits: Array<TextEdit>,\r\n): boolean {\r\n  // For every edit, the start of its range will be after the end of the\r\n  // previous edit's range.\r\n  if (editsOverlap(edits)) {\r\n    getLogger('text-edit').warn(\r\n      'applyTextEdits was called with overlapping edits.',\r\n    );\r\n    return false;\r\n  }\r\n  // Special-case whole-buffer changes to minimize disruption.\r\n  if (edits.length === 1 && edits[0].oldRange.isEqual(buffer.getRange())) {\r\n    if (edits[0].oldText != null && edits[0].oldText !== buffer.getText()) {\r\n      return false;\r\n    }\r\n    buffer.setTextViaDiff(edits[0].newText);\r\n    return true;\r\n  }\r\n\r\n  const checkpoint = buffer.createCheckpoint();\r\n\r\n  // Iterate through in reverse order. Edits earlier in the file can move around text later in the\r\n  // file, so to avoid conflicts edits should be applied last first.\r\n  for (let i = edits.length - 1; i >= 0; i--) {\r\n    const edit = edits[i];\r\n    const success = applyToBuffer(buffer, edit);\r\n    if (!success) {\r\n      buffer.revertToCheckpoint(checkpoint);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  buffer.groupChangesSinceCheckpoint(checkpoint);\r\n  return true;\r\n}\r\n\r\nfunction applyToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edit: TextEdit,\r\n): boolean {\r\n  if (edit.oldRange.start.row === edit.oldRange.end.row) {\r\n    // A little extra validation when the old range spans only one line. In particular, this helps\r\n    // when the old range is empty so there is no old text for us to compare against. We can at\r\n    // least abort if the line isn't long enough.\r\n    const lineLength = buffer.lineLengthForRow(edit.oldRange.start.row);\r\n    if (edit.oldRange.end.column > lineLength) {\r\n      return false;\r\n    }\r\n  }\r\n  if (edit.oldText != null) {\r\n    const currentText = buffer.getTextInRange(edit.oldRange);\r\n    if (currentText !== edit.oldText) {\r\n      return false;\r\n    }\r\n  }\r\n  buffer.setTextInRange(edit.oldRange, edit.newText);\r\n  return true;\r\n}\r\n\r\n// Returns whether an array of sorted TextEdits contain an overlapping range.\r\nfunction editsOverlap(sortedEdits: Array<TextEdit>): boolean {\r\n  for (let i = 0; i < sortedEdits.length - 1; i++) {\r\n    if (\r\n      sortedEdits[i].oldRange.end.isGreaterThan(\r\n        sortedEdits[i + 1].oldRange.start,\r\n      )\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction sortEdits(edits: Array<TextEdit>): Array<TextEdit> {\r\n  // stable sort (preserve order of edits starting in the same location)\r\n  return edits\r\n    .map((edit, i) => [edit, i])\r\n    .sort(\r\n      ([e1, i1], [e2, i2]) =>\r\n        e1.oldRange.start.compare(e2.oldRange.start) ||\r\n        e1.oldRange.end.compare(e2.oldRange.end) ||\r\n        i1 - i2,\r\n    )\r\n    .map(([edit]) => edit);\r\n}\r\n","(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function _encode(ch) {\n        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    function encodeURIComponent2(str) {\n        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);\n    }\n    function encodeNoop(str) {\n        return str.replace(/[#?]/, _encode);\n    }\n    /**\n     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n     * This class is a simple parser which creates the basic component paths\n     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n     * and encoding.\n     *\n     *       foo://example.com:8042/over/there?name=ferret#nose\n     *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n     *        |           |            |            |        |\n     *     scheme     authority       path        query   fragment\n     *        |   _____________________|__\n     *       / \\ /                        \\\n     *       urn:example:animal:ferret:nose\n     *\n     *\n     */\n    var URI = (function () {\n        function URI() {\n            this._scheme = URI._empty;\n            this._authority = URI._empty;\n            this._path = URI._empty;\n            this._query = URI._empty;\n            this._fragment = URI._empty;\n            this._formatted = null;\n            this._fsPath = null;\n        }\n        URI.isUri = function (thing) {\n            if (thing instanceof URI) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return typeof thing.authority === 'string'\n                && typeof thing.fragment === 'string'\n                && typeof thing.path === 'string'\n                && typeof thing.query === 'string'\n                && typeof thing.scheme === 'string';\n        };\n        Object.defineProperty(URI.prototype, \"scheme\", {\n            /**\n             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n             * The part before the first colon.\n             */\n            get: function () {\n                return this._scheme;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"authority\", {\n            /**\n             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n             * The part between the first double slashes and the next slash.\n             */\n            get: function () {\n                return this._authority;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"path\", {\n            /**\n             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._path;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"query\", {\n            /**\n             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._query;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"fragment\", {\n            /**\n             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._fragment;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"fsPath\", {\n            // ---- filesystem path -----------------------\n            /**\n             * Returns a string representing the corresponding file system path of this URI.\n             * Will handle UNC paths and normalize windows drive letters to lower-case. Also\n             * uses the platform specific path separator. Will *not* validate the path for\n             * invalid characters and semantics. Will *not* look at the scheme of this URI.\n             */\n            get: function () {\n                if (!this._fsPath) {\n                    var value;\n                    if (this._authority && this._path && this.scheme === 'file') {\n                        // unc path: file://shares/c$/far/boo\n                        value = \"//\" + this._authority + this._path;\n                    }\n                    else if (URI._driveLetterPath.test(this._path)) {\n                        // windows drive letter: file:///c:/far/boo\n                        value = this._path[1].toLowerCase() + this._path.substr(2);\n                    }\n                    else {\n                        // other path\n                        value = this._path;\n                    }\n                    if (isWindows) {\n                        value = value.replace(/\\//g, '\\\\');\n                    }\n                    this._fsPath = value;\n                }\n                return this._fsPath;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // ---- modify to new -------------------------\n        URI.prototype.with = function (change) {\n            if (!change) {\n                return this;\n            }\n            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;\n            if (scheme === void 0) {\n                scheme = this.scheme;\n            }\n            else if (scheme === null) {\n                scheme = '';\n            }\n            if (authority === void 0) {\n                authority = this.authority;\n            }\n            else if (authority === null) {\n                authority = '';\n            }\n            if (path === void 0) {\n                path = this.path;\n            }\n            else if (path === null) {\n                path = '';\n            }\n            if (query === void 0) {\n                query = this.query;\n            }\n            else if (query === null) {\n                query = '';\n            }\n            if (fragment === void 0) {\n                fragment = this.fragment;\n            }\n            else if (fragment === null) {\n                fragment = '';\n            }\n            if (scheme === this.scheme\n                && authority === this.authority\n                && path === this.path\n                && query === this.query\n                && fragment === this.fragment) {\n                return this;\n            }\n            var ret = new URI();\n            ret._scheme = scheme;\n            ret._authority = authority;\n            ret._path = path;\n            ret._query = query;\n            ret._fragment = fragment;\n            URI._validate(ret);\n            return ret;\n        };\n        // ---- parse & validate ------------------------\n        URI.parse = function (value) {\n            var ret = new URI();\n            var data = URI._parseComponents(value);\n            ret._scheme = data.scheme;\n            ret._authority = decodeURIComponent(data.authority);\n            ret._path = decodeURIComponent(data.path);\n            ret._query = decodeURIComponent(data.query);\n            ret._fragment = decodeURIComponent(data.fragment);\n            URI._validate(ret);\n            return ret;\n        };\n        URI.file = function (path) {\n            var ret = new URI();\n            ret._scheme = 'file';\n            // normalize to fwd-slashes on windows,\n            // on other systems bwd-slaches are valid\n            // filename character, eg /f\\oo/ba\\r.txt\n            if (isWindows) {\n                path = path.replace(/\\\\/g, URI._slash);\n            }\n            // check for authority as used in UNC shares\n            // or use the path as given\n            if (path[0] === URI._slash && path[0] === path[1]) {\n                var idx = path.indexOf(URI._slash, 2);\n                if (idx === -1) {\n                    ret._authority = path.substring(2);\n                }\n                else {\n                    ret._authority = path.substring(2, idx);\n                    ret._path = path.substring(idx);\n                }\n            }\n            else {\n                ret._path = path;\n            }\n            // Ensure that path starts with a slash\n            // or that it is at least a slash\n            if (ret._path[0] !== URI._slash) {\n                ret._path = URI._slash + ret._path;\n            }\n            URI._validate(ret);\n            return ret;\n        };\n        URI._parseComponents = function (value) {\n            var ret = {\n                scheme: URI._empty,\n                authority: URI._empty,\n                path: URI._empty,\n                query: URI._empty,\n                fragment: URI._empty,\n            };\n            var match = URI._regexp.exec(value);\n            if (match) {\n                ret.scheme = match[2] || ret.scheme;\n                ret.authority = match[4] || ret.authority;\n                ret.path = match[5] || ret.path;\n                ret.query = match[7] || ret.query;\n                ret.fragment = match[9] || ret.fragment;\n            }\n            return ret;\n        };\n        URI.from = function (components) {\n            return new URI().with(components);\n        };\n        URI._validate = function (ret) {\n            // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n            // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n            if (ret.scheme && !URI._schemePattern.test(ret.scheme)) {\n                throw new Error('[UriError]: Scheme contains illegal characters.');\n            }\n            // path, http://tools.ietf.org/html/rfc3986#section-3.3\n            // If a URI contains an authority component, then the path component\n            // must either be empty or begin with a slash (\"/\") character.  If a URI\n            // does not contain an authority component, then the path cannot begin\n            // with two slash characters (\"//\").\n            if (ret.path) {\n                if (ret.authority) {\n                    if (!URI._singleSlashStart.test(ret.path)) {\n                        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n                    }\n                }\n                else {\n                    if (URI._doubleSlashStart.test(ret.path)) {\n                        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n                    }\n                }\n            }\n        };\n        // ---- printing/externalize ---------------------------\n        /**\n         *\n         * @param skipEncoding Do not encode the result, default is `false`\n         */\n        URI.prototype.toString = function (skipEncoding) {\n            if (skipEncoding === void 0) { skipEncoding = false; }\n            if (!skipEncoding) {\n                if (!this._formatted) {\n                    this._formatted = URI._asFormatted(this, false);\n                }\n                return this._formatted;\n            }\n            else {\n                // we don't cache that\n                return URI._asFormatted(this, true);\n            }\n        };\n        URI._asFormatted = function (uri, skipEncoding) {\n            var encoder = !skipEncoding\n                ? encodeURIComponent2\n                : encodeNoop;\n            var parts = [];\n            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\n            if (scheme) {\n                parts.push(scheme, ':');\n            }\n            if (authority || scheme === 'file') {\n                parts.push('//');\n            }\n            if (authority) {\n                authority = authority.toLowerCase();\n                var idx = authority.indexOf(':');\n                if (idx === -1) {\n                    parts.push(encoder(authority));\n                }\n                else {\n                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\n                }\n            }\n            if (path) {\n                // lower-case windows drive letters in /C:/fff or C:/fff\n                var m = URI._upperCaseDrive.exec(path);\n                if (m) {\n                    if (m[1]) {\n                        path = '/' + m[2].toLowerCase() + path.substr(3); // \"/c:\".length === 3\n                    }\n                    else {\n                        path = m[2].toLowerCase() + path.substr(2); // // \"c:\".length === 2\n                    }\n                }\n                // encode every segement but not slashes\n                // make sure that # and ? are always encoded\n                // when occurring in paths - otherwise the result\n                // cannot be parsed back again\n                var lastIdx = 0;\n                while (true) {\n                    var idx = path.indexOf(URI._slash, lastIdx);\n                    if (idx === -1) {\n                        parts.push(encoder(path.substring(lastIdx)));\n                        break;\n                    }\n                    parts.push(encoder(path.substring(lastIdx, idx)), URI._slash);\n                    lastIdx = idx + 1;\n                }\n                ;\n            }\n            if (query) {\n                parts.push('?', encoder(query));\n            }\n            if (fragment) {\n                parts.push('#', encoder(fragment));\n            }\n            return parts.join(URI._empty);\n        };\n        URI.prototype.toJSON = function () {\n            var res = {\n                fsPath: this.fsPath,\n                external: this.toString(),\n                $mid: 1\n            };\n            if (this.path) {\n                res.path = this.path;\n            }\n            if (this.scheme) {\n                res.scheme = this.scheme;\n            }\n            if (this.authority) {\n                res.authority = this.authority;\n            }\n            if (this.query) {\n                res.query = this.query;\n            }\n            if (this.fragment) {\n                res.fragment = this.fragment;\n            }\n            return res;\n        };\n        URI.revive = function (data) {\n            var result = new URI();\n            result._scheme = data.scheme || URI._empty;\n            result._authority = data.authority || URI._empty;\n            result._path = data.path || URI._empty;\n            result._query = data.query || URI._empty;\n            result._fragment = data.fragment || URI._empty;\n            result._fsPath = data.fsPath;\n            result._formatted = data.external;\n            URI._validate(result);\n            return result;\n        };\n        return URI;\n    }());\n    URI._empty = '';\n    URI._slash = '/';\n    URI._regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    URI._driveLetterPath = /^\\/[a-zA-z]:/;\n    URI._upperCaseDrive = /^(\\/)?([A-Z]:)/;\n    URI._schemePattern = /^\\w[\\w\\d+.-]*$/;\n    URI._singleSlashStart = /^\\//;\n    URI._doubleSlashStart = /^\\/\\//;\n    exports.default = URI;\n    var isWindows;\n    if (typeof process === 'object') {\n        isWindows = process.platform === 'win32';\n    }\n    else if (typeof navigator === 'object') {\n        var userAgent = navigator.userAgent;\n        isWindows = userAgent.indexOf('Windows') >= 0;\n    }\n});\n","/**\r\nModified from https://github.com/substack/node-shell-quote/commit/72fb5a8.\r\nIncludes https://github.com/substack/node-shell-quote/pull/29, with minor\r\nmodifications to remove the unnecessary Array polyfills.\r\n\r\nUse the typed wrappers in ./string.js to access these functions.\r\n\r\nThe MIT License\r\n\r\nCopyright (c) 2013 James Halliday (mail@substack.net)\r\n\r\nPermission is hereby granted, free of charge,\r\nto any person obtaining a copy of this software and\r\nassociated documentation files (the \"Software\"), to\r\ndeal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify,\r\nmerge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom\r\nthe Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice\r\nshall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\r\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n@noflow\r\n*/\r\n\r\n/* eslint-disable */\r\n\r\nexports.quote = function (xs) {\r\n    return xs.map(function (s) {\r\n        if (s && typeof s === 'object') {\r\n            return s.op.replace(/(.)/g, '\\\\$1');\r\n        }\r\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\r\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\r\n        }\r\n        else if (/[\"'\\s]/.test(s)) {\r\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\r\n        }\r\n        else {\r\n            return String(s).replace(/([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '\\\\$1');\r\n        }\r\n    }).join(' ');\r\n};\r\n\r\nvar CONTROL = '(?:' + [\r\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '[&;()|<>]'\r\n].join('|') + ')';\r\nvar META = '|&;()<> \\\\t';\r\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\r\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\r\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\r\n\r\nvar TOKEN = '';\r\nfor (var i = 0; i < 4; i++) {\r\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\r\n}\r\n\r\nexports.parse = function (s, env, opts) {\r\n    var mapped = parse(s, env, opts);\r\n    if (typeof env !== 'function') return mapped;\r\n    return mapped.reduce(function (acc, s) {\r\n        if (typeof s === 'object') return acc.concat(s);\r\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\r\n        if (xs.length === 1) return acc.concat(xs[0]);\r\n        return acc.concat(xs.filter(Boolean).map(function (x) {\r\n            if (RegExp('^' + TOKEN).test(x)) {\r\n                return JSON.parse(x.split(TOKEN)[1]); }\r\n            else return x;\r\n        }));\r\n    }, []);\r\n};\r\n\r\nfunction parse (s, env, opts) {\r\n    var chunker = new RegExp([\r\n        '(' + CONTROL + ')', // control chars\r\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\r\n    ].join('|'), 'g');\r\n    var match = s.match(chunker).filter(Boolean);\r\n    var commented = false;\r\n\r\n    if (!match) return [];\r\n    if (!env) env = {};\r\n    if (!opts) opts = {};\r\n    return match.map(function (s, j) {\r\n        if (commented) {\r\n            return;\r\n        }\r\n        if (s.charAt(0) === '#') {\r\n            commented = true;\r\n            return { comment: s.substr(1) + match.slice(j+1).join(' ') };\r\n        }\r\n        if (RegExp('^' + CONTROL + '$').test(s)) {\r\n            return { op: s };\r\n        }\r\n\r\n        // Hand-written scanner/parser for Bash quoting rules:\r\n        //\r\n        //  1. inside single quotes, all characters are printed literally.\r\n        //  2. inside double quotes, all characters are printed literally\r\n        //     except variables prefixed by '$' and backslashes followed by\r\n        //     either a double quote or another backslash.\r\n        //  3. outside of any quotes, backslashes are treated as escape\r\n        //     characters and not printed (unless they are themselves escaped)\r\n        //  4. quote context can switch mid-token if there is no whitespace\r\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\r\n        //     \"allonetoken\")\r\n        var SQ = \"'\";\r\n        var DQ = '\"';\r\n        var DS = '$';\r\n        var BS = opts.escape || '\\\\';\r\n        var quote = false;\r\n        var esc = false;\r\n        var out = '';\r\n        var isGlob = false;\r\n\r\n        for (var i = 0, len = s.length; i < len; i++) {\r\n            var c = s.charAt(i);\r\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\r\n            if (esc) {\r\n                out += c;\r\n                esc = false;\r\n            }\r\n            else if (quote) {\r\n                if (c === quote) {\r\n                    quote = false;\r\n                }\r\n                else if (quote == SQ) {\r\n                    out += c;\r\n                }\r\n                else { // Double quote\r\n                    if (c === BS) {\r\n                        i += 1;\r\n                        c = s.charAt(i);\r\n                        if (c === DQ || c === BS || c === DS) {\r\n                            out += c;\r\n                        } else {\r\n                            out += BS + c;\r\n                        }\r\n                    }\r\n                    else if (c === DS) {\r\n                        out += parseEnvVar();\r\n                    }\r\n                    else {\r\n                        out += c;\r\n                    }\r\n                }\r\n            }\r\n            else if (c === DQ || c === SQ) {\r\n                quote = c;\r\n            }\r\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\r\n                return { op: s };\r\n            }\r\n            else if (c === BS) {\r\n                esc = true;\r\n            }\r\n            else if (c === DS) {\r\n                out += parseEnvVar();\r\n            }\r\n            else out += c;\r\n        }\r\n\r\n        if (isGlob) return {op: 'glob', pattern: out};\r\n\r\n        return out;\r\n\r\n        function parseEnvVar() {\r\n            i += 1;\r\n            var varend, varname;\r\n            //debugger\r\n            if (s.charAt(i) === '{') {\r\n                i += 1;\r\n                if (s.charAt(i) === '}') {\r\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\r\n                }\r\n                varend = s.indexOf('}', i);\r\n                if (varend < 0) {\r\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\r\n                }\r\n                varname = s.substr(i, varend - i);\r\n                i = varend;\r\n            }\r\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\r\n                varname = s.charAt(i);\r\n                i += 1;\r\n            }\r\n            else {\r\n                varend = s.substr(i).match(/[^\\w\\d_]/);\r\n                if (!varend) {\r\n                    varname = s.substr(i);\r\n                    i = s.length;\r\n                } else {\r\n                    varname = s.substr(i, varend.index);\r\n                    i += varend.index - 1;\r\n                }\r\n            }\r\n            return getVar(null, '', varname);\r\n        }\r\n    })\r\n    // finalize parsed aruments\r\n    .reduce(function(prev, arg){\r\n        if (arg === undefined){\r\n            return prev;\r\n        }\r\n        return prev.concat(arg);\r\n    },[]);\r\n\r\n    function getVar (_, pre, key) {\r\n        var r = typeof env === 'function' ? env(key) : env[key];\r\n        if (r === undefined) r = '';\r\n\r\n        if (typeof r === 'object') {\r\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\r\n        }\r\n        else return pre + r;\r\n    }\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\nimport {parse, quote} from './_shell-quote';\r\n\r\nexport function stringifyError(error: Error): string {\r\n  return `name: ${error.name}, message: ${error.message}, stack: ${\r\n    error.stack\r\n  }.`;\r\n}\r\n\r\n// As of Flow v0.28, Flow does not alllow implicit string coercion of null or undefined. Use this to\r\n// make it explicit.\r\nexport function maybeToString(str: ?string): string {\r\n  // We don't want to encourage the use of this function directly because it coerces anything to a\r\n  // string. We get stricter typechecking by using maybeToString, so it should generally be\r\n  // preferred.\r\n  return String(str);\r\n}\r\n\r\n/**\r\n * Originally adapted from https://github.com/azer/relative-date.\r\n * We're including it because of https://github.com/npm/npm/issues/12012\r\n */\r\nconst SECOND = 1000;\r\nconst MINUTE = 60 * SECOND;\r\nconst HOUR = 60 * MINUTE;\r\nconst DAY = 24 * HOUR;\r\nconst WEEK = 7 * DAY;\r\nconst YEAR = DAY * 365;\r\nconst MONTH = YEAR / 12;\r\n\r\nconst shortFormats = [\r\n  [0.7 * MINUTE, 'now'],\r\n  [1.5 * MINUTE, '1m'],\r\n  [60 * MINUTE, 'm', MINUTE],\r\n  [1.5 * HOUR, '1h'],\r\n  [DAY, 'h', HOUR],\r\n  [2 * DAY, '1d'],\r\n  [7 * DAY, 'd', DAY],\r\n  [1.5 * WEEK, '1w'],\r\n  [MONTH, 'w', WEEK],\r\n  [1.5 * MONTH, '1mo'],\r\n  [YEAR, 'mo', MONTH],\r\n  [1.5 * YEAR, '1y'],\r\n  [Number.MAX_VALUE, 'y', YEAR],\r\n];\r\n\r\nconst longFormats = [\r\n  [0.7 * MINUTE, 'just now'],\r\n  [1.5 * MINUTE, 'a minute ago'],\r\n  [60 * MINUTE, 'minutes ago', MINUTE],\r\n  [1.5 * HOUR, 'an hour ago'],\r\n  [DAY, 'hours ago', HOUR],\r\n  [2 * DAY, 'yesterday'],\r\n  [7 * DAY, 'days ago', DAY],\r\n  [1.5 * WEEK, 'a week ago'],\r\n  [MONTH, 'weeks ago', WEEK],\r\n  [1.5 * MONTH, 'a month ago'],\r\n  [YEAR, 'months ago', MONTH],\r\n  [1.5 * YEAR, 'a year ago'],\r\n  [Number.MAX_VALUE, 'years ago', YEAR],\r\n];\r\n\r\nconst longFormatsNumbers = [\r\n  [0.7 * MINUTE, 'just now'],\r\n  [1.5 * MINUTE, '1 minute ago'],\r\n  [60 * MINUTE, 'minutes ago', MINUTE],\r\n  [1.5 * HOUR, '1 hour ago'],\r\n  [DAY, 'hours ago', HOUR],\r\n  [2 * DAY, 'yesterday'],\r\n  [7 * DAY, 'days ago', DAY],\r\n  [1.5 * WEEK, '1 week ago'],\r\n  [MONTH, 'weeks ago', WEEK],\r\n  [1.5 * MONTH, '1 month ago'],\r\n  [YEAR, 'months ago', MONTH],\r\n  [1.5 * YEAR, '1 year ago'],\r\n  [Number.MAX_VALUE, 'years ago', YEAR],\r\n];\r\n\r\nexport function relativeDate(\r\n  input_: number | Date,\r\n  reference_?: number | Date,\r\n  useShortVariant?: boolean = false,\r\n  useNumbersOnly?: boolean = false,\r\n): string {\r\n  let input = input_;\r\n  let reference = reference_;\r\n  if (input instanceof Date) {\r\n    input = input.getTime();\r\n  }\r\n  // flowlint-next-line sketchy-null-number:off\r\n  if (!reference) {\r\n    reference = new Date().getTime();\r\n  }\r\n  if (reference instanceof Date) {\r\n    reference = reference.getTime();\r\n  }\r\n\r\n  const delta = reference - input;\r\n  const formats = useShortVariant\r\n    ? shortFormats\r\n    : useNumbersOnly\r\n      ? longFormatsNumbers\r\n      : longFormats;\r\n  for (const [limit, relativeFormat, remainder] of formats) {\r\n    if (delta < limit) {\r\n      if (typeof remainder === 'number') {\r\n        return (\r\n          Math.round(delta / remainder) +\r\n          (useShortVariant ? '' : ' ') +\r\n          relativeFormat\r\n        );\r\n      } else {\r\n        return relativeFormat;\r\n      }\r\n    }\r\n  }\r\n\r\n  throw new Error('This should never be reached.');\r\n}\r\n\r\n/**\r\n * Count the number of occurrences of `char` in `str`.\r\n * `char` must be a string of length 1.\r\n */\r\nexport function countOccurrences(haystack: string, char: string) {\r\n  invariant(char.length === 1, 'char must be a string of length 1');\r\n\r\n  let count = 0;\r\n  const code = char.charCodeAt(0);\r\n  for (let i = 0; i < haystack.length; i++) {\r\n    if (haystack.charCodeAt(i) === code) {\r\n      count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n * shell-quote's parse allows pipe operators and comments.\r\n * Generally users don't care about this, so throw if we encounter any operators.\r\n */\r\nexport function shellParse(str: string, env?: Object): Array<string> {\r\n  const result = parse(str, env);\r\n  for (let i = 0; i < result.length; i++) {\r\n    if (typeof result[i] !== 'string') {\r\n      if (result[i].op != null) {\r\n        throw new Error(\r\n          `Unexpected operator \"${result[i].op}\" provided to shellParse`,\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `Unexpected comment \"${result[i].comment}\" provided to shellParse`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * shell-quote's parse allows pipe operators and comments and globs\r\n * We treat glob patterns as normal strings. For the other operators, we throw.\r\n */\r\nexport function shellParseWithGlobs(str: string, env?: Object): Array<string> {\r\n  const result = parse(str, env);\r\n  for (let i = 0; i < result.length; i++) {\r\n    if (typeof result[i] !== 'string') {\r\n      if (result[i].op === 'glob') {\r\n        result[i] = result[i].pattern;\r\n      } else if (result[i].op != null) {\r\n        throw new Error(\r\n          `Unexpected operator \"${result[i].op}\" provided to shellParse`,\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `Unexpected comment \"${result[i].comment}\" provided to shellParse`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Technically you can pass in { operator: string } here,\r\n * but we don't use that in most APIs.\r\n */\r\nexport function shellQuote(args: Array<string>): string {\r\n  return quote(args);\r\n}\r\n\r\nexport function removeCommonPrefix(a: string, b: string): [string, string] {\r\n  let i = 0;\r\n  while (a[i] === b[i] && i < a.length && i < b.length) {\r\n    i++;\r\n  }\r\n  return [a.substring(i), b.substring(i)];\r\n}\r\n\r\nexport function removeCommonSuffix(a: string, b: string): [string, string] {\r\n  let i = 0;\r\n  while (\r\n    a[a.length - 1 - i] === b[b.length - 1 - i] &&\r\n    i < a.length &&\r\n    i < b.length\r\n  ) {\r\n    i++;\r\n  }\r\n  return [a.substring(0, a.length - i), b.substring(0, b.length - i)];\r\n}\r\n\r\nexport function shorten(\r\n  str: string,\r\n  maxLength: number,\r\n  suffix?: string,\r\n): string {\r\n  return str.length < maxLength\r\n    ? str\r\n    : str.slice(0, maxLength) + (suffix || '');\r\n}\r\n\r\n/**\r\n * Like String.split, but only splits once.\r\n */\r\nexport function splitOnce(str: string, separator: string): [string, ?string] {\r\n  const index = str.indexOf(separator);\r\n  return index === -1\r\n    ? [str, null]\r\n    : [str.slice(0, index), str.slice(index + separator.length)];\r\n}\r\n\r\n/**\r\n * Indents each line by the specified number of characters.\r\n */\r\nexport function indent(\r\n  str: string,\r\n  level: number = 2,\r\n  char: string = ' ',\r\n): string {\r\n  return str.replace(/^([^\\n])/gm, char.repeat(level) + '$1');\r\n}\r\n\r\nexport function pluralize(noun: string, count: number) {\r\n  return count === 1 ? noun : noun + 's';\r\n}\r\n\r\nexport function capitalize(str: string): string {\r\n  return str.length === 0\r\n    ? str\r\n    : str\r\n        .charAt(0)\r\n        .toUpperCase()\r\n        .concat(str.slice(1));\r\n}\r\n\r\ntype MatchRange = [/* start */ number, /* end */ number];\r\n\r\n/**\r\n * Returns a list of ranges where needle occurs in haystack.\r\n * This will *not* return overlapping matches; i.e. the returned list will be disjoint.\r\n * This makes it easier to use for e.g. highlighting matches in a UI.\r\n */\r\nexport function getMatchRanges(\r\n  haystack: string,\r\n  needle: string,\r\n): Array<MatchRange> {\r\n  if (needle === '') {\r\n    // Not really a valid use.\r\n    return [];\r\n  }\r\n\r\n  const ranges = [];\r\n  let matchIndex = 0;\r\n  while ((matchIndex = haystack.indexOf(needle, matchIndex)) !== -1) {\r\n    const prevRange = ranges[ranges.length - 1];\r\n    if (prevRange != null && prevRange[1] === matchIndex) {\r\n      prevRange[1] += needle.length;\r\n    } else {\r\n      ranges.push([matchIndex, matchIndex + needle.length]);\r\n    }\r\n    matchIndex += needle.length;\r\n  }\r\n  return ranges;\r\n}\r\n\r\nexport function escapeMarkdown(markdown: string): string {\r\n  // Which characters can be backslash-escaped?\r\n  // markdown:   ! #    ()*+ -.        [\\] _`{ }   https://daringfireball.net/projects/markdown/syntax#backslash\r\n  // commonMark: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~  https://spec.commonmark.org/0.28/#backslash-escapes\r\n  // We'll only backslash-escape the lowest common denominator.\r\n  const slashEscaped = markdown.replace(/[#!()*+\\-.[\\\\\\]_`{}]/g, '\\\\$&');\r\n  // And HTML tags need to be &lt; &gt; escaped.\r\n  return slashEscaped.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n}\r\n\r\n// Originally copied from:\r\n// http://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url\r\n// But adopted to match `www.` urls as well as `https?` urls\r\n// and `!` as acceptable url piece.\r\n// Then optimized with https://www.npmjs.com/package/regexp-tree.\r\n// Added a single matching group for use with String.split.\r\n// eslint-disable-next-line max-len\r\nexport const URL_REGEX = /(https?:\\/\\/(?:www\\.)?[-\\w@:%.+~#=]{2,256}\\.[a-z]{2,6}\\b[-\\w@:%+.~#?&/=!]*|www\\.[-\\w@:%.+~#=]{2,256}\\.[a-z]{2,6}\\b[-\\w@:%+.~#?&/=!]*)/;\r\n\r\nexport const ELLIPSIS_CHAR = '\\u2026';\r\nexport const ZERO_WIDTH_SPACE = '\\u200B';\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n// NuclideUri's are either a local file path, or a URI\r\n// of the form nuclide://<host><path>\r\n//\r\n// This package creates, queries and decomposes NuclideUris.\r\n\r\nimport LspUri from 'vscode-uri';\r\n\r\nexport type NuclideUri = string;\r\n\r\ntype ParsedUrl = {\r\n  hostname: ?string,\r\n  path: string,\r\n};\r\n\r\ntype ParsedRemoteUrl = {\r\n  hostname: string,\r\n  path: string,\r\n};\r\n\r\ntype ParsedPath = {\r\n  root: string,\r\n  dir: string,\r\n  base: string,\r\n  ext: string,\r\n  name: string,\r\n};\r\n\r\nimport invariant from 'assert';\r\n// eslint-disable-next-line nuclide-internal/prefer-nuclide-uri\r\nimport pathModule from 'path';\r\n\r\nimport os from 'os';\r\nimport {maybeToString} from './string';\r\n\r\nconst ARCHIVE_SEPARATOR = '!';\r\nconst KNOWN_ARCHIVE_EXTENSIONS = [];\r\n\r\nconst REMOTE_PATH_URI_PREFIX = 'nuclide://';\r\n// TODO(ljw): following regex is incorrect. A URI scheme must start with\r\n// [A-Za-z] not [0-9_-]. Also, not all schemes require // after them.\r\nconst URI_PREFIX_REGEX = /^[A-Za-z0-9_-]+:\\/\\/.*/;\r\n\r\nfunction isRemote(uri: NuclideUri): boolean {\r\n  return uri.startsWith(REMOTE_PATH_URI_PREFIX);\r\n}\r\n\r\n// Atom often puts its URIs in places where we'd expect to see Nuclide URIs (or plain paths)\r\nfunction isAtomUri(uri: NuclideUri): boolean {\r\n  return uri.startsWith('atom://');\r\n}\r\n\r\nfunction isUri(uri: string): boolean {\r\n  return URI_PREFIX_REGEX.test(uri);\r\n}\r\n\r\nfunction isLocal(uri: NuclideUri): boolean {\r\n  return !isRemote(uri) && !isUri(uri) && !isAtomUri(uri);\r\n}\r\n\r\nfunction createRemoteUri(hostname: string, remotePath: string): string {\r\n  invariant(\r\n    remotePath != null && remotePath !== '',\r\n    'NuclideUri must include a path.',\r\n  );\r\n  return `nuclide://${hostname}${remotePath}`;\r\n}\r\n\r\nfunction isInArchive(uri: NuclideUri): boolean {\r\n  if (isAtomUri(uri) || uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return false;\r\n  }\r\n  for (\r\n    let i = uri.indexOf(ARCHIVE_SEPARATOR);\r\n    i >= 0;\r\n    i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)\r\n  ) {\r\n    if (_isArchiveSeparator(uri, i)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction ancestorOutsideArchive(uri: NuclideUri): NuclideUri {\r\n  for (\r\n    let i = uri.indexOf(ARCHIVE_SEPARATOR);\r\n    i >= 0;\r\n    i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)\r\n  ) {\r\n    if (_isArchiveSeparator(uri, i)) {\r\n      return uri.substring(0, i);\r\n    }\r\n  }\r\n  return uri;\r\n}\r\n\r\n/**\r\n * Parses valid Nuclide URIs into the hostname and path components.\r\n * Throws an Error on invalid URIs. Invalid URIs are:\r\n *  1) Any URI that does not start with 'nuclide://' protocol.\r\n *  2) A URI starting with 'nuclide://' that doesn't contain either a hostname or a path\r\n *\r\n * Everything that does not contain a '://' is assumed to be a local path. Both POSIX and Windows\r\n * paths are legal\r\n */\r\nfunction parse(uri: NuclideUri): ParsedUrl {\r\n  if (uri.startsWith(REMOTE_PATH_URI_PREFIX)) {\r\n    const hostAndPath = uri.substr(REMOTE_PATH_URI_PREFIX.length);\r\n    const hostSep = hostAndPath.indexOf('/');\r\n\r\n    invariant(\r\n      hostSep !== -1,\r\n      `Remote URIs must contain a hostname and a path. Failed to parse ${uri}`,\r\n    );\r\n\r\n    const hostname = hostAndPath.substr(0, hostSep);\r\n    invariant(\r\n      hostname !== '',\r\n      `Remote URIs must contain a hostname. Failed to parse ${uri}`,\r\n    );\r\n\r\n    const path = hostAndPath.substr(hostSep);\r\n    invariant(\r\n      !_endsWithArchiveSeparator(uri),\r\n      `Path cannot end with archive separator. Failed to parse ${uri}`,\r\n    );\r\n    return {hostname, path};\r\n  }\r\n\r\n  invariant(\r\n    !_endsWithArchiveSeparator(uri),\r\n    `Path cannot end with archive separator. Failed to parse ${uri}`,\r\n  );\r\n  return {hostname: null, path: uri};\r\n}\r\n\r\nfunction parseRemoteUri(remoteUri: NuclideUri): ParsedRemoteUrl {\r\n  if (!isRemote(remoteUri)) {\r\n    throw new Error('Expected remote uri. Got ' + remoteUri);\r\n  }\r\n  const parsedUri = parse(remoteUri);\r\n  invariant(\r\n    // flowlint-next-line sketchy-null-string:off\r\n    parsedUri.hostname,\r\n    `Remote Nuclide URIs must contain hostnames, '${maybeToString(\r\n      parsedUri.hostname,\r\n    )}' found while parsing '${remoteUri}'`,\r\n  );\r\n\r\n  // Explicitly copying object properties appeases Flow's \"maybe\" type handling. Using the `...`\r\n  // operator causes null/undefined errors, and `Object.assign` bypasses type checking.\r\n  return {\r\n    hostname: parsedUri.hostname,\r\n    path: parsedUri.path,\r\n  };\r\n}\r\n\r\nfunction getPath(uri: NuclideUri): string {\r\n  return parse(uri).path;\r\n}\r\n\r\nfunction getHostname(remoteUri: NuclideUri): string {\r\n  return parseRemoteUri(remoteUri).hostname;\r\n}\r\n\r\nfunction getHostnameOpt(remoteUri: ?NuclideUri): ?string {\r\n  if (remoteUri == null || !isRemote(remoteUri)) {\r\n    return null;\r\n  }\r\n\r\n  return getHostname(remoteUri);\r\n}\r\n\r\nfunction join(uri: NuclideUri, ...relativePath: Array<string>): NuclideUri {\r\n  return joinArray(uri, relativePath);\r\n}\r\n\r\nfunction joinArray(uri: NuclideUri, relativePath: Array<string>): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    relativePath.splice(0, 0, path);\r\n    _archiveEncodeArrayInPlace(uriPathModule, relativePath);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      createRemoteUri(hostname, uriPathModule.join.apply(null, relativePath)),\r\n    );\r\n  } else {\r\n    relativePath.splice(0, 0, uri);\r\n    _archiveEncodeArrayInPlace(uriPathModule, relativePath);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.join.apply(null, relativePath),\r\n    );\r\n  }\r\n}\r\n\r\nfunction archiveJoin(uri: NuclideUri, path: string): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  if (!KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext))) {\r\n    throw new Error(`Cannot archiveJoin with non-archive ${uri} and ${path}`);\r\n  }\r\n  return uri + ARCHIVE_SEPARATOR + path;\r\n}\r\n\r\nfunction normalize(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    const normal = _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.normalize(_archiveEncode(uriPathModule, path)),\r\n    );\r\n    return createRemoteUri(hostname, normal);\r\n  } else {\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.normalize(_archiveEncode(uriPathModule, uri)),\r\n    );\r\n  }\r\n}\r\n\r\nfunction normalizeDir(uri: NuclideUri): NuclideUri {\r\n  return ensureTrailingSeparator(normalize(uri));\r\n}\r\n\r\nfunction getParent(uri: NuclideUri): NuclideUri {\r\n  // TODO: Is this different than dirname?\r\n  return normalize(join(uri, '..'));\r\n}\r\n\r\nfunction relative(uri: NuclideUri, other: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  const remote = isRemote(uri);\r\n  if (\r\n    remote !== isRemote(other) ||\r\n    (remote && getHostname(uri) !== getHostname(other))\r\n  ) {\r\n    throw new Error(\r\n      `Cannot relative urls on different hosts: ${uri} and ${other}`,\r\n    );\r\n  }\r\n  const uriEncode = _archiveEncode(uriPathModule, remote ? getPath(uri) : uri);\r\n  const otherEncode = _archiveEncode(\r\n    uriPathModule,\r\n    remote ? getPath(other) : other,\r\n  );\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.relative(\r\n      _matchTrailingArchive(uriEncode, otherEncode),\r\n      _matchTrailingArchive(otherEncode, uriEncode),\r\n    ),\r\n  );\r\n}\r\n\r\nfunction basename(uri: NuclideUri, ext: string = ''): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.basename(_archiveEncode(uriPathModule, getPath(uri)), ext),\r\n  );\r\n}\r\n\r\nfunction dirname(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    return createRemoteUri(\r\n      hostname,\r\n      _archiveDecode(\r\n        uriPathModule,\r\n        uriPathModule.dirname(_archiveEncode(uriPathModule, path)),\r\n      ),\r\n    );\r\n  } else {\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.dirname(_archiveEncode(uriPathModule, uri)),\r\n    );\r\n  }\r\n}\r\n\r\nfunction extname(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.extname(_archiveEncode(uriPathModule, getPath(uri))),\r\n  );\r\n}\r\n\r\nfunction stripExtension(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const ext = extname(uri);\r\n  if (ext.length === 0) {\r\n    return uri;\r\n  }\r\n\r\n  return uri.slice(0, -1 * ext.length);\r\n}\r\n\r\nfunction _isWindowsPath(path: string): boolean {\r\n  return _pathModuleFor(path) === pathModule.win32;\r\n}\r\n\r\nfunction _getWindowsPathFromWindowsFileUri(uri: string): ?string {\r\n  const prefix = 'file://';\r\n  if (!uri.startsWith(prefix)) {\r\n    return null;\r\n  }\r\n\r\n  const path = uri.substr(prefix.length);\r\n  return _isWindowsPath(path) ? path : null;\r\n}\r\n\r\n/**\r\n * uri is either a file: uri, or a nuclide: uri.\r\n * must convert file: uri's to just a path for atom.\r\n *\r\n * Returns null if not a valid file: URI.\r\n */\r\nfunction uriToNuclideUri(uri: string): ?string {\r\n  // file:// URIs should never normally contain Windows backslashes:\r\n  // e.g. vscode-uri escapes C:\\abc to file:///c:/abc.\r\n  // This just handles any hacky users that simply prepended 'file://'.\r\n  // (vscode-uri does not know how to handle file://C:\\abc.)\r\n  const windowsPathFromUri = _getWindowsPathFromWindowsFileUri(uri);\r\n  if (windowsPathFromUri != null) {\r\n    return windowsPathFromUri;\r\n  }\r\n\r\n  const lspUri = LspUri.parse(uri);\r\n  if (lspUri.scheme === 'file' && lspUri.path) {\r\n    // only handle real files for now.\r\n    return lspUri.fsPath;\r\n  } else if (isRemote(uri)) {\r\n    return uri;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Converts local paths to file: URI's. Leaves remote URI's alone.\r\n */\r\nfunction nuclideUriToUri(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  if (isRemote(uri)) {\r\n    return uri;\r\n  } else {\r\n    return LspUri.file(uri).toString();\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if child is equal to, or is a proper descendant of parent.\r\n */\r\nfunction contains(parent: NuclideUri, child: NuclideUri): boolean {\r\n  _testForIllegalUri(parent);\r\n  _testForIllegalUri(child);\r\n\r\n  // Can't just do startsWith here. If this directory is \"www\" and you\r\n  // are trying to check \"www-base\", just using startsWith would return\r\n  // true, even though \"www-base\" is at the same level as \"Www\", not\r\n  // contained in it.\r\n  // Also, there's an issue with a trailing separator ambiguity. A path\r\n  // like /abc/ does contain /abc\r\n  // This function is used in some performance-sensitive parts, so we\r\n  // want to avoid doing unnecessary string copy, as those that would\r\n  // result from an ensureTrailingSeparator() call\r\n  //\r\n  // First we'll check the lengths.\r\n  // Then check startsWith. If so, then if the two path lengths are\r\n  // equal OR if the next character in the path to check is a path\r\n  // separator, then we know the checked path is in this path.\r\n\r\n  if (child.length < parent.length) {\r\n    // A strong indication of false\r\n    // It could be a matter of a trailing separator, though\r\n    if (child.length < parent.length - 1) {\r\n      // It must be more than just the separator\r\n      return false;\r\n    }\r\n\r\n    return (\r\n      parent.startsWith(child) &&\r\n      (endsWithSeparator(parent) || _isArchiveSeparator(child, parent.length))\r\n    );\r\n  }\r\n\r\n  if (!child.startsWith(parent)) {\r\n    return false;\r\n  }\r\n\r\n  if (endsWithSeparator(parent) || parent.length === child.length) {\r\n    return true;\r\n  }\r\n\r\n  const uriPathModule = _pathModuleFor(child);\r\n\r\n  return (\r\n    _isArchiveSeparator(child, parent.length) ||\r\n    child.slice(parent.length).startsWith(uriPathModule.sep)\r\n  );\r\n}\r\n\r\n/**\r\n * Filter an array of paths to contain only the collapsed root paths, e.g.\r\n * [a/b/c, a/, c/d/, c/d/e] collapses to [a/, c/d/]\r\n */\r\nfunction collapse(paths: Array<NuclideUri>): Array<NuclideUri> {\r\n  return paths.filter(p => !paths.some(fp => contains(fp, p) && fp !== p));\r\n}\r\n\r\nconst hostFormatters = [];\r\n\r\n// A formatter which may shorten hostnames.\r\n// Returns null if the formatter won't shorten the hostname.\r\nexport type HostnameFormatter = (uri: NuclideUri) => ?string;\r\n\r\n// Registers a host formatter for nuclideUriToDisplayString\r\nfunction registerHostnameFormatter(formatter: HostnameFormatter): IDisposable {\r\n  hostFormatters.push(formatter);\r\n  return {\r\n    dispose: () => {\r\n      const index = hostFormatters.indexOf(formatter);\r\n      if (index >= 0) {\r\n        hostFormatters.splice(index, 1);\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nfunction hostnameToDisplayHostname(hostname: string): string {\r\n  return hostFormatters.reduce((current, formatter) => {\r\n    const next = formatter(current);\r\n    if (next != null && next !== '') {\r\n      return next;\r\n    } else {\r\n      return current;\r\n    }\r\n  }, hostname);\r\n}\r\n\r\nfunction nuclideUriToDisplayHostname(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  return isRemote(uri) ? hostnameToDisplayHostname(getHostname(uri)) : uri;\r\n}\r\n\r\n/**\r\n * NuclideUris should never be shown to humans.\r\n * This function returns a human usable string.\r\n */\r\nfunction nuclideUriToDisplayString(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  return isRemote(uri)\r\n    ? `${nuclideUriToDisplayHostname(uri)}:${getPath(uri)}`\r\n    : uri;\r\n}\r\n\r\nfunction ensureTrailingSeparator(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (uri.endsWith(uriPathModule.sep)) {\r\n    return uri;\r\n  }\r\n\r\n  return uri + uriPathModule.sep;\r\n}\r\n\r\nfunction trimTrailingSeparator(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  let stripped = uri;\r\n\r\n  while (stripped.endsWith(uriPathModule.sep) && !isRoot(stripped)) {\r\n    stripped = stripped.slice(0, -1 * uriPathModule.sep.length);\r\n  }\r\n\r\n  return stripped;\r\n}\r\n\r\nfunction endsWithSeparator(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return uri.endsWith(uriPathModule.sep);\r\n}\r\n\r\nfunction endsWithEdenDir(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return uri.endsWith('.eden');\r\n}\r\n\r\nfunction isAbsolute(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  if (isRemote(uri)) {\r\n    return true;\r\n  } else {\r\n    const uriPathModule = _pathModuleFor(uri);\r\n    return uriPathModule.isAbsolute(uri);\r\n  }\r\n}\r\n\r\nfunction resolve(uri: NuclideUri, ...paths: Array<string>): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    paths.splice(0, 0, path);\r\n    _archiveEncodeArrayInPlace(uriPathModule, paths);\r\n    return createRemoteUri(\r\n      hostname,\r\n      _archiveDecode(uriPathModule, uriPathModule.resolve.apply(null, paths)),\r\n    );\r\n  } else {\r\n    paths.splice(0, 0, uri);\r\n    _archiveEncodeArrayInPlace(uriPathModule, paths);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.resolve.apply(null, paths),\r\n    );\r\n  }\r\n}\r\n\r\nfunction isHomeRelative(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return uri.startsWith('~');\r\n}\r\n\r\nfunction expandHomeDir(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n\r\n  // Do not expand non home relative uris\r\n  if (!uri.startsWith('~')) {\r\n    return uri;\r\n  }\r\n\r\n  // \"home\" on Windows is %UserProfile%. Note that Windows environment variables\r\n  // are NOT case sensitive, but process.env is a magic object that wraps GetEnvironmentVariableW\r\n  // on Windows, so asking for any case is expected to work.\r\n  const {HOME, UserProfile} = process.env;\r\n\r\n  const isWindows = !isRemote(uri) && os.platform() === 'win32';\r\n  const homePath = isWindows ? UserProfile : HOME;\r\n  invariant(homePath != null);\r\n\r\n  if (uri === '~') {\r\n    return homePath;\r\n  }\r\n\r\n  // Uris like ~abc should not be expanded\r\n  if (!uri.startsWith('~/') && (!isWindows || !uri.startsWith('~\\\\'))) {\r\n    return uri;\r\n  }\r\n\r\n  return pathModule.resolve(homePath, uri.replace('~', '.'));\r\n}\r\n\r\n/**\r\n * Splits a string containing local paths by an OS-specific path delimiter\r\n * Useful for splitting env variables such as PATH\r\n *\r\n * Since remote URI might contain the delimiter, only local paths are allowed.\r\n */\r\nfunction splitPathList(paths: string): Array<NuclideUri> {\r\n  invariant(\r\n    paths.indexOf(REMOTE_PATH_URI_PREFIX) < 0,\r\n    'Splitting remote URIs is not supported',\r\n  );\r\n  const uriPathModule = _pathModuleFor(paths);\r\n\r\n  return paths.split(uriPathModule.delimiter);\r\n}\r\n\r\n/**\r\n * Joins an array of local paths with an OS-specific path delimiter into a single string.\r\n * Useful for constructing env variables such as PATH\r\n *\r\n * Since remote URI might contain the delimiter, only local paths are allowed.\r\n */\r\nfunction joinPathList(paths: Array<NuclideUri>): string {\r\n  if (paths.length === 0) {\r\n    return '';\r\n  }\r\n\r\n  invariant(\r\n    paths.every(path => !isRemote(path)),\r\n    'Joining of remote URIs is not supported',\r\n  );\r\n\r\n  const uriPathModule = _pathModuleFor(paths[0]);\r\n  return paths.join(uriPathModule.delimiter);\r\n}\r\n\r\n/**\r\n * This function prepends the given relative path with a \"current-folder\" prefix\r\n * which is `./` on *nix and .\\ on Windows\r\n */\r\nfunction ensureLocalPrefix(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n\r\n  invariant(!isRemote(uri), 'Local prefix can not be added to a remote path');\r\n  invariant(\r\n    !isAbsolute(uri),\r\n    'Local prefix can not be added to an absolute path',\r\n  );\r\n\r\n  const localPrefix = `.${uriPathModule.sep}`;\r\n  if (uri.startsWith(localPrefix)) {\r\n    return uri;\r\n  }\r\n\r\n  return localPrefix + uri;\r\n}\r\n\r\nfunction isRoot(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return dirname(uri) === uri;\r\n}\r\n\r\nfunction parsePath(uri: NuclideUri): ParsedPath {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  const parsed = uriPathModule.parse(\r\n    _archiveEncode(uriPathModule, getPath(uri)),\r\n  );\r\n  return {\r\n    root: _archiveDecode(uriPathModule, parsed.root),\r\n    dir: _archiveDecode(uriPathModule, parsed.dir),\r\n    base: _archiveDecode(uriPathModule, parsed.base),\r\n    ext: _archiveDecode(uriPathModule, parsed.ext),\r\n    name: _archiveDecode(uriPathModule, parsed.name),\r\n  };\r\n}\r\n\r\nfunction pathSeparatorFor(uri: NuclideUri): string {\r\n  return _pathModuleFor(uri).sep;\r\n}\r\n\r\nfunction split(uri: NuclideUri): Array<string> {\r\n  const parts = [];\r\n  let current = uri;\r\n  let parent = dirname(current);\r\n\r\n  while (current !== parent) {\r\n    parts.push(basename(current));\r\n\r\n    current = parent;\r\n    parent = dirname(current);\r\n  }\r\n\r\n  if (isAbsolute(uri)) {\r\n    parts.push(parent);\r\n  }\r\n  parts.reverse();\r\n  return parts;\r\n}\r\n\r\nfunction hasKnownArchiveExtension(uri: NuclideUri): boolean {\r\n  return KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext));\r\n}\r\n\r\nfunction _pathModuleFor(uri: NuclideUri): typeof pathModule {\r\n  invariant(\r\n    !_endsWithArchiveSeparator(uri),\r\n    `Path cannot end with archive separator. Failed to determine path module for ${uri}`,\r\n  );\r\n  if (uri.startsWith(pathModule.posix.sep)) {\r\n    return pathModule.posix;\r\n  }\r\n  if (uri.indexOf('://') > -1) {\r\n    return pathModule.posix;\r\n  }\r\n  if (uri[1] === ':' && uri[2] === pathModule.win32.sep) {\r\n    return pathModule.win32;\r\n  }\r\n\r\n  // This little russian roulette here is blocking T29990593. I didn't\r\n  // clean it because we might see posix paths on windows and vice versa.\r\n  if (\r\n    uri.split(pathModule.win32.sep).length >\r\n    uri.split(pathModule.posix.sep).length\r\n  ) {\r\n    return pathModule.win32;\r\n  } else {\r\n    return pathModule.posix;\r\n  }\r\n}\r\n\r\n// Runs _archiveEncode in-place on array, and returns argument for convenience.\r\nfunction _archiveEncodeArrayInPlace(\r\n  uriPathModule: typeof pathModule,\r\n  array: Array<NuclideUri>,\r\n): Array<NuclideUri> {\r\n  array.forEach((uri, i, a) => (a[i] = _archiveEncode(uriPathModule, uri)));\r\n  return array;\r\n}\r\n\r\n// This adds a native separator after every archive separator\r\n// so that the native path handling code sees them.\r\nfunction _archiveEncode(\r\n  uriPathModule: typeof pathModule,\r\n  uri: NuclideUri,\r\n): NuclideUri {\r\n  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return uri;\r\n  }\r\n  return KNOWN_ARCHIVE_EXTENSIONS.reduce(\r\n    (acc, ext) =>\r\n      acc.replace(\r\n        `${ext}${ARCHIVE_SEPARATOR}`,\r\n        `${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`,\r\n      ),\r\n    uri,\r\n  );\r\n}\r\n\r\n// This is the inverse of `encodeArchiveSeparators()` to put things\r\n// back after the native path handler has run.\r\nfunction _archiveDecode(\r\n  uriPathModule: typeof pathModule,\r\n  uri: NuclideUri,\r\n): NuclideUri {\r\n  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return uri;\r\n  }\r\n  return _trimArchiveSuffix(\r\n    KNOWN_ARCHIVE_EXTENSIONS.reduce(\r\n      (acc, ext) =>\r\n        acc.replace(\r\n          `${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`,\r\n          `${ext}${ARCHIVE_SEPARATOR}`,\r\n        ),\r\n      uri,\r\n    ),\r\n  );\r\n}\r\n\r\n// When working with encoded uri's, the archive separator is part of the name\r\n// so we can manipulate paths with uriPathModule.  However, in `relative` if\r\n// one uri contains the other, we need the names seen by uriPathModule to agree\r\n// on whether there is an archive separator or not.  E.g. if we have:\r\n//    /etc/file.zip\r\n//    /etc/file.zip!abc\r\n// When we encode these, we get:\r\n//    /etc/file.zip\r\n//    /etc/file.zip!/abc\r\n// We need to add a trailing '!' to the first one so uriPathModule can see that\r\n// the first contains the second.\r\nfunction _matchTrailingArchive(uri: string, other: string): string {\r\n  if (\r\n    uri.length < other.length &&\r\n    other.startsWith(uri) &&\r\n    _isArchiveSeparator(other, uri.length)\r\n  ) {\r\n    return uri + ARCHIVE_SEPARATOR;\r\n  } else {\r\n    return uri;\r\n  }\r\n}\r\n\r\nfunction _trimArchiveSuffix(path: string): string {\r\n  if (_endsWithArchiveSeparator(path)) {\r\n    return path.substring(0, path.length - ARCHIVE_SEPARATOR.length);\r\n  } else {\r\n    return path;\r\n  }\r\n}\r\n\r\nfunction _endsWithArchiveSeparator(path: string): boolean {\r\n  return _isArchiveSeparator(path, path.length - 1);\r\n}\r\n\r\nfunction _isArchiveSeparator(path: string, index: number): boolean {\r\n  return (\r\n    path.length > index &&\r\n    path.charAt(index) === ARCHIVE_SEPARATOR &&\r\n    KNOWN_ARCHIVE_EXTENSIONS.some(ext => {\r\n      const extStart = index - ext.length;\r\n      return path.indexOf(ext, extStart) === extStart;\r\n    })\r\n  );\r\n}\r\n\r\nfunction _testForIllegalUri(uri: ?NuclideUri): void {\r\n  if (uri != null) {\r\n    if (_endsWithArchiveSeparator(uri)) {\r\n      throw new Error(\r\n        `Path operation invoked on URI ending with ${ARCHIVE_SEPARATOR}: ${uri}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nconst NUCLIDE_URI_TYPE_NAME = 'NuclideUri';\r\n\r\n// If mustBeRemote is present then remote-ness must match, otherwise remote-ness\r\n// is ignored.\r\nfunction validate(uri: NuclideUri, mustBeRemote?: boolean): void {\r\n  // Be a little extra paranoid to catch places where the type system may be weak.\r\n  invariant(uri != null, 'Unexpected null NuclideUri');\r\n  invariant(\r\n    typeof uri === 'string',\r\n    `Unexpected NuclideUri type: ${String(uri)}`,\r\n  );\r\n\r\n  if (isRemote(uri)) {\r\n    parse(uri);\r\n    invariant(mustBeRemote !== false, 'Expected remote NuclideUri');\r\n  } else {\r\n    invariant(uri !== '', 'NuclideUri must contain a non-empty path');\r\n    invariant(mustBeRemote !== true, 'Expected local NuclideUri');\r\n  }\r\n}\r\n\r\nconst IMAGE_EXTENSIONS = new Set([\r\n  '.bmp',\r\n  '.gif',\r\n  '.ico',\r\n  '.jpeg',\r\n  '.jpg',\r\n  '.png',\r\n  '.webp',\r\n]);\r\n\r\n/**\r\n * Returns true if this filename looks like an image that Nuclide can open; otherwise false.\r\n */\r\nfunction looksLikeImageUri(uri: NuclideUri): boolean {\r\n  const ext = extname(uri).toLowerCase();\r\n  return IMAGE_EXTENSIONS.has(ext);\r\n}\r\n\r\nexport default {\r\n  basename,\r\n  dirname,\r\n  extname,\r\n  stripExtension,\r\n  isRemote,\r\n  isLocal,\r\n  createRemoteUri,\r\n  isInArchive,\r\n  ancestorOutsideArchive,\r\n  parse,\r\n  parseRemoteUri,\r\n  validate,\r\n  getPath,\r\n  getHostname,\r\n  getHostnameOpt,\r\n  join,\r\n  joinArray,\r\n  archiveJoin,\r\n  relative,\r\n  looksLikeImageUri,\r\n  normalize,\r\n  normalizeDir,\r\n  getParent,\r\n  uriToNuclideUri,\r\n  nuclideUriToUri,\r\n  contains,\r\n  collapse,\r\n  nuclideUriToDisplayString,\r\n  nuclideUriToDisplayHostname,\r\n  hostnameToDisplayHostname,\r\n  registerHostnameFormatter,\r\n  ensureTrailingSeparator,\r\n  trimTrailingSeparator,\r\n  endsWithSeparator,\r\n  endsWithEdenDir,\r\n  isAbsolute,\r\n  isHomeRelative,\r\n  resolve,\r\n  expandHomeDir,\r\n  splitPathList,\r\n  joinPathList,\r\n  ensureLocalPrefix,\r\n  isRoot,\r\n  parsePath,\r\n  split,\r\n  pathSeparatorFor,\r\n  hasKnownArchiveExtension,\r\n  ARCHIVE_SEPARATOR,\r\n  KNOWN_ARCHIVE_EXTENSIONS,\r\n  NUCLIDE_URI_TYPE_NAME,\r\n};\r\n\r\nexport const __TEST__ = {\r\n  _pathModuleFor,\r\n};\r\n","import { Range, CompositeDisposable, TextEditor, TextChange, Disposable, BufferStoppedChangingEvent } from \"atom\"\nimport type { TextEdit, BusySignalService } from \"atom-ide-base\"\nimport type {\n  FileCodeFormatProvider,\n  OnSaveCodeFormatProvider,\n  OnTypeCodeFormatProvider,\n  RangeCodeFormatProvider,\n} from \"./types\"\n\nimport { getFormatOnSave, getFormatOnType } from \"./config\"\nimport { getLogger } from \"log4js\"\nimport { ProviderRegistry } from \"atom-ide-base/commons-atom/ProviderRegistry\"\nimport { applyTextEditsToBuffer } from \"@atom-ide-community/nuclide-commons-atom/text-edit\"\nimport nuclideUri from \"@atom-ide-community/nuclide-commons/nuclideUri\"\nimport { debounce } from \"./utils\"\n\n// Save events are critical, so don't allow providers to block them.\nexport const SAVE_TIMEOUT = 500\n\nexport default class CodeFormatManager {\n  _subscriptions: CompositeDisposable\n  _rangeProviders: ProviderRegistry<RangeCodeFormatProvider>\n  _fileProviders: ProviderRegistry<FileCodeFormatProvider>\n  _onTypeProviders: ProviderRegistry<OnTypeCodeFormatProvider>\n  _onSaveProviders: ProviderRegistry<OnSaveCodeFormatProvider>\n  _busySignalService: BusySignalService | undefined\n\n  constructor() {\n    /**\n     * Subscribe to all formatting events (commands, saves, edits) and dispatch formatters as necessary. By handling all\n     * events in a central location, we ensure that no buffer runs into race conditions with simultaneous formatters.\n     */\n    this._subscriptions = new CompositeDisposable(\n      // Events from the explicit Atom command.\n      atom.commands.add(\"atom-text-editor\", \"code-format:format-code\", async (event) => {\n        const editorElement = event.currentTarget\n        const editor = editorElement.getModel()\n        // Make sure we halt everything when the editor gets destroyed.\n        const edits = await this._formatCodeInTextEditor(editor)\n        try {\n          const success = applyTextEditsToBuffer(editor.getBuffer(), edits) as boolean\n          if (!success) {\n            throw new Error(\"No code formatting providers found!\")\n          }\n        } catch (err) {\n          atom.notifications.addError(`Failed to format code: ${err.message}`, {\n            detail: err.detail,\n          })\n        }\n      }),\n\n      atom.workspace.observeTextEditors((editor) => {\n        const editorSubs = new CompositeDisposable(\n          // Format on typing in the editor\n          editor.getBuffer().onDidStopChanging(async (event) => {\n            if (!getFormatOnType()) {\n              return\n            }\n            try {\n              await this._formatCodeOnTypeInTextEditor(editor, event)\n            } catch (err) {\n              getLogger(\"code-format\").warn(\"Failed to format code on type:\", err)\n            }\n          }),\n          // Format on save\n          editor.onDidSave(\n            debounce(async () => {\n              const edits = await this._formatCodeOnSaveInTextEditor(editor)\n              const success = applyTextEditsToBuffer(editor.getBuffer(), edits) as boolean\n              if (!success) {\n                throw new Error(\"No code formatting providers found!\")\n              }\n            }, SAVE_TIMEOUT)\n          )\n        )\n        // Make sure we halt everything when the editor gets destroyed.\n        // We need to capture when editors are about to be destroyed in order to\n        // interrupt any pending formatting operations. (Otherwise, we may end up\n        // attempting to save a destroyed editor!)\n        editor.onDidDestroy(() => editorSubs.dispose())\n      })\n    )\n\n    this._rangeProviders = new ProviderRegistry()\n    this._fileProviders = new ProviderRegistry()\n    this._onTypeProviders = new ProviderRegistry()\n    this._onSaveProviders = new ProviderRegistry()\n  }\n\n  // Return the text edits used to format code in the editor specified.\n  async _formatCodeInTextEditor(\n    editor: TextEditor,\n    selectionRange: Range = editor.getSelectedBufferRange()\n  ): Promise<Array<TextEdit>> {\n    const buffer = editor.getBuffer()\n    const bufferRange = buffer.getRange()\n\n    let formatRange: Range\n    if (selectionRange.isEmpty()) {\n      // If no selection is done, then, the whole file is wanted to be formatted.\n      formatRange = bufferRange\n    } else {\n      const { start: selectionStart, end: selectionEnd } = selectionRange\n      // Format selections should start at the beginning of the line,\n      // and include the last selected line end.\n      // (If the user has already selected complete rows, then depending on how they\n      // did it, their caret might be either (1) at the end of their last selected line\n      // or (2) at the first column of the line AFTER their selection. In both cases\n      // we snap the formatRange to end at the first column of the line after their\n      // selection.)\n      formatRange = new Range(\n        [selectionStart.row, 0],\n        selectionEnd.column === 0 ? selectionEnd : [selectionEnd.row + 1, 0]\n      )\n    }\n\n    // range providers\n    const rangeProviders = [...this._rangeProviders.getAllProvidersForEditor(editor)]\n    const allRangeEdits = await this._reportBusy(\n      editor,\n      Promise.all(rangeProviders.map((p) => p.formatCode(editor, formatRange)))\n    )\n    const rangeEdits = allRangeEdits.filter((edits) => edits.length > 0)\n\n    // file providers\n    const fileProviders = [...this._fileProviders.getAllProvidersForEditor(editor)]\n    const allFileEdits = await this._reportBusy(\n      editor,\n      Promise.all(fileProviders.map((p) => p.formatEntireFile(editor, formatRange)))\n    )\n    const nonNullFileEdits = allFileEdits.filter((result) => result !== null && result !== undefined) as {\n      newCursor?: number\n      formatted: string\n    }[]\n    const contents = editor.getText()\n    const editorRange = editor.getBuffer().getRange()\n    const fileEdits = nonNullFileEdits.map(({ formatted }) => [\n      {\n        oldRange: editorRange,\n        newText: formatted,\n        oldText: contents,\n      } as TextEdit,\n    ])\n\n    // merge edits\n    // When formatting the entire file, prefer file-based providers.\n    const preferFileEdits = formatRange.isEqual(bufferRange)\n    const edits = preferFileEdits ? fileEdits.concat(rangeEdits) : rangeEdits.concat(fileEdits)\n    return edits.flat() // TODO or [0]?\n  }\n\n  async _formatCodeOnTypeInTextEditor(\n    editor: TextEditor,\n    { changes }: BufferStoppedChangingEvent\n  ): Promise<Array<TextEdit>> {\n    // Don't try to format changes with multiple cursors.\n    if (changes.length !== 1) {\n      return []\n    }\n    // if no provider return immediately\n    const providers = [...this._onTypeProviders.getAllProvidersForEditor(editor)]\n    if (providers.length === 0) {\n      return []\n    }\n    const event = changes[0]\n    // This also ensures the non-emptiness of event.newText for below.\n    if (!shouldFormatOnType(event)) {\n      return []\n    }\n    // In the case of bracket-matching, we use the last character because that's\n    // the character that will usually cause a reformat (i.e. `}` instead of `{`).\n    const character = event.newText[event.newText.length - 1]\n\n    const contents = editor.getText()\n    const cursorPosition = editor.getCursorBufferPosition().copy()\n\n    // The bracket-matching package basically overwrites\n    //\n    //     editor.insertText('{');\n    //\n    // with\n    //\n    //     editor.insertText('{}');\n    //     cursor.moveLeft();\n    //\n    // We want to wait until the cursor has actually moved before we issue a\n    // format request, so that we format at the right position (and potentially\n    // also let any other event handlers have their go).\n    const allEdits = await Promise.all(\n      providers.map((p) => p.formatAtPosition(editor, editor.getCursorBufferPosition(), character))\n    )\n    const firstNonEmptyIndex = allEdits.findIndex((edits) => edits.length > 0)\n    if (firstNonEmptyIndex === -1) {\n      return []\n    } else {\n      const edits = allEdits[firstNonEmptyIndex]\n      const provider = providers[firstNonEmptyIndex]\n      _checkContentsAreSame(contents, editor.getText())\n      // Note that this modification is not in a transaction, so it applies as a\n      // separate editing event than the character typing. This means that you\n      // can undo just the formatting by attempting to undo once, and then undo\n      // your actual code by undoing again.\n      if (!applyTextEditsToBuffer(editor.getBuffer(), edits)) {\n        throw new Error(\"Could not apply edits to text buffer.\")\n      }\n\n      if (provider.keepCursorPosition) {\n        editor.setCursorBufferPosition(cursorPosition)\n      }\n      return edits\n    }\n  }\n\n  async _formatCodeOnSaveInTextEditor(editor: TextEditor): Promise<TextEdit[]> {\n    const saveProviders = [...this._onSaveProviders.getAllProvidersForEditor(editor)]\n    if (saveProviders.length > 0) {\n      const allEdits = await this._reportBusy(\n        editor,\n        Promise.all(saveProviders.map((p) => p.formatOnSave(editor))),\n        false\n      )\n      const edits = allEdits.filter((edits) => edits.length > 0)\n      return edits.flat()\n    } else if (getFormatOnSave(editor)) {\n      return this._formatCodeInTextEditor(editor, editor.getBuffer().getRange())\n    }\n    return []\n  }\n\n  _reportBusy<T>(editor: TextEditor, promise: Promise<T>, revealTooltip: boolean = true): Promise<T> {\n    const busySignalService = this._busySignalService\n    if (busySignalService !== undefined) {\n      const path = editor.getPath()\n      const displayPath = path !== undefined ? nuclideUri.basename(path) : \"<untitled>\"\n      return busySignalService.reportBusyWhile(`Formatting code in ${displayPath}`, () => promise, { revealTooltip })\n    }\n    return promise\n  }\n\n  addRangeProvider(provider: RangeCodeFormatProvider): Disposable {\n    return this._rangeProviders.addProvider(provider)\n  }\n\n  addFileProvider(provider: FileCodeFormatProvider): Disposable {\n    return this._fileProviders.addProvider(provider)\n  }\n\n  addOnTypeProvider(provider: OnTypeCodeFormatProvider): Disposable {\n    return this._onTypeProviders.addProvider(provider)\n  }\n\n  addOnSaveProvider(provider: OnSaveCodeFormatProvider): Disposable {\n    return this._onSaveProviders.addProvider(provider)\n  }\n\n  consumeBusySignal(busySignalService: BusySignalService): Disposable {\n    this._busySignalService = busySignalService\n    return new Disposable(() => {\n      this._busySignalService = undefined\n    })\n  }\n\n  dispose() {\n    this._subscriptions.dispose()\n  }\n}\n\nfunction shouldFormatOnType(event: TextChange): boolean {\n  // There's not a direct way to figure out what caused this edit event. There\n  // are three cases that we want to pay attention to:\n  //\n  // 1) The user typed a character.\n  // 2) The user typed a character, and bracket-matching kicked in, causing\n  //    there to be two characters typed.\n  // 3) The user pasted a string.\n  //\n  // We only want to trigger autoformatting in the first two cases. However,\n  // we can only look at what new string was inserted, and not what actually\n  // caused the event, so we just use some heuristics to determine which of\n  // these the event probably was depending on what was typed. This means, for\n  // example, we may issue spurious format requests when the user pastes a\n  // single character, but this is acceptable.\n  if (event.oldText !== \"\") {\n    // We either just deleted something or replaced a selection. For the time\n    // being, we're not going to issue a reformat in that case.\n    return false\n  } else if (event.newText === \"\") {\n    // Not sure what happened here; why did we get an event in this case? Bail\n    // for safety.\n    return false\n  } else if (event.newText.length > 1 && !isBracketPair(event.newText)) {\n    return false\n  }\n  return true\n}\n\n/**\n * We can't tell the difference between a paste and the bracket-matcher package inserting an extra bracket, so we just\n * assume that any pair of brackets that bracket-matcher recognizes was a pair matched by the package.\n */\nfunction isBracketPair(typedText: string): boolean {\n  if (atom.packages.getActivePackage(\"bracket-matcher\") === undefined) {\n    return false\n  }\n  const validBracketPairs = atom.config.get(\"bracket-matcher.autocompleteCharacters\") as Array<string>\n  return validBracketPairs.includes(typedText)\n}\n\n// Checks whether contents are same in the buffer post-format, throwing if\n// anything has changed.\nfunction _checkContentsAreSame(before: string, after: string): void {\n  if (before !== after) {\n    throw new Error(\"The file contents were changed before formatting was complete.\")\n  }\n}\n","import type { TextEditor } from \"atom\"\n\nexport function getFormatOnSave(editor: TextEditor): boolean {\n  return atom.config.get(\"atom-ide-code-format.formatOnSave\", {\n    scope: editor.getRootScopeDescriptor(),\n  }) as boolean\n}\n\nexport function getFormatOnType(): boolean {\n  return atom.config.get(\"atom-ide-code-format.formatOnType\") as boolean\n}\n","/** A faster vresion of lodash.debounce */\n/* eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any */\nexport function debounce<T extends (...args: any[]) => void>(func: T, wait: number): T {\n  let timeoutId: NodeJS.Timeout | undefined\n  // @ts-ignore\n  return (...args: Parameters<T>) => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId)\n    }\n    timeoutId = setTimeout(() => {\n      func(...args)\n    }, wait)\n  }\n}\n","import type { Disposable } from \"atom\"\nimport type { BusySignalService } from \"atom-ide-base\"\nimport type {\n  RangeCodeFormatProvider,\n  FileCodeFormatProvider,\n  OnTypeCodeFormatProvider,\n  OnSaveCodeFormatProvider,\n} from \"./types\"\n\nimport CodeFormatManager from \"./CodeFormatManager\"\n\nexport { default as config } from \"./config.json\"\n\nlet codeFormatManager: CodeFormatManager\n\nexport function activate() {\n  codeFormatManager = new CodeFormatManager()\n}\n\nexport function consumeRangeProvider(provider: RangeCodeFormatProvider): Disposable {\n  return codeFormatManager.addRangeProvider(provider)\n}\n\nexport function consumeFileProvider(provider: FileCodeFormatProvider): Disposable {\n  return codeFormatManager.addFileProvider(provider)\n}\n\nexport function consumeOnTypeProvider(provider: OnTypeCodeFormatProvider): Disposable {\n  return codeFormatManager.addOnTypeProvider(provider)\n}\n\nexport function consumeOnSaveProvider(provider: OnSaveCodeFormatProvider): Disposable {\n  return codeFormatManager.addOnSaveProvider(provider)\n}\n\nexport function consumeBusySignal(busySignalService: BusySignalService): Disposable {\n  return codeFormatManager.consumeBusySignal(busySignalService)\n}\n\nexport function deactivate() {\n  codeFormatManager.dispose()\n}\n\n// TODO remove\nexport { consumeLegacyProvider } from \"./legacy-provider\"\n","// TODO Remove\n\nimport type { Disposable } from \"atom\"\nimport { consumeRangeProvider, consumeFileProvider, consumeOnSaveProvider, consumeOnTypeProvider } from \"./main\"\nimport type { CodeFormatProvider } from \"./types\"\n\nexport function consumeLegacyProvider(provider: CodeFormatProvider): Disposable {\n  // Legacy providers used `selector` / `inclusionPriority`.\n  // @ts-ignore legacy API compatability.\n  provider.grammarScopes =\n    provider.grammarScopes ||\n    // @ts-ignore\n    (provider.selector != null ? provider.selector.split(\", \") : null)\n  provider.priority =\n    provider.priority != null\n      ? provider.priority\n      : // @ts-ignore\n      provider.inclusionPriority != null\n      ? // @ts-ignore\n        provider.inclusionPriority\n      : 0\n  if (\"formatCode\" in provider) {\n    return consumeRangeProvider(provider)\n  } else if (\"formatEntireFile\" in provider) {\n    return consumeFileProvider(provider)\n  } else if (\"formatAtPosition\" in provider) {\n    return consumeOnTypeProvider(provider)\n  } else if (\"formatOnSave\" in provider) {\n    return consumeOnSaveProvider(provider)\n  }\n  throw new Error(\"Invalid code format provider\")\n}\n"],"names":["ProviderRegistry_2","constructor","this","providers","addProvider","provider","index","findIndex","p","priority","push","splice","atom_1","removeProvider","indexOf","getProviderForEditor","editor","grammar","getGrammar","scopeName","findProvider","getAllProvidersForEditor","findAllProviders","grammarScopes","UniversalDisposable","teardowns","disposed","Set","length","add","Error","i","assertTeardown","addUntilDestroyed","destructible","destroyDisposable","onDidDestroy","dispose","remove","teardown","delete","forEach","unsubscribe","destroy","clear","TypeError","emitter","eventName","callback","addListener","removeListener","fn","Observable","create","observer","next","bind","path","atom","workspace","getTextEditors","getPath","buffer","getBuffer","getViewOfEditor","getScrollTop","position","scrollTop","setCursorBufferPosition","autoscroll","setScrollTop","defer","cursor","getCursors","merge","of","getBufferPosition","onDidChangePosition","map","event","newBufferPosition","take","textEditor","readOnlyExceptions","getElement","setAttribute","removeAttribute","enforcedSoftWrap","setSoftWrapped","onDidChangeSoftWrapped","softWrapped","process","nextTick","isDestroyed","item","TextEditor","textEditorElement","bufferLineNumber","getModel","pixelPositionForBufferPosition","top","getLineHeightInPixels","clientHeight","Math","max","focus","views","getView","async","file","options","center","moveCursor","activatePane","activateItem","line","column","pending","currentEditor","getActiveTextEditor","paneContainer","paneContainerForItem","activate","goToLocationInEditor","open","initialLine","initialColumn","searchAllPanes","tmp","captureStackTrace","error","scrollToBufferPosition","goToLocationSubject","Subject","changes","paths","Array","from","keys","checkpoints","Promise","all","createCheckpoint","allOkay","reduce","successSoFar","edits","get","applyTextEdits","checkPoint","revertToCheckpoint","applySortedTextEditsToBuffer","sortEdits","sortedEdits","oldRange","end","isGreaterThan","start","editsOverlap","warn","isEqual","getRange","oldText","getText","setTextViaDiff","newText","checkpoint","applyToBuffer","groupChangesSinceCheckpoint","edit","row","lineLength","lineLengthForRow","getTextInRange","setTextInRange","sort","e1","i1","e2","i2","compare","v","undefined","require","exports","_encode","ch","charCodeAt","toString","toUpperCase","encodeURIComponent2","str","encodeURIComponent","replace","encodeNoop","Object","defineProperty","value","isWindows","URI","_scheme","_empty","_authority","_path","_query","_fragment","_formatted","_fsPath","isUri","thing","authority","fragment","query","scheme","prototype","enumerable","configurable","_driveLetterPath","test","toLowerCase","substr","with","change","ret","_validate","parse","data","_parseComponents","decodeURIComponent","_slash","idx","substring","match","_regexp","exec","components","_schemePattern","_singleSlashStart","_doubleSlashStart","skipEncoding","_asFormatted","uri","encoder","parts","m","_upperCaseDrive","lastIdx","join","toJSON","res","fsPath","external","$mid","revive","result","default","platform","navigator","userAgent","factory","module","xs","s","op","String","CONTROL","BAREWORD","TOKEN","pow","random","env","opts","mapped","chunker","RegExp","filter","Boolean","commented","j","charAt","comment","slice","SQ","DQ","DS","BS","escape","quote","esc","out","isGlob","len","c","parseEnvVar","pattern","varend","varname","getVar","prev","arg","concat","_","pre","key","r","JSON","stringify","acc","split","x","name","message","stack","input_","reference_","useShortVariant","useNumbersOnly","input","reference","Date","getTime","delta","formats","shortFormats","longFormatsNumbers","longFormats","limit","relativeFormat","remainder","round","haystack","char","count","code","args","a","b","maxLength","suffix","separator","level","repeat","noun","needle","ranges","matchIndex","prevRange","markdown","HOUR","DAY","WEEK","YEAR","MONTH","Number","MAX_VALUE","KNOWN_ARCHIVE_EXTENSIONS","URI_PREFIX_REGEX","isRemote","startsWith","isAtomUri","createRemoteUri","hostname","remotePath","hostAndPath","hostSep","_endsWithArchiveSeparator","parseRemoteUri","remoteUri","parsedUri","getHostname","relativePath","joinArray","_testForIllegalUri","uriPathModule","_pathModuleFor","_archiveEncodeArrayInPlace","_archiveDecode","apply","normalize","_archiveEncode","basename","ext","dirname","extname","_getWindowsPathFromWindowsFileUri","prefix","pathModule","win32","_isWindowsPath","contains","parent","child","endsWithSeparator","_isArchiveSeparator","sep","hostFormatters","hostnameToDisplayHostname","current","formatter","nuclideUriToDisplayHostname","ensureTrailingSeparator","endsWith","isAbsolute","isRoot","posix","array","_matchTrailingArchive","other","some","extStart","IMAGE_EXTENSIONS","stripExtension","isLocal","isInArchive","ancestorOutsideArchive","validate","mustBeRemote","getHostnameOpt","archiveJoin","relative","remote","uriEncode","otherEncode","looksLikeImageUri","has","normalizeDir","getParent","uriToNuclideUri","windowsPathFromUri","lspUri","LspUri","nuclideUriToUri","collapse","fp","nuclideUriToDisplayString","registerHostnameFormatter","trimTrailingSeparator","stripped","endsWithEdenDir","isHomeRelative","resolve","expandHomeDir","HOME","UserProfile","os","homePath","splitPathList","delimiter","joinPathList","every","ensureLocalPrefix","localPrefix","parsePath","parsed","root","dir","base","reverse","pathSeparatorFor","hasKnownArchiveExtension","ARCHIVE_SEPARATOR","NUCLIDE_URI_TYPE_NAME","__TEST__","CodeFormatManager","_subscriptions","CompositeDisposable","commands","currentTarget","_formatCodeInTextEditor","applyTextEditsToBuffer","err","notifications","addError","detail","observeTextEditors","editorSubs","onDidStopChanging","config","_formatCodeOnTypeInTextEditor","getLogger","onDidSave","func","wait","timeoutId","clearTimeout","setTimeout","debounce","_formatCodeOnSaveInTextEditor","_rangeProviders","ProviderRegistry","_fileProviders","_onTypeProviders","_onSaveProviders","selectionRange","getSelectedBufferRange","bufferRange","formatRange","isEmpty","selectionStart","selectionEnd","Range","rangeProviders","rangeEdits","_reportBusy","formatCode","fileProviders","nonNullFileEdits","formatEntireFile","contents","editorRange","fileEdits","formatted","flat","typedText","packages","getActivePackage","includes","isBracketPair","shouldFormatOnType","character","cursorPosition","getCursorBufferPosition","copy","allEdits","formatAtPosition","firstNonEmptyIndex","before","after","_checkContentsAreSame","keepCursorPosition","saveProviders","formatOnSave","scope","getRootScopeDescriptor","getFormatOnSave","promise","revealTooltip","busySignalService","_busySignalService","displayPath","nuclideUri","reportBusyWhile","addRangeProvider","addFileProvider","addOnTypeProvider","addOnSaveProvider","consumeBusySignal","Disposable","codeFormatManager","consumeRangeProvider","consumeFileProvider","consumeOnTypeProvider","consumeOnSaveProvider","selector","inclusionPriority"],"mappings":"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"}