{"version":3,"file":"main.js","sources":["../node_modules/nuclide/nuclide-commons/getDisplayName.js","../node_modules/nuclide/nuclide-commons/UniversalDisposable.js","../node_modules/nuclide/nuclide-commons/promise.js","../node_modules/nuclide/nuclide-commons/performanceNow.js","../node_modules/nuclide/nuclide-commons/analytics.js","../node_modules/nuclide/nuclide-commons-atom/ProviderRegistry.js","../node_modules/nuclide/nuclide-commons/event.js","../node_modules/nuclide/nuclide-commons-atom/text-editor.js","../node_modules/nuclide/nuclide-commons-atom/go-to-location.js","../node_modules/nuclide/nuclide-commons-atom/text-edit.js","../node_modules/nuclide/nuclide-commons-atom/FileEventHandlers.js","../node_modules/atom-ide-base/src-commons-atom/ProviderRegistry.ts","../node_modules/vscode-uri/lib/index.js","../node_modules/nuclide/nuclide-commons/_shell-quote.js","../node_modules/nuclide/nuclide-commons/string.js","../node_modules/nuclide/nuclide-commons/nuclideUri.js","../../src/CodeFormatManager.ts","../../src/config.ts","../../src/main.ts","../../src/legacy-provider.ts"],"sourcesContent":["/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nexport default function getDisplayName(\r\n  functionOrClass: Function | Class<*>,\r\n): string {\r\n  if (\r\n    typeof functionOrClass.displayName === 'string' &&\r\n    functionOrClass.displayName !== ''\r\n  ) {\r\n    return functionOrClass.displayName;\r\n  } else if (\r\n    typeof functionOrClass.name === 'string' &&\r\n    functionOrClass.name !== ''\r\n  ) {\r\n    return functionOrClass.name;\r\n  }\r\n\r\n  return 'Unknown';\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nexport type IDestructible = {\r\n  destroy(): void,\r\n  onDidDestroy(callback: () => mixed): IDisposable,\r\n};\r\n\r\nexport type AnyTeardown =\r\n  | (() => mixed)\r\n  | rxjs$ISubscription\r\n  | IDisposable\r\n  | IDestructible;\r\n\r\n/**\r\n * Like a CompositeDisposable, but in addition to Disposable instances it can\r\n * also accept plain functions and Rx subscriptions.\r\n */\r\nexport default class UniversalDisposable {\r\n  disposed: boolean;\r\n  teardowns: Set<AnyTeardown>;\r\n\r\n  constructor(...teardowns: Array<AnyTeardown>) {\r\n    this.teardowns = new Set();\r\n    this.disposed = false;\r\n    if (teardowns.length) {\r\n      this.add(...teardowns);\r\n    }\r\n  }\r\n\r\n  add(...teardowns: Array<AnyTeardown>): void {\r\n    if (this.disposed) {\r\n      throw new Error('Cannot add to an already disposed UniversalDisposable!');\r\n    }\r\n    for (let i = 0; i < teardowns.length; i++) {\r\n      assertTeardown(teardowns[i]);\r\n      this.teardowns.add(teardowns[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a list of teardowns but also ties them to the lifetime of `destructible`.\r\n   * When `destructible` is destroyed (or `this.dispose()` gets called, whichever comes first),\r\n   * all `teardowns` provided are also disposed.\r\n   *\r\n   * This is a subtle pattern to get right because of two factors:\r\n   * - we need to make sure that all teardowns are also removed on destroy\r\n   * - we also need to ensure that we don't leak the onDidDestroy disposable\r\n   */\r\n  addUntilDestroyed(\r\n    destructible: IDestructible,\r\n    ...teardowns: Array<AnyTeardown>\r\n  ) {\r\n    if (this.disposed) {\r\n      throw new Error('Cannot add to an already disposed UniversalDisposable!');\r\n    }\r\n    const destroyDisposable = new UniversalDisposable(\r\n      ...teardowns,\r\n      destructible.onDidDestroy(() => {\r\n        destroyDisposable.dispose();\r\n        this.remove(destroyDisposable);\r\n      }),\r\n    );\r\n    this.add(destroyDisposable);\r\n  }\r\n\r\n  remove(teardown: AnyTeardown): void {\r\n    if (!this.disposed) {\r\n      this.teardowns.delete(teardown);\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    if (!this.disposed) {\r\n      this.disposed = true;\r\n      this.teardowns.forEach(teardown => {\r\n        if (typeof teardown.dispose === 'function') {\r\n          teardown.dispose();\r\n        } else if (typeof teardown.unsubscribe === 'function') {\r\n          teardown.unsubscribe();\r\n        } else if (typeof teardown.destroy === 'function') {\r\n          teardown.destroy();\r\n        } else if (typeof teardown === 'function') {\r\n          teardown();\r\n        }\r\n      });\r\n      this.teardowns = (null: any);\r\n    }\r\n  }\r\n\r\n  unsubscribe(): void {\r\n    this.dispose();\r\n  }\r\n\r\n  clear(): void {\r\n    if (!this.disposed) {\r\n      this.teardowns.clear();\r\n    }\r\n  }\r\n}\r\n\r\nfunction assertTeardown(teardown: AnyTeardown): void {\r\n  if (\r\n    typeof teardown.dispose === 'function' ||\r\n    typeof teardown.unsubscribe === 'function' ||\r\n    typeof teardown.destroy === 'function' ||\r\n    typeof teardown === 'function'\r\n  ) {\r\n    return;\r\n  }\r\n  throw new TypeError(\r\n    'Arguments to UniversalDisposable.add must be disposable',\r\n  );\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\n\r\ntype RunReturn<T> =\r\n  | {\r\n      status: 'success',\r\n      result: T,\r\n    }\r\n  | {\r\n      status: 'outdated',\r\n    };\r\n\r\n/**\r\n * Allows a caller to ensure that the results it receives from consecutive\r\n * promise resolutions are never outdated. Usage:\r\n *\r\n * var requestSerializer = new RequestSerializer();\r\n *\r\n * // in some later loop:\r\n *\r\n * // note that you do not await the async function here -- you must pass the\r\n * // promise it returns to `run`\r\n * var result = await requestSerializer.run(someAsyncFunction())\r\n *\r\n * if (result.status === 'success') {\r\n *   ....\r\n *   result.result\r\n * } else if (result.status === 'outdated') {\r\n *   ....\r\n * }\r\n *\r\n * The contract is that the status is 'success' if and only if this was the most\r\n * recently dispatched call of 'run'. For example, if you call run(promise1) and\r\n * then run(promise2), and promise2 resolves first, the second callsite would\r\n * receive a 'success' status. If promise1 later resolved, the first callsite\r\n * would receive an 'outdated' status.\r\n */\r\nexport class RequestSerializer<T> {\r\n  _lastDispatchedOp: number;\r\n  _lastFinishedOp: number;\r\n  _latestPromise: Promise<T>;\r\n  _waitResolve: Function;\r\n\r\n  constructor() {\r\n    this._lastDispatchedOp = 0;\r\n    this._lastFinishedOp = 0;\r\n    this._latestPromise = new Promise((resolve, reject) => {\r\n      this._waitResolve = resolve;\r\n    });\r\n  }\r\n\r\n  async run(promise: Promise<T>): Promise<RunReturn<T>> {\r\n    const thisOp = this._lastDispatchedOp + 1;\r\n    this._lastDispatchedOp = thisOp;\r\n    this._latestPromise = promise;\r\n    this._waitResolve();\r\n    const result = await promise;\r\n    if (this._lastFinishedOp < thisOp) {\r\n      this._lastFinishedOp = thisOp;\r\n      return {\r\n        status: 'success',\r\n        result,\r\n      };\r\n    } else {\r\n      return {\r\n        status: 'outdated',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a Promise that resolves to the last result of `run`,\r\n   * as soon as there are no more outstanding `run` calls.\r\n   */\r\n  async waitForLatestResult(): Promise<T> {\r\n    let lastPromise = null;\r\n    let result: any = null;\r\n    while (lastPromise !== this._latestPromise) {\r\n      lastPromise = this._latestPromise;\r\n      // Wait for the current last know promise to resolve, or a next run have started.\r\n      // eslint-disable-next-line no-await-in-loop\r\n      result = await new Promise((resolve, reject) => {\r\n        this._waitResolve = resolve;\r\n        this._latestPromise.then(resolve);\r\n      });\r\n    }\r\n    return (result: T);\r\n  }\r\n\r\n  isRunInProgress(): boolean {\r\n    return this._lastDispatchedOp > this._lastFinishedOp;\r\n  }\r\n}\r\n\r\n/*\r\n * Returns a promise that will resolve after `milliSeconds` milli seconds.\r\n * this can be used to pause execution asynchronously.\r\n * e.g. await sleep(1000), pauses the async flow execution for 1 second.\r\n */\r\nexport function sleep(milliSeconds: number): Promise<void> {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, milliSeconds);\r\n  });\r\n}\r\n\r\nexport function nextTick(): Promise<void> {\r\n  return new Promise(resolve => {\r\n    process.nextTick(resolve);\r\n  });\r\n}\r\n\r\n/**\r\n * Executes a provided callback only if a promise takes longer than\r\n * `milliSeconds` milliseconds to resolve.\r\n *\r\n * @param `promise` the promise to wait on.\r\n * @param `milliSeconds` max amount of time that `promise` can take to resolve\r\n * before timeoutFn is fired.\r\n * @param `timeoutFn` the function to execute when a promise takes longer than\r\n * `milliSeconds` ms to resolve.\r\n * @param `cleanupFn` the cleanup function to execute after the promise resolves.\r\n */\r\nexport async function triggerAfterWait<T>(\r\n  promise: Promise<T>,\r\n  milliSeconds: number,\r\n  timeoutFn: () => void,\r\n  cleanupFn?: () => void,\r\n): Promise<T> {\r\n  const timeout = setTimeout(timeoutFn, milliSeconds);\r\n  try {\r\n    return await promise;\r\n  } finally {\r\n    clearTimeout(timeout);\r\n    if (cleanupFn) {\r\n      cleanupFn();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Thrown by `timeoutPromise` if the timer fires before the promise resolves/rejects.\r\n */\r\nexport class TimedOutError extends Error {\r\n  timeout: number;\r\n  constructor(milliseconds: number) {\r\n    super(`Timed out after ${String(milliseconds)} ms`);\r\n    this.timeout = milliseconds;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a Promise that resolves to the same value as the given promise, or rejects with\r\n * `TimedOutError` if it takes longer than `milliseconds` milliseconds.\r\n */\r\nexport function timeoutPromise<T>(\r\n  promise: Promise<T>,\r\n  milliseconds: number,\r\n): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    let timeout = setTimeout(() => {\r\n      timeout = null;\r\n      reject(new TimedOutError(milliseconds));\r\n      // This gives useless error.stack results.\r\n      // We could capture the stack pre-emptively at the start\r\n      // of this method if we wanted useful ones.\r\n    }, milliseconds);\r\n    promise\r\n      .then(value => {\r\n        if (timeout != null) {\r\n          clearTimeout(timeout);\r\n        }\r\n        resolve(value);\r\n      })\r\n      .catch(value => {\r\n        if (timeout != null) {\r\n          clearTimeout(timeout);\r\n        }\r\n        reject(value);\r\n      });\r\n  });\r\n}\r\n\r\n// An DeadlineRequest parameter to an async method is a way of *requesting* that\r\n// method to throw a TimedOutError if it doesn't complete in a certain time.\r\n// It's just a request -- the async method will typically honor the request\r\n// by passing the parameter on to ALL subsidiary async methods that it awaits,\r\n// or by calling expirePromise to enforce a timeout, or similar.\r\n//\r\n// In cases where a method supports DeadlineRequest but you don't trust it, do\r\n// `await timeoutAfterDeadline(deadline, untrusted.foo(deadline-1000))` so you\r\n// ask it nicely but if it doesn't give its own more-specific deadline message\r\n// within a 1000ms grace period then you force matters.\r\n//\r\n// Under the hood an DeadlineRequest is just a timestamp of the time by which\r\n// the operation should complete. This makes it compositional (better than\r\n// \"delay\" parameters) and safely remotable (better than \"CancellationToken\"\r\n// parameters) so long as clocks are in sync. In all other respects it's less\r\n// versatile than CancellationTokens.\r\nexport type DeadlineRequest = number;\r\n\r\nexport function createDeadline(delay: number): DeadlineRequest {\r\n  return Date.now() + delay;\r\n}\r\n\r\nexport function timeoutAfterDeadline<T>(\r\n  deadline: DeadlineRequest,\r\n  promise: Promise<T>,\r\n): Promise<T> {\r\n  const delay = deadline - Date.now();\r\n  return timeoutPromise(promise, delay < 0 ? 0 : delay);\r\n}\r\n\r\n/**\r\n * Call an async function repeatedly with a maximum number of trials limit,\r\n * until a valid result that's defined by a validation function.\r\n * A failed call can result from an async thrown exception, or invalid result.\r\n *\r\n * @param `retryFunction` the async logic that's wanted to be retried.\r\n * @param `validationFunction` the validation function that decides whether a response is valid.\r\n * @param `maximumTries` the number of times the `retryFunction` can fail to get a valid\r\n * response before the `retryLimit` is terminated reporting an error.\r\n * @param `retryIntervalMs` optional, the number of milliseconds to wait between trials, if wanted.\r\n *\r\n * If an exception is encountered on the last trial, the exception is thrown.\r\n * If no valid response is found, an exception is thrown.\r\n */\r\nexport async function retryLimit<T>(\r\n  retryFunction: () => Promise<T>,\r\n  validationFunction: (result: T) => boolean,\r\n  maximumTries: number,\r\n  retryIntervalMs?: number = 0,\r\n): Promise<T> {\r\n  let result = null;\r\n  let tries = 0;\r\n  let lastError = null;\r\n  while (tries === 0 || tries < maximumTries) {\r\n    try {\r\n      // eslint-disable-next-line no-await-in-loop\r\n      result = await retryFunction();\r\n      lastError = null;\r\n      if (validationFunction(result)) {\r\n        return result;\r\n      }\r\n    } catch (error) {\r\n      lastError = error;\r\n      result = null;\r\n    }\r\n\r\n    if (++tries < maximumTries && retryIntervalMs !== 0) {\r\n      // eslint-disable-next-line no-await-in-loop\r\n      await sleep(retryIntervalMs);\r\n    }\r\n  }\r\n  if (lastError != null) {\r\n    throw lastError;\r\n  } else if (tries === maximumTries) {\r\n    throw new Error('No valid response found!');\r\n  } else {\r\n    return ((result: any): T);\r\n  }\r\n}\r\n\r\n/**\r\n * Limits async function execution parallelism to only one at a time.\r\n * Hence, if a call is already running, it will wait for it to finish,\r\n * then start the next async execution, but if called again while not finished,\r\n * it will return the scheduled execution promise.\r\n *\r\n * Sample Usage:\r\n * ```\r\n * let i = 1;\r\n * const oneExecAtATime = oneParallelAsyncCall(() => {\r\n *   return next Promise((resolve, reject) => {\r\n *     setTimeout(200, () => resolve(i++));\r\n *   });\r\n * });\r\n *\r\n * const result1Promise = oneExecAtATime(); // Start an async, and resolve to 1 in 200 ms.\r\n * const result2Promise = oneExecAtATime(); // Schedule the next async, and resolve to 2 in 400 ms.\r\n * const result3Promise = oneExecAtATime(); // Reuse scheduled promise and resolve to 2 in 400 ms.\r\n * ```\r\n */\r\nexport function serializeAsyncCall<T>(\r\n  asyncFun: () => Promise<T>,\r\n): () => Promise<T> {\r\n  let scheduledCall = null;\r\n  let pendingCall = null;\r\n  const startAsyncCall = () => {\r\n    const resultPromise = asyncFun();\r\n    pendingCall = resultPromise.then(\r\n      () => (pendingCall = null),\r\n      () => (pendingCall = null),\r\n    );\r\n    return resultPromise;\r\n  };\r\n  const callNext = () => {\r\n    scheduledCall = null;\r\n    return startAsyncCall();\r\n  };\r\n  const scheduleNextCall = () => {\r\n    if (scheduledCall == null) {\r\n      invariant(pendingCall, 'pendingCall must not be null!');\r\n      scheduledCall = pendingCall.then(callNext, callNext);\r\n    }\r\n    return scheduledCall;\r\n  };\r\n  return () => {\r\n    if (pendingCall == null) {\r\n      return startAsyncCall();\r\n    } else {\r\n      return scheduleNextCall();\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Provides a promise along with methods to change its state. Our version of the non-standard\r\n * `Promise.defer()`.\r\n *\r\n * IMPORTANT: This should almost never be used!! Instead, use the Promise constructor. See\r\n *  <https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern>\r\n */\r\nexport class Deferred<T> {\r\n  promise: Promise<T>;\r\n  resolve: (value: T) => void;\r\n  reject: (error: Error) => void;\r\n\r\n  constructor() {\r\n    this.promise = new Promise((resolve, reject) => {\r\n      this.resolve = resolve;\r\n      this.reject = reject;\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a value derived asynchronously from an element in the items array.\r\n * The test function is applied sequentially to each element in items until\r\n * one returns a Promise that resolves to a non-null value. When this happens,\r\n * the Promise returned by this method will resolve to that non-null value. If\r\n * no such Promise is produced, then the Promise returned by this function\r\n * will resolve to null.\r\n *\r\n * @param items Array of elements that will be passed to test, one at a time.\r\n * @param test Will be called with each item and must return either:\r\n *     (1) A \"thenable\" (i.e, a Promise or promise-like object) that resolves\r\n *         to a derived value (that will be returned) or null.\r\n *     (2) null.\r\n *     In both cases where null is returned, test will be applied to the next\r\n *     item in the array.\r\n * @param thisArg Receiver that will be used when test is called.\r\n * @return Promise that resolves to an asynchronously derived value or null.\r\n */\r\nexport function asyncFind<T, U>(\r\n  items_: Array<T>,\r\n  test: (t: T) => ?Promise<?U>,\r\n  thisArg?: mixed,\r\n): Promise<?U> {\r\n  let items = items_;\r\n  return new Promise((resolve, reject) => {\r\n    // Create a local copy of items to defend against the caller modifying the\r\n    // array before this Promise is resolved.\r\n    items = items.slice();\r\n    const numItems = items.length;\r\n\r\n    const next = async function(index) {\r\n      if (index === numItems) {\r\n        resolve(null);\r\n        return;\r\n      }\r\n\r\n      const item = items[index];\r\n      const result = await test.call(thisArg, item);\r\n      if (result != null) {\r\n        resolve(result);\r\n      } else {\r\n        next(index + 1);\r\n      }\r\n    };\r\n\r\n    next(0);\r\n  });\r\n}\r\n\r\nexport function denodeify(\r\n  f: (...args: Array<any>) => any,\r\n): (...args: Array<any>) => Promise<any> {\r\n  return function(...args: Array<any>) {\r\n    return new Promise((resolve, reject) => {\r\n      function callback(error, result) {\r\n        if (error) {\r\n          reject(error);\r\n        } else {\r\n          resolve(result);\r\n        }\r\n      }\r\n      f.apply(this, args.concat([callback]));\r\n    });\r\n  };\r\n}\r\n\r\n/**\r\n * A Promise utility that runs a maximum of limit async operations at a time\r\n * iterating over an array and returning the result of executions.\r\n * e.g. to limit the number of file reads to 5,\r\n * replace the code:\r\n *    var fileContents = await Promise.all(filePaths.map(fsPromise.readFile))\r\n * with:\r\n *    var fileContents = await asyncLimit(filePaths, 5, fsPromise.readFile)\r\n *\r\n * This is particulrily useful to limit IO operations to a configurable maximum (to avoid\r\n * blocking), while enjoying the configured level of parallelism.\r\n *\r\n * @param array the array of items for iteration.\r\n * @param limit the configurable number of parallel async operations.\r\n * @param mappingFunction the async Promise function that could return a useful result.\r\n */\r\nexport function asyncLimit<T, V>(\r\n  array: Array<T>,\r\n  limit: number,\r\n  mappingFunction: (item: T) => Promise<V>,\r\n): Promise<Array<V>> {\r\n  const result: Array<V> = new Array(array.length);\r\n  let parallelPromises = 0;\r\n  let index = 0;\r\n\r\n  let parallelLimit = Math.min(limit, array.length) || 1;\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const runPromise = async () => {\r\n      if (index === array.length) {\r\n        if (parallelPromises === 0) {\r\n          resolve(result);\r\n        }\r\n        return;\r\n      }\r\n      ++parallelPromises;\r\n      const i = index++;\r\n      try {\r\n        result[i] = await mappingFunction(array[i]);\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n      --parallelPromises;\r\n      runPromise();\r\n    };\r\n\r\n    while (parallelLimit--) {\r\n      runPromise();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * `filter` Promise utility that allows filtering an array with an async Promise function.\r\n * It's an alternative to `Array.prototype.filter` that accepts an async function.\r\n * You can optionally configure a limit to set the maximum number of async operations at a time.\r\n *\r\n * Previously, with the `Promise.all` primitive, we can't set the parallelism limit and we have to\r\n * `filter`, so, we replace the old `filter` code:\r\n *     var existingFilePaths = [];\r\n *     await Promise.all(filePaths.map(async (filePath) => {\r\n *       if (await fsPromise.exists(filePath)) {\r\n *         existingFilePaths.push(filePath);\r\n *       }\r\n *     }));\r\n * with limit 5 parallel filesystem operations at a time:\r\n *    var existingFilePaths = await asyncFilter(filePaths, fsPromise.exists, 5);\r\n *\r\n * @param array the array of items for `filter`ing.\r\n * @param filterFunction the async `filter` function that returns a Promise that resolves to a\r\n *   boolean.\r\n * @param limit the configurable number of parallel async operations.\r\n */\r\nexport async function asyncFilter<T>(\r\n  array: Array<T>,\r\n  filterFunction: (item: T) => Promise<boolean>,\r\n  limit?: number,\r\n): Promise<Array<T>> {\r\n  const filteredList = [];\r\n  // flowlint-next-line sketchy-null-number:off\r\n  await asyncLimit(array, limit || array.length, async (item: T) => {\r\n    if (await filterFunction(item)) {\r\n      filteredList.push(item);\r\n    }\r\n  });\r\n  return filteredList;\r\n}\r\n\r\nexport async function asyncObjFilter<T>(\r\n  obj: {[key: string]: T},\r\n  filterFunction: (item: T, key: string) => Promise<boolean>,\r\n  limit?: number,\r\n): Promise<{[key: string]: T}> {\r\n  const keys = Object.keys(obj);\r\n  const filteredObj = {};\r\n  // flowlint-next-line sketchy-null-number:off\r\n  await asyncLimit(keys, limit || keys.length, async (key: string) => {\r\n    const item = obj[key];\r\n    if (await filterFunction(item, key)) {\r\n      filteredObj[key] = item;\r\n    }\r\n  });\r\n  return filteredObj;\r\n}\r\n\r\n/**\r\n * `some` Promise utility that allows `some` an array with an async Promise some function.\r\n * It's an alternative to `Array.prototype.some` that accepts an async some function.\r\n * You can optionally configure a limit to set the maximum number of async operations at a time.\r\n *\r\n * Previously, with the Promise.all primitive, we can't set the parallelism limit and we have to\r\n * `some`, so, we replace the old `some` code:\r\n *     var someFileExist = false;\r\n *     await Promise.all(filePaths.map(async (filePath) => {\r\n *       if (await fsPromise.exists(filePath)) {\r\n *         someFileExist = true;\r\n *       }\r\n *     }));\r\n * with limit 5 parallel filesystem operations at a time:\r\n *    var someFileExist = await asyncSome(filePaths, fsPromise.exists, 5);\r\n *\r\n * @param array the array of items for `some`ing.\r\n * @param someFunction the async `some` function that returns a Promise that resolves to a\r\n *   boolean.\r\n * @param limit the configurable number of parallel async operations.\r\n */\r\nexport async function asyncSome<T>(\r\n  array: Array<T>,\r\n  someFunction: (item: T) => Promise<boolean>,\r\n  limit?: number,\r\n): Promise<boolean> {\r\n  let resolved = false;\r\n  // flowlint-next-line sketchy-null-number:off\r\n  await asyncLimit(array, limit || array.length, async (item: T) => {\r\n    if (resolved) {\r\n      // We don't need to call the someFunction anymore or wait any longer.\r\n      return;\r\n    }\r\n    if (await someFunction(item)) {\r\n      resolved = true;\r\n    }\r\n  });\r\n  return resolved;\r\n}\r\n\r\n/**\r\n * Check if an object is Promise by testing if it has a `then` function property.\r\n */\r\nexport function isPromise(object: any): boolean {\r\n  return (\r\n    Boolean(object) &&\r\n    typeof object === 'object' &&\r\n    typeof object.then === 'function'\r\n  );\r\n}\r\n\r\n/**\r\n * We can't name a function 'finally', so use lastly instead.\r\n * fn() will be executed (and completed) after the provided promise resolves/rejects.\r\n */\r\nexport function lastly<T>(\r\n  promise: Promise<T>,\r\n  fn: () => Promise<mixed> | mixed,\r\n): Promise<T> {\r\n  return promise.then(\r\n    ret => {\r\n      return Promise.resolve(fn()).then(() => ret);\r\n    },\r\n    err => {\r\n      return Promise.resolve(fn()).then(() => Promise.reject(err));\r\n    },\r\n  );\r\n}\r\n\r\n/**\r\n * With a pure promise object, there's no way to tell synchronously\r\n * whether or not it has 'settled' (i.e. been fulfilled or rejected).\r\n * Here we provide a wrapper that provides that information.\r\n */\r\nexport type PromiseState<T> =\r\n  | {kind: 'pending'}\r\n  | {kind: 'fulfilled', value: T}\r\n  | {kind: 'rejected', error: any};\r\n\r\nexport class PromiseWithState<T> {\r\n  _promise: Promise<T>;\r\n  _state: PromiseState<T>;\r\n\r\n  constructor(promise: Promise<T>) {\r\n    this._state = {kind: 'pending'};\r\n    this._promise = promise.then(\r\n      value => {\r\n        this._state = {kind: 'fulfilled', value};\r\n        return value;\r\n      },\r\n      error => {\r\n        this._state = {kind: 'rejected', error};\r\n        throw error;\r\n      },\r\n    );\r\n  }\r\n\r\n  getPromise(): Promise<T> {\r\n    return this._promise;\r\n  }\r\n\r\n  getState(): PromiseState<T> {\r\n    return this._state;\r\n  }\r\n}\r\n\r\nexport function delayTime(ms: number): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\n/* global performance */\r\n\r\n/**\r\n * Polyfill for performance.now that works both on Atom (chrome) and node.\r\n * It returns a monotonically increasing timer in milliseconds.\r\n *\r\n * Usage:\r\n *   const now = performanceNow();\r\n *   // ... code you want to benchmark ...\r\n *   const timeItTookInMilliseconds = performanceNow() - now;\r\n */\r\n\r\nexport default (typeof performance !== 'undefined'\r\n  ? (): number => performance.now()\r\n  : (): number => {\r\n      const [seconds, nanoseconds] = process.hrtime();\r\n      return seconds * 1000 + nanoseconds / 1000000;\r\n    });\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport type {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport getDisplayName from './getDisplayName';\r\nimport UniversalDisposable from './UniversalDisposable';\r\nimport {isPromise} from './promise';\r\nimport performanceNow from './performanceNow';\r\n\r\nexport type SessionInfo = {\r\n  id: string,\r\n  start: number,\r\n};\r\n\r\nexport type RawAnalyticsService = {\r\n  track(\r\n    eventName: string,\r\n    values?: {[key: string]: mixed},\r\n    immediate?: boolean,\r\n  ): ?Promise<mixed>,\r\n  isTrackSupported: () => boolean,\r\n  setApplicationSessionObservable: (Observable<SessionInfo>) => void,\r\n};\r\n\r\nlet rawAnalyticsService: RawAnalyticsService = {\r\n  track(): ?Promise<mixed> {},\r\n  isTrackSupported: () => false,\r\n  setApplicationSessionObservable: (ob: Observable<SessionInfo>) => {},\r\n};\r\n\r\nexport type TrackingEvent = {\r\n  type: string,\r\n  data?: Object,\r\n};\r\n\r\nexport type TrackEvent = {\r\n  key: string,\r\n  values: {[key: string]: mixed},\r\n};\r\n\r\n/**\r\n * Track a set of values against a named event.\r\n * Analytics will be batched and processed asynchronously in the background.\r\n *\r\n * @param eventName Name of the event to be tracked.\r\n * @param values The object containing the data to track.\r\n */\r\nexport function track(\r\n  eventName: string,\r\n  values?: {[key: string]: mixed},\r\n): void {\r\n  rawAnalyticsService.track(eventName, values || {});\r\n}\r\n\r\nexport function isTrackSupported(): boolean {\r\n  return rawAnalyticsService.isTrackSupported();\r\n}\r\n\r\n/**\r\n * Same as `track`, except this is guaranteed to send immediately.\r\n * The returned promise will resolve when the request completes (or reject on failure).\r\n */\r\nexport function trackImmediate(\r\n  eventName: string,\r\n  values?: {[key: string]: mixed},\r\n): Promise<mixed> {\r\n  return (\r\n    rawAnalyticsService.track(eventName, values || {}, true) ||\r\n    Promise.resolve()\r\n  );\r\n}\r\n\r\n/**\r\n * An alternative interface for `track` that accepts a single event object. This is particularly\r\n * useful when dealing with streams (Observables).\r\n */\r\nexport function trackEvent(event: TrackingEvent): void {\r\n  track(event.type, event.data);\r\n}\r\n\r\n/**\r\n * Track each event in a stream of TrackingEvents.\r\n */\r\nexport function trackEvents(events: Observable<TrackingEvent>): IDisposable {\r\n  return new UniversalDisposable(events.subscribe(trackEvent));\r\n}\r\n\r\n/**\r\n * A sampled version of track that only tracks every 1/sampleRate calls.\r\n */\r\nexport function trackSampled(\r\n  eventName: string,\r\n  sampleRate: number,\r\n  values?: {[key: string]: mixed},\r\n): void {\r\n  if (Math.random() * sampleRate <= 1) {\r\n    rawAnalyticsService.track(eventName, {\r\n      ...values,\r\n      sample_rate: sampleRate,\r\n    });\r\n  }\r\n}\r\n\r\nconst PERFORMANCE_EVENT = 'performance';\r\nconst canMeasure = typeof performance !== 'undefined';\r\nexport class TimingTracker {\r\n  static eventCount = 0;\r\n\r\n  _eventName: string;\r\n  _startTime: number;\r\n  _startMark: string;\r\n  _values: {[key: string]: mixed};\r\n\r\n  constructor(eventName: string, values: {[key: string]: mixed}) {\r\n    this._eventName = eventName;\r\n    this._startMark = `${this._eventName}_${TimingTracker.eventCount++}_start`;\r\n    this._startTime = performanceNow();\r\n    this._values = values;\r\n    if (canMeasure) {\r\n      // eslint-disable-next-line no-undef\r\n      performance.mark(this._startMark);\r\n    }\r\n  }\r\n\r\n  onError(error: Error): void {\r\n    this._trackTimingEvent(error);\r\n  }\r\n\r\n  onCancel(): void {\r\n    this._trackTimingEvent(/* error */ null, true);\r\n  }\r\n\r\n  onSuccess(): void {\r\n    this._trackTimingEvent(/* error */ null);\r\n  }\r\n\r\n  _trackTimingEvent(exception: ?Error, canceled: boolean = false): void {\r\n    if (canMeasure) {\r\n      /* eslint-disable no-undef */\r\n      // call measure to add this information to the devtools timeline in the\r\n      // case the profiler is running.\r\n      performance.measure(this._eventName, this._startMark);\r\n      // then clear all the marks and measurements to avoid growing the\r\n      // performance entry buffer\r\n      performance.clearMarks(this._startMark);\r\n      performance.clearMeasures(this._eventName);\r\n      /* eslint-enable no-undef */\r\n    }\r\n\r\n    track(PERFORMANCE_EVENT, {\r\n      ...this._values,\r\n      duration: Math.round(performanceNow() - this._startTime).toString(),\r\n      eventName: this._eventName,\r\n      error: exception ? '1' : '0',\r\n      exception: exception ? exception.toString() : '',\r\n      canceled,\r\n    });\r\n  }\r\n}\r\n\r\nexport function startTracking(\r\n  eventName: string,\r\n  values?: {[key: string]: any} = {},\r\n): TimingTracker {\r\n  return new TimingTracker(eventName, values);\r\n}\r\n\r\n/**\r\n * Reports analytics including timing for a single operation.\r\n *\r\n * Usage:\r\n *\r\n * analytics.trackTiming('my-package-some-long-operation' () => doit());\r\n *\r\n * Returns (or throws) the result of the operation.\r\n */\r\nexport function trackTiming<T>(\r\n  eventName: string,\r\n  operation: () => T,\r\n  values?: {[key: string]: any} = {},\r\n): T {\r\n  const tracker = startTracking(eventName, values);\r\n\r\n  try {\r\n    const result = operation();\r\n\r\n    if (isPromise(result)) {\r\n      // Atom uses a different Promise implementation than Nuclide, so the following is not true:\r\n      // invariant(result instanceof Promise);\r\n\r\n      // For the method returning a Promise, track the time after the promise is resolved/rejected.\r\n      return (result: any).then(\r\n        value => {\r\n          tracker.onSuccess();\r\n          return value;\r\n        },\r\n        reason => {\r\n          tracker.onError(reason instanceof Error ? reason : new Error(reason));\r\n          return Promise.reject(reason);\r\n        },\r\n      );\r\n    } else {\r\n      tracker.onSuccess();\r\n      return result;\r\n    }\r\n  } catch (error) {\r\n    tracker.onError(error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport function decorateTrackTiming<U: Array<*>, T>(\r\n  fn: (...args: U) => T,\r\n  values?: {[key: string]: any} = {},\r\n): (...args: U) => T {\r\n  const name = getDisplayName(fn);\r\n  function decoratedTrackTiming(...args: U) {\r\n    return trackTiming(name, fn.bind(this, ...args), values);\r\n  }\r\n  decoratedTrackTiming.displayName = `trackTiming(${name})`;\r\n  return decoratedTrackTiming;\r\n}\r\n\r\n/**\r\n * A sampled version of trackTiming that only tracks every 1/sampleRate calls.\r\n */\r\nexport function trackTimingSampled<T>(\r\n  eventName: string,\r\n  operation: () => T,\r\n  sampleRate: number,\r\n  values?: {[key: string]: any} = {},\r\n): T {\r\n  if (Math.random() * sampleRate <= 1) {\r\n    return trackTiming(eventName, operation, {\r\n      ...values,\r\n      sample_rate: sampleRate,\r\n    });\r\n  }\r\n  return operation();\r\n}\r\n\r\nexport function decorateTrackTimingSampled<U: Array<*>, T>(\r\n  fn: (...args: U) => T,\r\n  sampleRate: number,\r\n  values?: {[key: string]: any} = {},\r\n): (...args: U) => T {\r\n  const name = getDisplayName(fn);\r\n  function decoratedTrackTimingSampled(...args: U) {\r\n    return trackTimingSampled(name, fn.bind(this, ...args), sampleRate, values);\r\n  }\r\n  decoratedTrackTimingSampled.displayName = `trackTimingSampled(${name})`;\r\n  return decoratedTrackTimingSampled;\r\n}\r\n\r\nexport function setRawAnalyticsService(\r\n  analyticsService: RawAnalyticsService,\r\n  ob: Observable<SessionInfo>,\r\n): void {\r\n  analyticsService.setApplicationSessionObservable(ob);\r\n  rawAnalyticsService = analyticsService;\r\n}\r\n\r\nexport default {\r\n  track,\r\n  trackSampled,\r\n  trackEvent,\r\n  trackTiming,\r\n  trackTimingSampled,\r\n  startTracking,\r\n  TimingTracker,\r\n  decorateTrackTiming,\r\n  decorateTrackTimingSampled,\r\n};\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport UniversalDisposable from '@atom-ide-community/nuclide-commons/UniversalDisposable';\r\n\r\nexport type Provider = {\r\n  // Providers with higher priorities will be preferred over lower ones.\r\n  priority: number,\r\n  // Omitting grammarScopes implies that the provider applies to all grammars.\r\n  +grammarScopes?: Array<string>,\r\n};\r\n\r\nexport default class ProviderRegistry<T: Provider> {\r\n  _providers: Array<T>;\r\n\r\n  constructor() {\r\n    this._providers = [];\r\n  }\r\n\r\n  addProvider(provider: T): IDisposable {\r\n    const index = this._providers.findIndex(\r\n      p => provider.priority > p.priority,\r\n    );\r\n    if (index === -1) {\r\n      this._providers.push(provider);\r\n    } else {\r\n      this._providers.splice(index, 0, provider);\r\n    }\r\n    return new UniversalDisposable(() => {\r\n      this.removeProvider(provider);\r\n    });\r\n  }\r\n\r\n  removeProvider(provider: T): void {\r\n    const index = this._providers.indexOf(provider);\r\n    if (index !== -1) {\r\n      this._providers.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  // TODO deprecate since there can be N providers.\r\n  getProviderForEditor(editor: atom$TextEditor): ?T {\r\n    const grammar = editor.getGrammar().scopeName;\r\n    return this.findProvider(grammar);\r\n  }\r\n\r\n  // TODO create an ordering or priority aware util to prefer instead.\r\n  getAllProvidersForEditor(editor: atom$TextEditor): Iterable<T> {\r\n    const grammar = editor.getGrammar().scopeName;\r\n    return this.findAllProviders(grammar);\r\n  }\r\n\r\n  findProvider(grammar: string): ?T {\r\n    for (const provider of this.findAllProviders(grammar)) {\r\n      return provider;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Iterates over all providers matching the grammar, in priority order.\r\n   */\r\n  *findAllProviders(grammar: string): Iterable<T> {\r\n    for (const provider of this._providers) {\r\n      if (\r\n        provider.grammarScopes == null ||\r\n        provider.grammarScopes.indexOf(grammar) !== -1\r\n      ) {\r\n        yield provider;\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport UniversalDisposable from './UniversalDisposable';\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\n/**\r\n * Add an event listener an return a disposable for removing it. Note that this function assumes\r\n * node EventEmitter semantics: namely, that adding the same combination of eventName and callback\r\n * adds a second listener.\r\n */\r\nexport function attachEvent(\r\n  emitter: events$EventEmitter,\r\n  eventName: string,\r\n  callback: Function,\r\n): IDisposable {\r\n  emitter.addListener(eventName, callback);\r\n  return new UniversalDisposable(() => {\r\n    emitter.removeListener(eventName, callback);\r\n  });\r\n}\r\n\r\ntype SubscribeCallback<T> = (item: T) => any;\r\ntype SubscribeFunction<T> = (\r\n  callback: SubscribeCallback<T>,\r\n) => IDisposable | (() => mixed);\r\n\r\nexport function observableFromSubscribeFunction<T>(\r\n  fn: SubscribeFunction<T>,\r\n): Observable<T> {\r\n  return Observable.create(\r\n    observer => new UniversalDisposable(fn(observer.next.bind(observer))),\r\n  );\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport type {NuclideUri} from '@atom-ide-community/nuclide-commons/nuclideUri';\r\n\r\nimport invariant from 'assert';\r\nimport {TextEditor} from 'atom';\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport {observableFromSubscribeFunction} from '@atom-ide-community/nuclide-commons/event';\r\n\r\n/**\r\n * Returns a text editor that has the given path open, or null if none exists. If there are multiple\r\n * text editors for this path, one is chosen arbitrarily.\r\n */\r\nexport function existingEditorForUri(path: NuclideUri): ?atom$TextEditor {\r\n  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a\r\n  // real problem. And if you have more than a few hundred you probably have bigger problems.\r\n  for (const editor of atom.workspace.getTextEditors()) {\r\n    if (editor.getPath() === path) {\r\n      return editor;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Returns a text editor that has the given buffer open, or null if none exists. If there are\r\n * multiple text editors for this buffer, one is chosen arbitrarily.\r\n */\r\nexport function existingEditorForBuffer(\r\n  buffer: atom$TextBuffer,\r\n): ?atom$TextEditor {\r\n  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a\r\n  // real problem. And if you have more than a few hundred you probably have bigger problems.\r\n  for (const editor of atom.workspace.getTextEditors()) {\r\n    if (editor.getBuffer() === buffer) {\r\n      return editor;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getViewOfEditor(\r\n  editor: atom$TextEditor,\r\n): atom$TextEditorElement {\r\n  return atom.views.getView(editor);\r\n}\r\n\r\nexport function getScrollTop(editor: atom$TextEditor): number {\r\n  return getViewOfEditor(editor).getScrollTop();\r\n}\r\n\r\nexport function setScrollTop(editor: atom$TextEditor, scrollTop: number): void {\r\n  getViewOfEditor(editor).setScrollTop(scrollTop);\r\n}\r\n\r\n/**\r\n * Does a best effort to set an editor pane to a given cursor position & scroll.\r\n * Does not ensure that the current cursor position is visible.\r\n *\r\n * Can be used with editor.getCursorBufferPosition() & getScrollTop() to restore\r\n * an editors cursor and scroll.\r\n */\r\nexport function setPositionAndScroll(\r\n  editor: atom$TextEditor,\r\n  position: atom$Point,\r\n  scrollTop: number,\r\n): void {\r\n  editor.setCursorBufferPosition(position, {autoscroll: false});\r\n  setScrollTop(editor, scrollTop);\r\n}\r\n\r\nexport function getCursorPositions(\r\n  editor: atom$TextEditor,\r\n): Observable<atom$Point> {\r\n  return Observable.defer(() => {\r\n    // This will behave strangely in the face of multiple cursors. Consider supporting multiple\r\n    // cursors in the future.\r\n    const cursor = editor.getCursors()[0];\r\n    invariant(cursor != null);\r\n    return Observable.merge(\r\n      Observable.of(cursor.getBufferPosition()),\r\n      observableFromSubscribeFunction(\r\n        cursor.onDidChangePosition.bind(cursor),\r\n      ).map(event => event.newBufferPosition),\r\n    );\r\n  });\r\n}\r\n\r\nexport function observeEditorDestroy(\r\n  editor: atom$TextEditor,\r\n): Observable<atom$TextEditor> {\r\n  return observableFromSubscribeFunction(editor.onDidDestroy.bind(editor))\r\n    .map(event => editor)\r\n    .take(1);\r\n}\r\n\r\n// Use atom readOnly attribute to set read-only state.\r\nexport function enforceReadOnlyEditor(\r\n  textEditor: atom$TextEditor,\r\n  readOnlyExceptions?: Array<string> = ['append', 'setText'],\r\n): IDisposable {\r\n  textEditor.getElement().setAttribute('readonly', '');\r\n  return {\r\n    dispose() {\r\n      textEditor.getElement().removeAttribute('readonly');\r\n    },\r\n  };\r\n}\r\n\r\n// Turn off soft wrap setting for these editors so diffs properly align.\r\n// Some text editor register sometimes override the set soft wrapping\r\n// after mounting an editor to the workspace - here, that's watched and reset to `false`.\r\nexport function enforceSoftWrap(\r\n  editor: atom$TextEditor,\r\n  enforcedSoftWrap: boolean,\r\n): IDisposable {\r\n  editor.setSoftWrapped(enforcedSoftWrap);\r\n  return editor.onDidChangeSoftWrapped(softWrapped => {\r\n    if (softWrapped !== enforcedSoftWrap) {\r\n      // Reset the overridden softWrap to `false` once the operation completes.\r\n      process.nextTick(() => {\r\n        if (!editor.isDestroyed()) {\r\n          editor.setSoftWrapped(enforcedSoftWrap);\r\n        }\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Checks if an object (typically an Atom pane) is a TextEditor.\r\n * Could be replaced with atom.workspace.isValidTextEditor,\r\n * but Flow doesn't support %checks in methods yet.\r\n */\r\nexport function isValidTextEditor(item: mixed): boolean %checks {\r\n  return item instanceof TextEditor;\r\n}\r\n\r\nexport function centerScrollToBufferLine(\r\n  textEditorElement: atom$TextEditorElement,\r\n  bufferLineNumber: number,\r\n): void {\r\n  const textEditor = textEditorElement.getModel();\r\n  const pixelPositionTop = textEditorElement.pixelPositionForBufferPosition([\r\n    bufferLineNumber,\r\n    0,\r\n  ]).top;\r\n  // Manually calculate the scroll location, instead of using\r\n  // `textEditor.scrollToBufferPosition([lineNumber, 0], {center: true})`\r\n  // because that API to wouldn't center the line if it was in the visible screen range.\r\n  const scrollTop =\r\n    pixelPositionTop +\r\n    textEditor.getLineHeightInPixels() / 2 -\r\n    textEditorElement.clientHeight / 2;\r\n  textEditorElement.setScrollTop(Math.max(scrollTop, 1));\r\n\r\n  textEditorElement.focus();\r\n\r\n  textEditor.setCursorBufferPosition([bufferLineNumber, 0], {\r\n    autoscroll: false,\r\n  });\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\nimport type {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\n\r\nimport {getLogger} from 'log4js';\r\nimport {Subject} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\nimport invariant from 'assert';\r\n\r\nexport type GoToLocationOptions = {|\r\n  line?: number,\r\n  column?: number,\r\n  center?: boolean,\r\n  activateItem?: boolean,\r\n  activatePane?: boolean,\r\n  pending?: boolean,\r\n  moveCursor?: boolean,\r\n|};\r\n\r\n/**\r\n * Opens the given file.\r\n *\r\n * Optionally include a line and column to navigate to. If a line is given, by default it will\r\n * center it in the opened text editor.\r\n *\r\n * This should be preferred over `atom.workspace.open()` in typical cases. The motivations are:\r\n * - We call `atom.workspace.open()` with the `searchAllPanes` option. This looks in other panes for\r\n *   the current file, rather just opening a new copy in the current pane. People often forget this\r\n *   option which typically leads to a subpar experience for people who use multiple panes.\r\n * - When moving around in the current file, `goToLocation` explicitly publishes events that the nav\r\n *   stack uses.\r\n *\r\n * Currently, `atom.workspace.open()` should be used only in these cases:\r\n * - When the URI to open is not a file URI. For example, if we want to open some tool like find\r\n *   references in a pane.\r\n * - When we want to open an untitled file (providing no file argument). Currently, goToLocation\r\n *   requires a file to open.\r\n * - When we want to open a file as a pending pane item. Currently goToLocation cannot do this.\r\n *\r\n * In these cases, you may disable the lint rule against `atom.workspace.open` by adding the\r\n * following comment above its use:\r\n * // eslint-disable-next-line nuclide-internal/atom-apis\r\n */\r\nexport async function goToLocation(\r\n  file: string,\r\n  options?: ?GoToLocationOptions,\r\n): Promise<atom$TextEditor> {\r\n  const center = options?.center ?? true;\r\n  const moveCursor = options?.moveCursor ?? true;\r\n  const activatePane = options?.activatePane ?? true;\r\n  const activateItem = options?.activateItem;\r\n  const line = options?.line;\r\n  const column = options?.column;\r\n  const pending = options?.pending;\r\n\r\n  // Prefer going to the current editor rather than the leftmost editor.\r\n  const currentEditor = atom.workspace.getActiveTextEditor();\r\n  if (currentEditor != null && currentEditor.getPath() === file) {\r\n    const paneContainer = atom.workspace.paneContainerForItem(currentEditor);\r\n    invariant(paneContainer != null);\r\n    if (activatePane) {\r\n      paneContainer.activate();\r\n    }\r\n    if (line != null) {\r\n      goToLocationInEditor(currentEditor, {\r\n        line,\r\n        column: column == null ? 0 : column,\r\n        center,\r\n        moveCursor,\r\n      });\r\n    } else {\r\n      invariant(column == null, 'goToLocation: Cannot specify just column');\r\n    }\r\n    return currentEditor;\r\n  } else {\r\n    // Obviously, calling goToLocation isn't a viable alternative here :P\r\n    // eslint-disable-next-line nuclide-internal/atom-apis\r\n    const editor = await atom.workspace.open(file, {\r\n      initialLine: line,\r\n      initialColumn: column,\r\n      searchAllPanes: true,\r\n      activatePane,\r\n      activateItem,\r\n      pending,\r\n    });\r\n    // TODO(T28305560) Investigate offenders for this error\r\n    if (editor == null) {\r\n      const tmp = {};\r\n      Error.captureStackTrace(tmp);\r\n      const error = Error(`atom.workspace.open returned null on ${file}`);\r\n      getLogger('goToLocation').error(error);\r\n      throw error;\r\n    }\r\n\r\n    if (center && line != null) {\r\n      editor.scrollToBufferPosition([line, column], {center: true});\r\n    }\r\n    return editor;\r\n  }\r\n}\r\n\r\nconst goToLocationSubject = new Subject();\r\n\r\ntype GotoLocationInEditorOptions = {|\r\n  line: number,\r\n  column: number,\r\n  center?: boolean,\r\n  moveCursor?: boolean,\r\n|};\r\n\r\n// Scrolls to the given line/column at the given editor\r\n// broadcasts the editor instance on an observable (subject) available\r\n// through the getGoToLocation\r\nexport function goToLocationInEditor(\r\n  editor: atom$TextEditor,\r\n  options: GotoLocationInEditorOptions,\r\n): void {\r\n  const center = options.center == null ? true : options.center;\r\n  const moveCursor = options.moveCursor == null ? true : options.moveCursor;\r\n  const {line, column} = options;\r\n\r\n  if (moveCursor) {\r\n    editor.setCursorBufferPosition([line, column]);\r\n  }\r\n  if (center) {\r\n    editor.scrollToBufferPosition([line, column], {center: true});\r\n  }\r\n\r\n  goToLocationSubject.next(editor);\r\n}\r\n\r\nexport function observeNavigatingEditors(): Observable<atom$TextEditor> {\r\n  return goToLocationSubject;\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\nimport type {NuclideUri} from '@atom-ide-community/nuclide-commons/nuclideUri';\r\n\r\nimport invariant from 'assert';\r\nimport {getLogger} from 'log4js';\r\n\r\nimport {existingEditorForUri} from './text-editor';\r\nimport {goToLocation} from './go-to-location';\r\n\r\nexport type TextEdit = {\r\n  oldRange: atom$Range,\r\n  newText: string,\r\n  // If included, this will be used to verify that the edit still applies cleanly.\r\n  oldText?: string,\r\n};\r\n\r\n/**\r\n * Attempts to apply the given patches for multiple files. Accepts a Map as input\r\n * with file paths as keys and a corresponding array of TextEdits as values.\r\n *\r\n * It is an error to send overlapping text-edits. All text-edits describe changes\r\n * made to the initial document version. The order of the edits does not matter\r\n * as they will be sorted before they are applied.\r\n *\r\n * All changes will be applied to the buffers but not saved. If a file is not\r\n * currently open, it will be opened.\r\n *\r\n * If a change is undone (Cmd+Z), only the changes of the current\r\n * file will be undone. All of the changes for that file will be undone at once.\r\n *\r\n * Returns true if the application was successful, otherwise false. If any of\r\n * the changes fail, for ANY file, then none of the changes are applied.\r\n */\r\nexport async function applyTextEditsForMultipleFiles(\r\n  changes: Map<NuclideUri, Array<TextEdit>>,\r\n): Promise<boolean> {\r\n  const paths = Array.from(changes.keys());\r\n\r\n  // NOTE: There is a race here. If the file contents change while the\r\n  // editors are being opened, then the ranges of the TextEdits will be off.\r\n  // However, currently this is only used to applyEdits to open files.\r\n  const editors = await Promise.all(\r\n    paths.map(async path => goToLocation(path)),\r\n  );\r\n  const checkpoints = editors.map(editor => {\r\n    invariant(editor != null);\r\n    const buffer = editor.getBuffer();\r\n    return [buffer, buffer.createCheckpoint()];\r\n  });\r\n  const allOkay = paths.reduce((successSoFar, path) => {\r\n    const edits = changes.get(path);\r\n    return successSoFar && edits != null && applyTextEdits(path, ...edits);\r\n  }, true);\r\n  if (!allOkay) {\r\n    checkpoints.forEach(([buffer, checkPoint]) => {\r\n      buffer.revertToCheckpoint(checkPoint);\r\n      return false;\r\n    });\r\n  }\r\n  return allOkay;\r\n}\r\n\r\n/**\r\n * Attempts to apply the given patches to the given file.\r\n *\r\n * It is an error to send overlapping edits. The order of the edits does not\r\n * matter (they will be sorted before they are applied).\r\n *\r\n * The file must be currently open in Atom, and the changes will be applied to the buffer but not\r\n * saved.\r\n *\r\n * Returns true if the application was successful, otherwise false (e.g. if the oldText did not\r\n * match).\r\n */\r\nexport function applyTextEdits(\r\n  path: NuclideUri,\r\n  ...edits: Array<TextEdit>\r\n): boolean {\r\n  const sortedEdits = sortEdits(edits);\r\n  const editor = existingEditorForUri(path);\r\n  invariant(editor != null);\r\n  return applySortedTextEditsToBuffer(editor.getBuffer(), sortedEdits);\r\n}\r\n\r\nexport function applyTextEditsToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edits: Array<TextEdit>,\r\n): boolean {\r\n  return applySortedTextEditsToBuffer(buffer, sortEdits(edits));\r\n}\r\n\r\nfunction applySortedTextEditsToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edits: Array<TextEdit>,\r\n): boolean {\r\n  // For every edit, the start of its range will be after the end of the\r\n  // previous edit's range.\r\n  if (editsOverlap(edits)) {\r\n    getLogger('text-edit').warn(\r\n      'applyTextEdits was called with overlapping edits.',\r\n    );\r\n    return false;\r\n  }\r\n  // Special-case whole-buffer changes to minimize disruption.\r\n  if (edits.length === 1 && edits[0].oldRange.isEqual(buffer.getRange())) {\r\n    if (edits[0].oldText != null && edits[0].oldText !== buffer.getText()) {\r\n      return false;\r\n    }\r\n    buffer.setTextViaDiff(edits[0].newText);\r\n    return true;\r\n  }\r\n\r\n  const checkpoint = buffer.createCheckpoint();\r\n\r\n  // Iterate through in reverse order. Edits earlier in the file can move around text later in the\r\n  // file, so to avoid conflicts edits should be applied last first.\r\n  for (let i = edits.length - 1; i >= 0; i--) {\r\n    const edit = edits[i];\r\n    const success = applyToBuffer(buffer, edit);\r\n    if (!success) {\r\n      buffer.revertToCheckpoint(checkpoint);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  buffer.groupChangesSinceCheckpoint(checkpoint);\r\n  return true;\r\n}\r\n\r\nfunction applyToBuffer(\r\n  buffer: atom$TextBuffer | simpleTextBuffer$TextBuffer,\r\n  edit: TextEdit,\r\n): boolean {\r\n  if (edit.oldRange.start.row === edit.oldRange.end.row) {\r\n    // A little extra validation when the old range spans only one line. In particular, this helps\r\n    // when the old range is empty so there is no old text for us to compare against. We can at\r\n    // least abort if the line isn't long enough.\r\n    const lineLength = buffer.lineLengthForRow(edit.oldRange.start.row);\r\n    if (edit.oldRange.end.column > lineLength) {\r\n      return false;\r\n    }\r\n  }\r\n  if (edit.oldText != null) {\r\n    const currentText = buffer.getTextInRange(edit.oldRange);\r\n    if (currentText !== edit.oldText) {\r\n      return false;\r\n    }\r\n  }\r\n  buffer.setTextInRange(edit.oldRange, edit.newText);\r\n  return true;\r\n}\r\n\r\n// Returns whether an array of sorted TextEdits contain an overlapping range.\r\nfunction editsOverlap(sortedEdits: Array<TextEdit>): boolean {\r\n  for (let i = 0; i < sortedEdits.length - 1; i++) {\r\n    if (\r\n      sortedEdits[i].oldRange.end.isGreaterThan(\r\n        sortedEdits[i + 1].oldRange.start,\r\n      )\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction sortEdits(edits: Array<TextEdit>): Array<TextEdit> {\r\n  // stable sort (preserve order of edits starting in the same location)\r\n  return edits\r\n    .map((edit, i) => [edit, i])\r\n    .sort(\r\n      ([e1, i1], [e2, i2]) =>\r\n        e1.oldRange.start.compare(e2.oldRange.start) ||\r\n        e1.oldRange.end.compare(e2.oldRange.end) ||\r\n        i1 - i2,\r\n    )\r\n    .map(([edit]) => edit);\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport type {Provider} from './ProviderRegistry';\r\nimport type {TextEdit} from './text-edit';\r\n\r\nimport {Observable} from 'rxjs-compat/bundles/rxjs-compat.umd.min.js';\r\nimport {track} from '@atom-ide-community/nuclide-commons/analytics';\r\nimport ProviderRegistry from './ProviderRegistry';\r\nimport {applyTextEditsToBuffer} from './text-edit';\r\nimport UniversalDisposable from '@atom-ide-community/nuclide-commons/UniversalDisposable';\r\n\r\nexport type FileEventHandlersConfig = {|\r\n  supportsOnWillSave: boolean,\r\n  onWillSaveTimeout?: number,\r\n  onWillSavePriority?: number,\r\n|};\r\n\r\ntype OnWillSaveProvider = Provider & {\r\n  timeout: number,\r\n  callback: (e: atom$TextEditor) => Observable<TextEdit>,\r\n};\r\n\r\n// Timeouts if providers don't all finish in 5 seconds.\r\nconst GLOBAL_SAVE_TIMEOUT_MS = 5000;\r\nconst onWillSaveProviders: ProviderRegistry<\r\n  OnWillSaveProvider,\r\n> = new ProviderRegistry();\r\n\r\n// Returns an observable of booleans, each of which indicates whether the\r\n// formatting text edits from a given provider was successfully applied or not.\r\nfunction onWillSave(editor: atom$TextEditor): Observable<boolean> {\r\n  if (editor.getPath() == null) {\r\n    return Observable.empty();\r\n  }\r\n\r\n  const providers = Array.from(\r\n    onWillSaveProviders.getAllProvidersForEditor(editor),\r\n  );\r\n  // NOTE: concat() is used here to subscribe to providers sequentially and\r\n  // apply their text edits in order.\r\n  return Observable.concat(\r\n    ...providers.map((provider: OnWillSaveProvider) =>\r\n      provider\r\n        .callback(editor)\r\n        .toArray()\r\n        .race(Observable.of([]).delay(provider.timeout))\r\n        .map(edits => {\r\n          const success = applyTextEditsToBuffer(editor.getBuffer(), edits);\r\n          return success;\r\n        }),\r\n    ),\r\n  );\r\n}\r\n\r\n// HACK: intercept the real TextEditor.save and handle it ourselves.\r\n// Atom has no way of injecting content into the buffer asynchronously\r\n// before a save operation.\r\n// If we try to format after the save, and then save again,\r\n// it's a poor user experience (and also races the text buffer's reload).\r\nfunction patchEditorSave(editor: atom$TextEditor): IDisposable {\r\n  const realSave = editor.save;\r\n  const editor_ = (editor: any);\r\n  editor_.save = async () => {\r\n    const timeout = new Date();\r\n    timeout.setTime(timeout.getTime() + GLOBAL_SAVE_TIMEOUT_MS);\r\n    try {\r\n      await onWillSave(editor_)\r\n        .timeout(timeout)\r\n        .toPromise();\r\n    } catch (e) {\r\n      const providers = Array.from(\r\n        onWillSaveProviders.getAllProvidersForEditor(editor_),\r\n      );\r\n      track('timeout-on-save', {\r\n        uri: editor.getPath(),\r\n        providers,\r\n      });\r\n    } finally {\r\n      await realSave.call(editor);\r\n    }\r\n  };\r\n  return new UniversalDisposable(() => {\r\n    editor_.save = realSave;\r\n  });\r\n}\r\n\r\nexport function registerOnWillSave(provider: OnWillSaveProvider): IDisposable {\r\n  return onWillSaveProviders.addProvider(provider);\r\n}\r\n\r\nexport function observeTextEditors(): IDisposable {\r\n  const disposables = new UniversalDisposable();\r\n  disposables.add(\r\n    atom.workspace.observeTextEditors(editor => {\r\n      disposables.add(patchEditorSave(editor));\r\n    }),\r\n  );\r\n  return disposables;\r\n}\r\n","import { Disposable, TextEditor } from \"atom\"\nimport { Provider as ProviderTypes, BusySignalProvider, FindReferencesProvider } from \"../types-packages/main.d\"\n\nexport class ProviderRegistry<Provider extends Exclude<ProviderTypes, BusySignalProvider | FindReferencesProvider>> {\n  private providers: Array<Provider>\n\n  constructor() {\n    this.providers = []\n  }\n\n  addProvider(provider: Provider): Disposable {\n    const index = this.providers.findIndex((p) => provider.priority > p.priority)\n    if (index === -1) {\n      this.providers.push(provider)\n    } else {\n      this.providers.splice(index, 0, provider)\n    }\n    return new Disposable(() => {\n      this.removeProvider(provider)\n    })\n  }\n\n  removeProvider(provider: Provider): void {\n    const index = this.providers.indexOf(provider)\n    if (index !== -1) {\n      this.providers.splice(index, 1)\n    }\n  }\n\n  // TODO deprecate since there can be N providers.\n  getProviderForEditor(editor: TextEditor): Provider | null {\n    const grammar = editor.getGrammar().scopeName\n    return this.findProvider(grammar)\n  }\n\n  // TODO create an ordering or priority aware util to prefer instead.\n  getAllProvidersForEditor(editor: TextEditor): Iterable<Provider> {\n    const grammar = editor.getGrammar().scopeName\n    return this.findAllProviders(grammar)\n  }\n\n  findProvider(grammar: string): Provider | null {\n    for (const provider of this.findAllProviders(grammar)) {\n      return provider\n    }\n    return null\n  }\n\n  /** Iterates over all providers matching the grammar, in priority order. */\n  *findAllProviders(grammar: string): Iterable<Provider> {\n    for (const provider of this.providers) {\n      if (provider.grammarScopes == null || provider.grammarScopes.indexOf(grammar) !== -1) {\n        yield provider\n      }\n    }\n  }\n}\n","(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function _encode(ch) {\n        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    function encodeURIComponent2(str) {\n        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);\n    }\n    function encodeNoop(str) {\n        return str.replace(/[#?]/, _encode);\n    }\n    /**\n     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n     * This class is a simple parser which creates the basic component paths\n     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n     * and encoding.\n     *\n     *       foo://example.com:8042/over/there?name=ferret#nose\n     *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n     *        |           |            |            |        |\n     *     scheme     authority       path        query   fragment\n     *        |   _____________________|__\n     *       / \\ /                        \\\n     *       urn:example:animal:ferret:nose\n     *\n     *\n     */\n    var URI = (function () {\n        function URI() {\n            this._scheme = URI._empty;\n            this._authority = URI._empty;\n            this._path = URI._empty;\n            this._query = URI._empty;\n            this._fragment = URI._empty;\n            this._formatted = null;\n            this._fsPath = null;\n        }\n        URI.isUri = function (thing) {\n            if (thing instanceof URI) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return typeof thing.authority === 'string'\n                && typeof thing.fragment === 'string'\n                && typeof thing.path === 'string'\n                && typeof thing.query === 'string'\n                && typeof thing.scheme === 'string';\n        };\n        Object.defineProperty(URI.prototype, \"scheme\", {\n            /**\n             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n             * The part before the first colon.\n             */\n            get: function () {\n                return this._scheme;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"authority\", {\n            /**\n             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n             * The part between the first double slashes and the next slash.\n             */\n            get: function () {\n                return this._authority;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"path\", {\n            /**\n             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._path;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"query\", {\n            /**\n             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._query;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"fragment\", {\n            /**\n             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n             */\n            get: function () {\n                return this._fragment;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(URI.prototype, \"fsPath\", {\n            // ---- filesystem path -----------------------\n            /**\n             * Returns a string representing the corresponding file system path of this URI.\n             * Will handle UNC paths and normalize windows drive letters to lower-case. Also\n             * uses the platform specific path separator. Will *not* validate the path for\n             * invalid characters and semantics. Will *not* look at the scheme of this URI.\n             */\n            get: function () {\n                if (!this._fsPath) {\n                    var value;\n                    if (this._authority && this._path && this.scheme === 'file') {\n                        // unc path: file://shares/c$/far/boo\n                        value = \"//\" + this._authority + this._path;\n                    }\n                    else if (URI._driveLetterPath.test(this._path)) {\n                        // windows drive letter: file:///c:/far/boo\n                        value = this._path[1].toLowerCase() + this._path.substr(2);\n                    }\n                    else {\n                        // other path\n                        value = this._path;\n                    }\n                    if (isWindows) {\n                        value = value.replace(/\\//g, '\\\\');\n                    }\n                    this._fsPath = value;\n                }\n                return this._fsPath;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // ---- modify to new -------------------------\n        URI.prototype.with = function (change) {\n            if (!change) {\n                return this;\n            }\n            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;\n            if (scheme === void 0) {\n                scheme = this.scheme;\n            }\n            else if (scheme === null) {\n                scheme = '';\n            }\n            if (authority === void 0) {\n                authority = this.authority;\n            }\n            else if (authority === null) {\n                authority = '';\n            }\n            if (path === void 0) {\n                path = this.path;\n            }\n            else if (path === null) {\n                path = '';\n            }\n            if (query === void 0) {\n                query = this.query;\n            }\n            else if (query === null) {\n                query = '';\n            }\n            if (fragment === void 0) {\n                fragment = this.fragment;\n            }\n            else if (fragment === null) {\n                fragment = '';\n            }\n            if (scheme === this.scheme\n                && authority === this.authority\n                && path === this.path\n                && query === this.query\n                && fragment === this.fragment) {\n                return this;\n            }\n            var ret = new URI();\n            ret._scheme = scheme;\n            ret._authority = authority;\n            ret._path = path;\n            ret._query = query;\n            ret._fragment = fragment;\n            URI._validate(ret);\n            return ret;\n        };\n        // ---- parse & validate ------------------------\n        URI.parse = function (value) {\n            var ret = new URI();\n            var data = URI._parseComponents(value);\n            ret._scheme = data.scheme;\n            ret._authority = decodeURIComponent(data.authority);\n            ret._path = decodeURIComponent(data.path);\n            ret._query = decodeURIComponent(data.query);\n            ret._fragment = decodeURIComponent(data.fragment);\n            URI._validate(ret);\n            return ret;\n        };\n        URI.file = function (path) {\n            var ret = new URI();\n            ret._scheme = 'file';\n            // normalize to fwd-slashes on windows,\n            // on other systems bwd-slaches are valid\n            // filename character, eg /f\\oo/ba\\r.txt\n            if (isWindows) {\n                path = path.replace(/\\\\/g, URI._slash);\n            }\n            // check for authority as used in UNC shares\n            // or use the path as given\n            if (path[0] === URI._slash && path[0] === path[1]) {\n                var idx = path.indexOf(URI._slash, 2);\n                if (idx === -1) {\n                    ret._authority = path.substring(2);\n                }\n                else {\n                    ret._authority = path.substring(2, idx);\n                    ret._path = path.substring(idx);\n                }\n            }\n            else {\n                ret._path = path;\n            }\n            // Ensure that path starts with a slash\n            // or that it is at least a slash\n            if (ret._path[0] !== URI._slash) {\n                ret._path = URI._slash + ret._path;\n            }\n            URI._validate(ret);\n            return ret;\n        };\n        URI._parseComponents = function (value) {\n            var ret = {\n                scheme: URI._empty,\n                authority: URI._empty,\n                path: URI._empty,\n                query: URI._empty,\n                fragment: URI._empty,\n            };\n            var match = URI._regexp.exec(value);\n            if (match) {\n                ret.scheme = match[2] || ret.scheme;\n                ret.authority = match[4] || ret.authority;\n                ret.path = match[5] || ret.path;\n                ret.query = match[7] || ret.query;\n                ret.fragment = match[9] || ret.fragment;\n            }\n            return ret;\n        };\n        URI.from = function (components) {\n            return new URI().with(components);\n        };\n        URI._validate = function (ret) {\n            // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n            // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n            if (ret.scheme && !URI._schemePattern.test(ret.scheme)) {\n                throw new Error('[UriError]: Scheme contains illegal characters.');\n            }\n            // path, http://tools.ietf.org/html/rfc3986#section-3.3\n            // If a URI contains an authority component, then the path component\n            // must either be empty or begin with a slash (\"/\") character.  If a URI\n            // does not contain an authority component, then the path cannot begin\n            // with two slash characters (\"//\").\n            if (ret.path) {\n                if (ret.authority) {\n                    if (!URI._singleSlashStart.test(ret.path)) {\n                        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n                    }\n                }\n                else {\n                    if (URI._doubleSlashStart.test(ret.path)) {\n                        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n                    }\n                }\n            }\n        };\n        // ---- printing/externalize ---------------------------\n        /**\n         *\n         * @param skipEncoding Do not encode the result, default is `false`\n         */\n        URI.prototype.toString = function (skipEncoding) {\n            if (skipEncoding === void 0) { skipEncoding = false; }\n            if (!skipEncoding) {\n                if (!this._formatted) {\n                    this._formatted = URI._asFormatted(this, false);\n                }\n                return this._formatted;\n            }\n            else {\n                // we don't cache that\n                return URI._asFormatted(this, true);\n            }\n        };\n        URI._asFormatted = function (uri, skipEncoding) {\n            var encoder = !skipEncoding\n                ? encodeURIComponent2\n                : encodeNoop;\n            var parts = [];\n            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\n            if (scheme) {\n                parts.push(scheme, ':');\n            }\n            if (authority || scheme === 'file') {\n                parts.push('//');\n            }\n            if (authority) {\n                authority = authority.toLowerCase();\n                var idx = authority.indexOf(':');\n                if (idx === -1) {\n                    parts.push(encoder(authority));\n                }\n                else {\n                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\n                }\n            }\n            if (path) {\n                // lower-case windows drive letters in /C:/fff or C:/fff\n                var m = URI._upperCaseDrive.exec(path);\n                if (m) {\n                    if (m[1]) {\n                        path = '/' + m[2].toLowerCase() + path.substr(3); // \"/c:\".length === 3\n                    }\n                    else {\n                        path = m[2].toLowerCase() + path.substr(2); // // \"c:\".length === 2\n                    }\n                }\n                // encode every segement but not slashes\n                // make sure that # and ? are always encoded\n                // when occurring in paths - otherwise the result\n                // cannot be parsed back again\n                var lastIdx = 0;\n                while (true) {\n                    var idx = path.indexOf(URI._slash, lastIdx);\n                    if (idx === -1) {\n                        parts.push(encoder(path.substring(lastIdx)));\n                        break;\n                    }\n                    parts.push(encoder(path.substring(lastIdx, idx)), URI._slash);\n                    lastIdx = idx + 1;\n                }\n                ;\n            }\n            if (query) {\n                parts.push('?', encoder(query));\n            }\n            if (fragment) {\n                parts.push('#', encoder(fragment));\n            }\n            return parts.join(URI._empty);\n        };\n        URI.prototype.toJSON = function () {\n            var res = {\n                fsPath: this.fsPath,\n                external: this.toString(),\n                $mid: 1\n            };\n            if (this.path) {\n                res.path = this.path;\n            }\n            if (this.scheme) {\n                res.scheme = this.scheme;\n            }\n            if (this.authority) {\n                res.authority = this.authority;\n            }\n            if (this.query) {\n                res.query = this.query;\n            }\n            if (this.fragment) {\n                res.fragment = this.fragment;\n            }\n            return res;\n        };\n        URI.revive = function (data) {\n            var result = new URI();\n            result._scheme = data.scheme || URI._empty;\n            result._authority = data.authority || URI._empty;\n            result._path = data.path || URI._empty;\n            result._query = data.query || URI._empty;\n            result._fragment = data.fragment || URI._empty;\n            result._fsPath = data.fsPath;\n            result._formatted = data.external;\n            URI._validate(result);\n            return result;\n        };\n        return URI;\n    }());\n    URI._empty = '';\n    URI._slash = '/';\n    URI._regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    URI._driveLetterPath = /^\\/[a-zA-z]:/;\n    URI._upperCaseDrive = /^(\\/)?([A-Z]:)/;\n    URI._schemePattern = /^\\w[\\w\\d+.-]*$/;\n    URI._singleSlashStart = /^\\//;\n    URI._doubleSlashStart = /^\\/\\//;\n    exports.default = URI;\n    var isWindows;\n    if (typeof process === 'object') {\n        isWindows = process.platform === 'win32';\n    }\n    else if (typeof navigator === 'object') {\n        var userAgent = navigator.userAgent;\n        isWindows = userAgent.indexOf('Windows') >= 0;\n    }\n});\n","/**\r\nModified from https://github.com/substack/node-shell-quote/commit/72fb5a8.\r\nIncludes https://github.com/substack/node-shell-quote/pull/29, with minor\r\nmodifications to remove the unnecessary Array polyfills.\r\n\r\nUse the typed wrappers in ./string.js to access these functions.\r\n\r\nThe MIT License\r\n\r\nCopyright (c) 2013 James Halliday (mail@substack.net)\r\n\r\nPermission is hereby granted, free of charge,\r\nto any person obtaining a copy of this software and\r\nassociated documentation files (the \"Software\"), to\r\ndeal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify,\r\nmerge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom\r\nthe Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice\r\nshall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\r\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n@noflow\r\n*/\r\n\r\n/* eslint-disable */\r\n\r\nexports.quote = function (xs) {\r\n    return xs.map(function (s) {\r\n        if (s && typeof s === 'object') {\r\n            return s.op.replace(/(.)/g, '\\\\$1');\r\n        }\r\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\r\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\r\n        }\r\n        else if (/[\"'\\s]/.test(s)) {\r\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\r\n        }\r\n        else {\r\n            return String(s).replace(/([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '\\\\$1');\r\n        }\r\n    }).join(' ');\r\n};\r\n\r\nvar CONTROL = '(?:' + [\r\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '[&;()|<>]'\r\n].join('|') + ')';\r\nvar META = '|&;()<> \\\\t';\r\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\r\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\r\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\r\n\r\nvar TOKEN = '';\r\nfor (var i = 0; i < 4; i++) {\r\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\r\n}\r\n\r\nexports.parse = function (s, env, opts) {\r\n    var mapped = parse(s, env, opts);\r\n    if (typeof env !== 'function') return mapped;\r\n    return mapped.reduce(function (acc, s) {\r\n        if (typeof s === 'object') return acc.concat(s);\r\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\r\n        if (xs.length === 1) return acc.concat(xs[0]);\r\n        return acc.concat(xs.filter(Boolean).map(function (x) {\r\n            if (RegExp('^' + TOKEN).test(x)) {\r\n                return JSON.parse(x.split(TOKEN)[1]); }\r\n            else return x;\r\n        }));\r\n    }, []);\r\n};\r\n\r\nfunction parse (s, env, opts) {\r\n    var chunker = new RegExp([\r\n        '(' + CONTROL + ')', // control chars\r\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\r\n    ].join('|'), 'g');\r\n    var match = s.match(chunker).filter(Boolean);\r\n    var commented = false;\r\n\r\n    if (!match) return [];\r\n    if (!env) env = {};\r\n    if (!opts) opts = {};\r\n    return match.map(function (s, j) {\r\n        if (commented) {\r\n            return;\r\n        }\r\n        if (s.charAt(0) === '#') {\r\n            commented = true;\r\n            return { comment: s.substr(1) + match.slice(j+1).join(' ') };\r\n        }\r\n        if (RegExp('^' + CONTROL + '$').test(s)) {\r\n            return { op: s };\r\n        }\r\n\r\n        // Hand-written scanner/parser for Bash quoting rules:\r\n        //\r\n        //  1. inside single quotes, all characters are printed literally.\r\n        //  2. inside double quotes, all characters are printed literally\r\n        //     except variables prefixed by '$' and backslashes followed by\r\n        //     either a double quote or another backslash.\r\n        //  3. outside of any quotes, backslashes are treated as escape\r\n        //     characters and not printed (unless they are themselves escaped)\r\n        //  4. quote context can switch mid-token if there is no whitespace\r\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\r\n        //     \"allonetoken\")\r\n        var SQ = \"'\";\r\n        var DQ = '\"';\r\n        var DS = '$';\r\n        var BS = opts.escape || '\\\\';\r\n        var quote = false;\r\n        var esc = false;\r\n        var out = '';\r\n        var isGlob = false;\r\n\r\n        for (var i = 0, len = s.length; i < len; i++) {\r\n            var c = s.charAt(i);\r\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\r\n            if (esc) {\r\n                out += c;\r\n                esc = false;\r\n            }\r\n            else if (quote) {\r\n                if (c === quote) {\r\n                    quote = false;\r\n                }\r\n                else if (quote == SQ) {\r\n                    out += c;\r\n                }\r\n                else { // Double quote\r\n                    if (c === BS) {\r\n                        i += 1;\r\n                        c = s.charAt(i);\r\n                        if (c === DQ || c === BS || c === DS) {\r\n                            out += c;\r\n                        } else {\r\n                            out += BS + c;\r\n                        }\r\n                    }\r\n                    else if (c === DS) {\r\n                        out += parseEnvVar();\r\n                    }\r\n                    else {\r\n                        out += c;\r\n                    }\r\n                }\r\n            }\r\n            else if (c === DQ || c === SQ) {\r\n                quote = c;\r\n            }\r\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\r\n                return { op: s };\r\n            }\r\n            else if (c === BS) {\r\n                esc = true;\r\n            }\r\n            else if (c === DS) {\r\n                out += parseEnvVar();\r\n            }\r\n            else out += c;\r\n        }\r\n\r\n        if (isGlob) return {op: 'glob', pattern: out};\r\n\r\n        return out;\r\n\r\n        function parseEnvVar() {\r\n            i += 1;\r\n            var varend, varname;\r\n            //debugger\r\n            if (s.charAt(i) === '{') {\r\n                i += 1;\r\n                if (s.charAt(i) === '}') {\r\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\r\n                }\r\n                varend = s.indexOf('}', i);\r\n                if (varend < 0) {\r\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\r\n                }\r\n                varname = s.substr(i, varend - i);\r\n                i = varend;\r\n            }\r\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\r\n                varname = s.charAt(i);\r\n                i += 1;\r\n            }\r\n            else {\r\n                varend = s.substr(i).match(/[^\\w\\d_]/);\r\n                if (!varend) {\r\n                    varname = s.substr(i);\r\n                    i = s.length;\r\n                } else {\r\n                    varname = s.substr(i, varend.index);\r\n                    i += varend.index - 1;\r\n                }\r\n            }\r\n            return getVar(null, '', varname);\r\n        }\r\n    })\r\n    // finalize parsed aruments\r\n    .reduce(function(prev, arg){\r\n        if (arg === undefined){\r\n            return prev;\r\n        }\r\n        return prev.concat(arg);\r\n    },[]);\r\n\r\n    function getVar (_, pre, key) {\r\n        var r = typeof env === 'function' ? env(key) : env[key];\r\n        if (r === undefined) r = '';\r\n\r\n        if (typeof r === 'object') {\r\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\r\n        }\r\n        else return pre + r;\r\n    }\r\n}\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\nimport invariant from 'assert';\r\nimport {parse, quote} from './_shell-quote';\r\n\r\nexport function stringifyError(error: Error): string {\r\n  return `name: ${error.name}, message: ${error.message}, stack: ${\r\n    error.stack\r\n  }.`;\r\n}\r\n\r\n// As of Flow v0.28, Flow does not alllow implicit string coercion of null or undefined. Use this to\r\n// make it explicit.\r\nexport function maybeToString(str: ?string): string {\r\n  // We don't want to encourage the use of this function directly because it coerces anything to a\r\n  // string. We get stricter typechecking by using maybeToString, so it should generally be\r\n  // preferred.\r\n  return String(str);\r\n}\r\n\r\n/**\r\n * Originally adapted from https://github.com/azer/relative-date.\r\n * We're including it because of https://github.com/npm/npm/issues/12012\r\n */\r\nconst SECOND = 1000;\r\nconst MINUTE = 60 * SECOND;\r\nconst HOUR = 60 * MINUTE;\r\nconst DAY = 24 * HOUR;\r\nconst WEEK = 7 * DAY;\r\nconst YEAR = DAY * 365;\r\nconst MONTH = YEAR / 12;\r\n\r\nconst shortFormats = [\r\n  [0.7 * MINUTE, 'now'],\r\n  [1.5 * MINUTE, '1m'],\r\n  [60 * MINUTE, 'm', MINUTE],\r\n  [1.5 * HOUR, '1h'],\r\n  [DAY, 'h', HOUR],\r\n  [2 * DAY, '1d'],\r\n  [7 * DAY, 'd', DAY],\r\n  [1.5 * WEEK, '1w'],\r\n  [MONTH, 'w', WEEK],\r\n  [1.5 * MONTH, '1mo'],\r\n  [YEAR, 'mo', MONTH],\r\n  [1.5 * YEAR, '1y'],\r\n  [Number.MAX_VALUE, 'y', YEAR],\r\n];\r\n\r\nconst longFormats = [\r\n  [0.7 * MINUTE, 'just now'],\r\n  [1.5 * MINUTE, 'a minute ago'],\r\n  [60 * MINUTE, 'minutes ago', MINUTE],\r\n  [1.5 * HOUR, 'an hour ago'],\r\n  [DAY, 'hours ago', HOUR],\r\n  [2 * DAY, 'yesterday'],\r\n  [7 * DAY, 'days ago', DAY],\r\n  [1.5 * WEEK, 'a week ago'],\r\n  [MONTH, 'weeks ago', WEEK],\r\n  [1.5 * MONTH, 'a month ago'],\r\n  [YEAR, 'months ago', MONTH],\r\n  [1.5 * YEAR, 'a year ago'],\r\n  [Number.MAX_VALUE, 'years ago', YEAR],\r\n];\r\n\r\nconst longFormatsNumbers = [\r\n  [0.7 * MINUTE, 'just now'],\r\n  [1.5 * MINUTE, '1 minute ago'],\r\n  [60 * MINUTE, 'minutes ago', MINUTE],\r\n  [1.5 * HOUR, '1 hour ago'],\r\n  [DAY, 'hours ago', HOUR],\r\n  [2 * DAY, 'yesterday'],\r\n  [7 * DAY, 'days ago', DAY],\r\n  [1.5 * WEEK, '1 week ago'],\r\n  [MONTH, 'weeks ago', WEEK],\r\n  [1.5 * MONTH, '1 month ago'],\r\n  [YEAR, 'months ago', MONTH],\r\n  [1.5 * YEAR, '1 year ago'],\r\n  [Number.MAX_VALUE, 'years ago', YEAR],\r\n];\r\n\r\nexport function relativeDate(\r\n  input_: number | Date,\r\n  reference_?: number | Date,\r\n  useShortVariant?: boolean = false,\r\n  useNumbersOnly?: boolean = false,\r\n): string {\r\n  let input = input_;\r\n  let reference = reference_;\r\n  if (input instanceof Date) {\r\n    input = input.getTime();\r\n  }\r\n  // flowlint-next-line sketchy-null-number:off\r\n  if (!reference) {\r\n    reference = new Date().getTime();\r\n  }\r\n  if (reference instanceof Date) {\r\n    reference = reference.getTime();\r\n  }\r\n\r\n  const delta = reference - input;\r\n  const formats = useShortVariant\r\n    ? shortFormats\r\n    : useNumbersOnly\r\n      ? longFormatsNumbers\r\n      : longFormats;\r\n  for (const [limit, relativeFormat, remainder] of formats) {\r\n    if (delta < limit) {\r\n      if (typeof remainder === 'number') {\r\n        return (\r\n          Math.round(delta / remainder) +\r\n          (useShortVariant ? '' : ' ') +\r\n          relativeFormat\r\n        );\r\n      } else {\r\n        return relativeFormat;\r\n      }\r\n    }\r\n  }\r\n\r\n  throw new Error('This should never be reached.');\r\n}\r\n\r\n/**\r\n * Count the number of occurrences of `char` in `str`.\r\n * `char` must be a string of length 1.\r\n */\r\nexport function countOccurrences(haystack: string, char: string) {\r\n  invariant(char.length === 1, 'char must be a string of length 1');\r\n\r\n  let count = 0;\r\n  const code = char.charCodeAt(0);\r\n  for (let i = 0; i < haystack.length; i++) {\r\n    if (haystack.charCodeAt(i) === code) {\r\n      count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n * shell-quote's parse allows pipe operators and comments.\r\n * Generally users don't care about this, so throw if we encounter any operators.\r\n */\r\nexport function shellParse(str: string, env?: Object): Array<string> {\r\n  const result = parse(str, env);\r\n  for (let i = 0; i < result.length; i++) {\r\n    if (typeof result[i] !== 'string') {\r\n      if (result[i].op != null) {\r\n        throw new Error(\r\n          `Unexpected operator \"${result[i].op}\" provided to shellParse`,\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `Unexpected comment \"${result[i].comment}\" provided to shellParse`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * shell-quote's parse allows pipe operators and comments and globs\r\n * We treat glob patterns as normal strings. For the other operators, we throw.\r\n */\r\nexport function shellParseWithGlobs(str: string, env?: Object): Array<string> {\r\n  const result = parse(str, env);\r\n  for (let i = 0; i < result.length; i++) {\r\n    if (typeof result[i] !== 'string') {\r\n      if (result[i].op === 'glob') {\r\n        result[i] = result[i].pattern;\r\n      } else if (result[i].op != null) {\r\n        throw new Error(\r\n          `Unexpected operator \"${result[i].op}\" provided to shellParse`,\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `Unexpected comment \"${result[i].comment}\" provided to shellParse`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Technically you can pass in { operator: string } here,\r\n * but we don't use that in most APIs.\r\n */\r\nexport function shellQuote(args: Array<string>): string {\r\n  return quote(args);\r\n}\r\n\r\nexport function removeCommonPrefix(a: string, b: string): [string, string] {\r\n  let i = 0;\r\n  while (a[i] === b[i] && i < a.length && i < b.length) {\r\n    i++;\r\n  }\r\n  return [a.substring(i), b.substring(i)];\r\n}\r\n\r\nexport function removeCommonSuffix(a: string, b: string): [string, string] {\r\n  let i = 0;\r\n  while (\r\n    a[a.length - 1 - i] === b[b.length - 1 - i] &&\r\n    i < a.length &&\r\n    i < b.length\r\n  ) {\r\n    i++;\r\n  }\r\n  return [a.substring(0, a.length - i), b.substring(0, b.length - i)];\r\n}\r\n\r\nexport function shorten(\r\n  str: string,\r\n  maxLength: number,\r\n  suffix?: string,\r\n): string {\r\n  return str.length < maxLength\r\n    ? str\r\n    : str.slice(0, maxLength) + (suffix || '');\r\n}\r\n\r\n/**\r\n * Like String.split, but only splits once.\r\n */\r\nexport function splitOnce(str: string, separator: string): [string, ?string] {\r\n  const index = str.indexOf(separator);\r\n  return index === -1\r\n    ? [str, null]\r\n    : [str.slice(0, index), str.slice(index + separator.length)];\r\n}\r\n\r\n/**\r\n * Indents each line by the specified number of characters.\r\n */\r\nexport function indent(\r\n  str: string,\r\n  level: number = 2,\r\n  char: string = ' ',\r\n): string {\r\n  return str.replace(/^([^\\n])/gm, char.repeat(level) + '$1');\r\n}\r\n\r\nexport function pluralize(noun: string, count: number) {\r\n  return count === 1 ? noun : noun + 's';\r\n}\r\n\r\nexport function capitalize(str: string): string {\r\n  return str.length === 0\r\n    ? str\r\n    : str\r\n        .charAt(0)\r\n        .toUpperCase()\r\n        .concat(str.slice(1));\r\n}\r\n\r\ntype MatchRange = [/* start */ number, /* end */ number];\r\n\r\n/**\r\n * Returns a list of ranges where needle occurs in haystack.\r\n * This will *not* return overlapping matches; i.e. the returned list will be disjoint.\r\n * This makes it easier to use for e.g. highlighting matches in a UI.\r\n */\r\nexport function getMatchRanges(\r\n  haystack: string,\r\n  needle: string,\r\n): Array<MatchRange> {\r\n  if (needle === '') {\r\n    // Not really a valid use.\r\n    return [];\r\n  }\r\n\r\n  const ranges = [];\r\n  let matchIndex = 0;\r\n  while ((matchIndex = haystack.indexOf(needle, matchIndex)) !== -1) {\r\n    const prevRange = ranges[ranges.length - 1];\r\n    if (prevRange != null && prevRange[1] === matchIndex) {\r\n      prevRange[1] += needle.length;\r\n    } else {\r\n      ranges.push([matchIndex, matchIndex + needle.length]);\r\n    }\r\n    matchIndex += needle.length;\r\n  }\r\n  return ranges;\r\n}\r\n\r\nexport function escapeMarkdown(markdown: string): string {\r\n  // Which characters can be backslash-escaped?\r\n  // markdown:   ! #    ()*+ -.        [\\] _`{ }   https://daringfireball.net/projects/markdown/syntax#backslash\r\n  // commonMark: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~  https://spec.commonmark.org/0.28/#backslash-escapes\r\n  // We'll only backslash-escape the lowest common denominator.\r\n  const slashEscaped = markdown.replace(/[#!()*+\\-.[\\\\\\]_`{}]/g, '\\\\$&');\r\n  // And HTML tags need to be &lt; &gt; escaped.\r\n  return slashEscaped.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n}\r\n\r\n// Originally copied from:\r\n// http://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url\r\n// But adopted to match `www.` urls as well as `https?` urls\r\n// and `!` as acceptable url piece.\r\n// Then optimized with https://www.npmjs.com/package/regexp-tree.\r\n// Added a single matching group for use with String.split.\r\n// eslint-disable-next-line max-len\r\nexport const URL_REGEX = /(https?:\\/\\/(?:www\\.)?[-\\w@:%.+~#=]{2,256}\\.[a-z]{2,6}\\b[-\\w@:%+.~#?&/=!]*|www\\.[-\\w@:%.+~#=]{2,256}\\.[a-z]{2,6}\\b[-\\w@:%+.~#?&/=!]*)/;\r\n\r\nexport const ELLIPSIS_CHAR = '\\u2026';\r\nexport const ZERO_WIDTH_SPACE = '\\u200B';\r\n","/**\r\n * Copyright (c) 2017-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n// NuclideUri's are either a local file path, or a URI\r\n// of the form nuclide://<host><path>\r\n//\r\n// This package creates, queries and decomposes NuclideUris.\r\n\r\nimport LspUri from 'vscode-uri';\r\n\r\nexport type NuclideUri = string;\r\n\r\ntype ParsedUrl = {\r\n  hostname: ?string,\r\n  path: string,\r\n};\r\n\r\ntype ParsedRemoteUrl = {\r\n  hostname: string,\r\n  path: string,\r\n};\r\n\r\ntype ParsedPath = {\r\n  root: string,\r\n  dir: string,\r\n  base: string,\r\n  ext: string,\r\n  name: string,\r\n};\r\n\r\nimport invariant from 'assert';\r\n// eslint-disable-next-line nuclide-internal/prefer-nuclide-uri\r\nimport pathModule from 'path';\r\n\r\nimport os from 'os';\r\nimport {maybeToString} from './string';\r\n\r\nconst ARCHIVE_SEPARATOR = '!';\r\nconst KNOWN_ARCHIVE_EXTENSIONS = [];\r\n\r\nconst REMOTE_PATH_URI_PREFIX = 'nuclide://';\r\n// TODO(ljw): following regex is incorrect. A URI scheme must start with\r\n// [A-Za-z] not [0-9_-]. Also, not all schemes require // after them.\r\nconst URI_PREFIX_REGEX = /^[A-Za-z0-9_-]+:\\/\\/.*/;\r\n\r\nfunction isRemote(uri: NuclideUri): boolean {\r\n  return uri.startsWith(REMOTE_PATH_URI_PREFIX);\r\n}\r\n\r\n// Atom often puts its URIs in places where we'd expect to see Nuclide URIs (or plain paths)\r\nfunction isAtomUri(uri: NuclideUri): boolean {\r\n  return uri.startsWith('atom://');\r\n}\r\n\r\nfunction isUri(uri: string): boolean {\r\n  return URI_PREFIX_REGEX.test(uri);\r\n}\r\n\r\nfunction isLocal(uri: NuclideUri): boolean {\r\n  return !isRemote(uri) && !isUri(uri) && !isAtomUri(uri);\r\n}\r\n\r\nfunction createRemoteUri(hostname: string, remotePath: string): string {\r\n  invariant(\r\n    remotePath != null && remotePath !== '',\r\n    'NuclideUri must include a path.',\r\n  );\r\n  return `nuclide://${hostname}${remotePath}`;\r\n}\r\n\r\nfunction isInArchive(uri: NuclideUri): boolean {\r\n  if (isAtomUri(uri) || uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return false;\r\n  }\r\n  for (\r\n    let i = uri.indexOf(ARCHIVE_SEPARATOR);\r\n    i >= 0;\r\n    i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)\r\n  ) {\r\n    if (_isArchiveSeparator(uri, i)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction ancestorOutsideArchive(uri: NuclideUri): NuclideUri {\r\n  for (\r\n    let i = uri.indexOf(ARCHIVE_SEPARATOR);\r\n    i >= 0;\r\n    i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)\r\n  ) {\r\n    if (_isArchiveSeparator(uri, i)) {\r\n      return uri.substring(0, i);\r\n    }\r\n  }\r\n  return uri;\r\n}\r\n\r\n/**\r\n * Parses valid Nuclide URIs into the hostname and path components.\r\n * Throws an Error on invalid URIs. Invalid URIs are:\r\n *  1) Any URI that does not start with 'nuclide://' protocol.\r\n *  2) A URI starting with 'nuclide://' that doesn't contain either a hostname or a path\r\n *\r\n * Everything that does not contain a '://' is assumed to be a local path. Both POSIX and Windows\r\n * paths are legal\r\n */\r\nfunction parse(uri: NuclideUri): ParsedUrl {\r\n  if (uri.startsWith(REMOTE_PATH_URI_PREFIX)) {\r\n    const hostAndPath = uri.substr(REMOTE_PATH_URI_PREFIX.length);\r\n    const hostSep = hostAndPath.indexOf('/');\r\n\r\n    invariant(\r\n      hostSep !== -1,\r\n      `Remote URIs must contain a hostname and a path. Failed to parse ${uri}`,\r\n    );\r\n\r\n    const hostname = hostAndPath.substr(0, hostSep);\r\n    invariant(\r\n      hostname !== '',\r\n      `Remote URIs must contain a hostname. Failed to parse ${uri}`,\r\n    );\r\n\r\n    const path = hostAndPath.substr(hostSep);\r\n    invariant(\r\n      !_endsWithArchiveSeparator(uri),\r\n      `Path cannot end with archive separator. Failed to parse ${uri}`,\r\n    );\r\n    return {hostname, path};\r\n  }\r\n\r\n  invariant(\r\n    !_endsWithArchiveSeparator(uri),\r\n    `Path cannot end with archive separator. Failed to parse ${uri}`,\r\n  );\r\n  return {hostname: null, path: uri};\r\n}\r\n\r\nfunction parseRemoteUri(remoteUri: NuclideUri): ParsedRemoteUrl {\r\n  if (!isRemote(remoteUri)) {\r\n    throw new Error('Expected remote uri. Got ' + remoteUri);\r\n  }\r\n  const parsedUri = parse(remoteUri);\r\n  invariant(\r\n    // flowlint-next-line sketchy-null-string:off\r\n    parsedUri.hostname,\r\n    `Remote Nuclide URIs must contain hostnames, '${maybeToString(\r\n      parsedUri.hostname,\r\n    )}' found while parsing '${remoteUri}'`,\r\n  );\r\n\r\n  // Explicitly copying object properties appeases Flow's \"maybe\" type handling. Using the `...`\r\n  // operator causes null/undefined errors, and `Object.assign` bypasses type checking.\r\n  return {\r\n    hostname: parsedUri.hostname,\r\n    path: parsedUri.path,\r\n  };\r\n}\r\n\r\nfunction getPath(uri: NuclideUri): string {\r\n  return parse(uri).path;\r\n}\r\n\r\nfunction getHostname(remoteUri: NuclideUri): string {\r\n  return parseRemoteUri(remoteUri).hostname;\r\n}\r\n\r\nfunction getHostnameOpt(remoteUri: ?NuclideUri): ?string {\r\n  if (remoteUri == null || !isRemote(remoteUri)) {\r\n    return null;\r\n  }\r\n\r\n  return getHostname(remoteUri);\r\n}\r\n\r\nfunction join(uri: NuclideUri, ...relativePath: Array<string>): NuclideUri {\r\n  return joinArray(uri, relativePath);\r\n}\r\n\r\nfunction joinArray(uri: NuclideUri, relativePath: Array<string>): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    relativePath.splice(0, 0, path);\r\n    _archiveEncodeArrayInPlace(uriPathModule, relativePath);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      createRemoteUri(hostname, uriPathModule.join.apply(null, relativePath)),\r\n    );\r\n  } else {\r\n    relativePath.splice(0, 0, uri);\r\n    _archiveEncodeArrayInPlace(uriPathModule, relativePath);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.join.apply(null, relativePath),\r\n    );\r\n  }\r\n}\r\n\r\nfunction archiveJoin(uri: NuclideUri, path: string): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  if (!KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext))) {\r\n    throw new Error(`Cannot archiveJoin with non-archive ${uri} and ${path}`);\r\n  }\r\n  return uri + ARCHIVE_SEPARATOR + path;\r\n}\r\n\r\nfunction normalize(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    const normal = _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.normalize(_archiveEncode(uriPathModule, path)),\r\n    );\r\n    return createRemoteUri(hostname, normal);\r\n  } else {\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.normalize(_archiveEncode(uriPathModule, uri)),\r\n    );\r\n  }\r\n}\r\n\r\nfunction normalizeDir(uri: NuclideUri): NuclideUri {\r\n  return ensureTrailingSeparator(normalize(uri));\r\n}\r\n\r\nfunction getParent(uri: NuclideUri): NuclideUri {\r\n  // TODO: Is this different than dirname?\r\n  return normalize(join(uri, '..'));\r\n}\r\n\r\nfunction relative(uri: NuclideUri, other: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  const remote = isRemote(uri);\r\n  if (\r\n    remote !== isRemote(other) ||\r\n    (remote && getHostname(uri) !== getHostname(other))\r\n  ) {\r\n    throw new Error(\r\n      `Cannot relative urls on different hosts: ${uri} and ${other}`,\r\n    );\r\n  }\r\n  const uriEncode = _archiveEncode(uriPathModule, remote ? getPath(uri) : uri);\r\n  const otherEncode = _archiveEncode(\r\n    uriPathModule,\r\n    remote ? getPath(other) : other,\r\n  );\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.relative(\r\n      _matchTrailingArchive(uriEncode, otherEncode),\r\n      _matchTrailingArchive(otherEncode, uriEncode),\r\n    ),\r\n  );\r\n}\r\n\r\nfunction basename(uri: NuclideUri, ext: string = ''): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.basename(_archiveEncode(uriPathModule, getPath(uri)), ext),\r\n  );\r\n}\r\n\r\nfunction dirname(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    return createRemoteUri(\r\n      hostname,\r\n      _archiveDecode(\r\n        uriPathModule,\r\n        uriPathModule.dirname(_archiveEncode(uriPathModule, path)),\r\n      ),\r\n    );\r\n  } else {\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.dirname(_archiveEncode(uriPathModule, uri)),\r\n    );\r\n  }\r\n}\r\n\r\nfunction extname(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return _archiveDecode(\r\n    uriPathModule,\r\n    uriPathModule.extname(_archiveEncode(uriPathModule, getPath(uri))),\r\n  );\r\n}\r\n\r\nfunction stripExtension(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const ext = extname(uri);\r\n  if (ext.length === 0) {\r\n    return uri;\r\n  }\r\n\r\n  return uri.slice(0, -1 * ext.length);\r\n}\r\n\r\nfunction _isWindowsPath(path: string): boolean {\r\n  return _pathModuleFor(path) === pathModule.win32;\r\n}\r\n\r\nfunction _getWindowsPathFromWindowsFileUri(uri: string): ?string {\r\n  const prefix = 'file://';\r\n  if (!uri.startsWith(prefix)) {\r\n    return null;\r\n  }\r\n\r\n  const path = uri.substr(prefix.length);\r\n  return _isWindowsPath(path) ? path : null;\r\n}\r\n\r\n/**\r\n * uri is either a file: uri, or a nuclide: uri.\r\n * must convert file: uri's to just a path for atom.\r\n *\r\n * Returns null if not a valid file: URI.\r\n */\r\nfunction uriToNuclideUri(uri: string): ?string {\r\n  // file:// URIs should never normally contain Windows backslashes:\r\n  // e.g. vscode-uri escapes C:\\abc to file:///c:/abc.\r\n  // This just handles any hacky users that simply prepended 'file://'.\r\n  // (vscode-uri does not know how to handle file://C:\\abc.)\r\n  const windowsPathFromUri = _getWindowsPathFromWindowsFileUri(uri);\r\n  if (windowsPathFromUri != null) {\r\n    return windowsPathFromUri;\r\n  }\r\n\r\n  const lspUri = LspUri.parse(uri);\r\n  if (lspUri.scheme === 'file' && lspUri.path) {\r\n    // only handle real files for now.\r\n    return lspUri.fsPath;\r\n  } else if (isRemote(uri)) {\r\n    return uri;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Converts local paths to file: URI's. Leaves remote URI's alone.\r\n */\r\nfunction nuclideUriToUri(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  if (isRemote(uri)) {\r\n    return uri;\r\n  } else {\r\n    return LspUri.file(uri).toString();\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if child is equal to, or is a proper descendant of parent.\r\n */\r\nfunction contains(parent: NuclideUri, child: NuclideUri): boolean {\r\n  _testForIllegalUri(parent);\r\n  _testForIllegalUri(child);\r\n\r\n  // Can't just do startsWith here. If this directory is \"www\" and you\r\n  // are trying to check \"www-base\", just using startsWith would return\r\n  // true, even though \"www-base\" is at the same level as \"Www\", not\r\n  // contained in it.\r\n  // Also, there's an issue with a trailing separator ambiguity. A path\r\n  // like /abc/ does contain /abc\r\n  // This function is used in some performance-sensitive parts, so we\r\n  // want to avoid doing unnecessary string copy, as those that would\r\n  // result from an ensureTrailingSeparator() call\r\n  //\r\n  // First we'll check the lengths.\r\n  // Then check startsWith. If so, then if the two path lengths are\r\n  // equal OR if the next character in the path to check is a path\r\n  // separator, then we know the checked path is in this path.\r\n\r\n  if (child.length < parent.length) {\r\n    // A strong indication of false\r\n    // It could be a matter of a trailing separator, though\r\n    if (child.length < parent.length - 1) {\r\n      // It must be more than just the separator\r\n      return false;\r\n    }\r\n\r\n    return (\r\n      parent.startsWith(child) &&\r\n      (endsWithSeparator(parent) || _isArchiveSeparator(child, parent.length))\r\n    );\r\n  }\r\n\r\n  if (!child.startsWith(parent)) {\r\n    return false;\r\n  }\r\n\r\n  if (endsWithSeparator(parent) || parent.length === child.length) {\r\n    return true;\r\n  }\r\n\r\n  const uriPathModule = _pathModuleFor(child);\r\n\r\n  return (\r\n    _isArchiveSeparator(child, parent.length) ||\r\n    child.slice(parent.length).startsWith(uriPathModule.sep)\r\n  );\r\n}\r\n\r\n/**\r\n * Filter an array of paths to contain only the collapsed root paths, e.g.\r\n * [a/b/c, a/, c/d/, c/d/e] collapses to [a/, c/d/]\r\n */\r\nfunction collapse(paths: Array<NuclideUri>): Array<NuclideUri> {\r\n  return paths.filter(p => !paths.some(fp => contains(fp, p) && fp !== p));\r\n}\r\n\r\nconst hostFormatters = [];\r\n\r\n// A formatter which may shorten hostnames.\r\n// Returns null if the formatter won't shorten the hostname.\r\nexport type HostnameFormatter = (uri: NuclideUri) => ?string;\r\n\r\n// Registers a host formatter for nuclideUriToDisplayString\r\nfunction registerHostnameFormatter(formatter: HostnameFormatter): IDisposable {\r\n  hostFormatters.push(formatter);\r\n  return {\r\n    dispose: () => {\r\n      const index = hostFormatters.indexOf(formatter);\r\n      if (index >= 0) {\r\n        hostFormatters.splice(index, 1);\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nfunction hostnameToDisplayHostname(hostname: string): string {\r\n  return hostFormatters.reduce((current, formatter) => {\r\n    const next = formatter(current);\r\n    if (next != null && next !== '') {\r\n      return next;\r\n    } else {\r\n      return current;\r\n    }\r\n  }, hostname);\r\n}\r\n\r\nfunction nuclideUriToDisplayHostname(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  return isRemote(uri) ? hostnameToDisplayHostname(getHostname(uri)) : uri;\r\n}\r\n\r\n/**\r\n * NuclideUris should never be shown to humans.\r\n * This function returns a human usable string.\r\n */\r\nfunction nuclideUriToDisplayString(uri: NuclideUri): string {\r\n  _testForIllegalUri(uri);\r\n  return isRemote(uri)\r\n    ? `${nuclideUriToDisplayHostname(uri)}:${getPath(uri)}`\r\n    : uri;\r\n}\r\n\r\nfunction ensureTrailingSeparator(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (uri.endsWith(uriPathModule.sep)) {\r\n    return uri;\r\n  }\r\n\r\n  return uri + uriPathModule.sep;\r\n}\r\n\r\nfunction trimTrailingSeparator(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  let stripped = uri;\r\n\r\n  while (stripped.endsWith(uriPathModule.sep) && !isRoot(stripped)) {\r\n    stripped = stripped.slice(0, -1 * uriPathModule.sep.length);\r\n  }\r\n\r\n  return stripped;\r\n}\r\n\r\nfunction endsWithSeparator(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  return uri.endsWith(uriPathModule.sep);\r\n}\r\n\r\nfunction endsWithEdenDir(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return uri.endsWith('.eden');\r\n}\r\n\r\nfunction isAbsolute(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  if (isRemote(uri)) {\r\n    return true;\r\n  } else {\r\n    const uriPathModule = _pathModuleFor(uri);\r\n    return uriPathModule.isAbsolute(uri);\r\n  }\r\n}\r\n\r\nfunction resolve(uri: NuclideUri, ...paths: Array<string>): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  if (isRemote(uri)) {\r\n    const {hostname, path} = parseRemoteUri(uri);\r\n    paths.splice(0, 0, path);\r\n    _archiveEncodeArrayInPlace(uriPathModule, paths);\r\n    return createRemoteUri(\r\n      hostname,\r\n      _archiveDecode(uriPathModule, uriPathModule.resolve.apply(null, paths)),\r\n    );\r\n  } else {\r\n    paths.splice(0, 0, uri);\r\n    _archiveEncodeArrayInPlace(uriPathModule, paths);\r\n    return _archiveDecode(\r\n      uriPathModule,\r\n      uriPathModule.resolve.apply(null, paths),\r\n    );\r\n  }\r\n}\r\n\r\nfunction isHomeRelative(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return uri.startsWith('~');\r\n}\r\n\r\nfunction expandHomeDir(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n\r\n  // Do not expand non home relative uris\r\n  if (!uri.startsWith('~')) {\r\n    return uri;\r\n  }\r\n\r\n  // \"home\" on Windows is %UserProfile%. Note that Windows environment variables\r\n  // are NOT case sensitive, but process.env is a magic object that wraps GetEnvironmentVariableW\r\n  // on Windows, so asking for any case is expected to work.\r\n  const {HOME, UserProfile} = process.env;\r\n\r\n  const isWindows = !isRemote(uri) && os.platform() === 'win32';\r\n  const homePath = isWindows ? UserProfile : HOME;\r\n  invariant(homePath != null);\r\n\r\n  if (uri === '~') {\r\n    return homePath;\r\n  }\r\n\r\n  // Uris like ~abc should not be expanded\r\n  if (!uri.startsWith('~/') && (!isWindows || !uri.startsWith('~\\\\'))) {\r\n    return uri;\r\n  }\r\n\r\n  return pathModule.resolve(homePath, uri.replace('~', '.'));\r\n}\r\n\r\n/**\r\n * Splits a string containing local paths by an OS-specific path delimiter\r\n * Useful for splitting env variables such as PATH\r\n *\r\n * Since remote URI might contain the delimiter, only local paths are allowed.\r\n */\r\nfunction splitPathList(paths: string): Array<NuclideUri> {\r\n  invariant(\r\n    paths.indexOf(REMOTE_PATH_URI_PREFIX) < 0,\r\n    'Splitting remote URIs is not supported',\r\n  );\r\n  const uriPathModule = _pathModuleFor(paths);\r\n\r\n  return paths.split(uriPathModule.delimiter);\r\n}\r\n\r\n/**\r\n * Joins an array of local paths with an OS-specific path delimiter into a single string.\r\n * Useful for constructing env variables such as PATH\r\n *\r\n * Since remote URI might contain the delimiter, only local paths are allowed.\r\n */\r\nfunction joinPathList(paths: Array<NuclideUri>): string {\r\n  if (paths.length === 0) {\r\n    return '';\r\n  }\r\n\r\n  invariant(\r\n    paths.every(path => !isRemote(path)),\r\n    'Joining of remote URIs is not supported',\r\n  );\r\n\r\n  const uriPathModule = _pathModuleFor(paths[0]);\r\n  return paths.join(uriPathModule.delimiter);\r\n}\r\n\r\n/**\r\n * This function prepends the given relative path with a \"current-folder\" prefix\r\n * which is `./` on *nix and .\\ on Windows\r\n */\r\nfunction ensureLocalPrefix(uri: NuclideUri): NuclideUri {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n\r\n  invariant(!isRemote(uri), 'Local prefix can not be added to a remote path');\r\n  invariant(\r\n    !isAbsolute(uri),\r\n    'Local prefix can not be added to an absolute path',\r\n  );\r\n\r\n  const localPrefix = `.${uriPathModule.sep}`;\r\n  if (uri.startsWith(localPrefix)) {\r\n    return uri;\r\n  }\r\n\r\n  return localPrefix + uri;\r\n}\r\n\r\nfunction isRoot(uri: NuclideUri): boolean {\r\n  _testForIllegalUri(uri);\r\n  return dirname(uri) === uri;\r\n}\r\n\r\nfunction parsePath(uri: NuclideUri): ParsedPath {\r\n  _testForIllegalUri(uri);\r\n  const uriPathModule = _pathModuleFor(uri);\r\n  const parsed = uriPathModule.parse(\r\n    _archiveEncode(uriPathModule, getPath(uri)),\r\n  );\r\n  return {\r\n    root: _archiveDecode(uriPathModule, parsed.root),\r\n    dir: _archiveDecode(uriPathModule, parsed.dir),\r\n    base: _archiveDecode(uriPathModule, parsed.base),\r\n    ext: _archiveDecode(uriPathModule, parsed.ext),\r\n    name: _archiveDecode(uriPathModule, parsed.name),\r\n  };\r\n}\r\n\r\nfunction pathSeparatorFor(uri: NuclideUri): string {\r\n  return _pathModuleFor(uri).sep;\r\n}\r\n\r\nfunction split(uri: NuclideUri): Array<string> {\r\n  const parts = [];\r\n  let current = uri;\r\n  let parent = dirname(current);\r\n\r\n  while (current !== parent) {\r\n    parts.push(basename(current));\r\n\r\n    current = parent;\r\n    parent = dirname(current);\r\n  }\r\n\r\n  if (isAbsolute(uri)) {\r\n    parts.push(parent);\r\n  }\r\n  parts.reverse();\r\n  return parts;\r\n}\r\n\r\nfunction hasKnownArchiveExtension(uri: NuclideUri): boolean {\r\n  return KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext));\r\n}\r\n\r\nfunction _pathModuleFor(uri: NuclideUri): typeof pathModule {\r\n  invariant(\r\n    !_endsWithArchiveSeparator(uri),\r\n    `Path cannot end with archive separator. Failed to determine path module for ${uri}`,\r\n  );\r\n  if (uri.startsWith(pathModule.posix.sep)) {\r\n    return pathModule.posix;\r\n  }\r\n  if (uri.indexOf('://') > -1) {\r\n    return pathModule.posix;\r\n  }\r\n  if (uri[1] === ':' && uri[2] === pathModule.win32.sep) {\r\n    return pathModule.win32;\r\n  }\r\n\r\n  // This little russian roulette here is blocking T29990593. I didn't\r\n  // clean it because we might see posix paths on windows and vice versa.\r\n  if (\r\n    uri.split(pathModule.win32.sep).length >\r\n    uri.split(pathModule.posix.sep).length\r\n  ) {\r\n    return pathModule.win32;\r\n  } else {\r\n    return pathModule.posix;\r\n  }\r\n}\r\n\r\n// Runs _archiveEncode in-place on array, and returns argument for convenience.\r\nfunction _archiveEncodeArrayInPlace(\r\n  uriPathModule: typeof pathModule,\r\n  array: Array<NuclideUri>,\r\n): Array<NuclideUri> {\r\n  array.forEach((uri, i, a) => (a[i] = _archiveEncode(uriPathModule, uri)));\r\n  return array;\r\n}\r\n\r\n// This adds a native separator after every archive separator\r\n// so that the native path handling code sees them.\r\nfunction _archiveEncode(\r\n  uriPathModule: typeof pathModule,\r\n  uri: NuclideUri,\r\n): NuclideUri {\r\n  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return uri;\r\n  }\r\n  return KNOWN_ARCHIVE_EXTENSIONS.reduce(\r\n    (acc, ext) =>\r\n      acc.replace(\r\n        `${ext}${ARCHIVE_SEPARATOR}`,\r\n        `${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`,\r\n      ),\r\n    uri,\r\n  );\r\n}\r\n\r\n// This is the inverse of `encodeArchiveSeparators()` to put things\r\n// back after the native path handler has run.\r\nfunction _archiveDecode(\r\n  uriPathModule: typeof pathModule,\r\n  uri: NuclideUri,\r\n): NuclideUri {\r\n  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {\r\n    return uri;\r\n  }\r\n  return _trimArchiveSuffix(\r\n    KNOWN_ARCHIVE_EXTENSIONS.reduce(\r\n      (acc, ext) =>\r\n        acc.replace(\r\n          `${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`,\r\n          `${ext}${ARCHIVE_SEPARATOR}`,\r\n        ),\r\n      uri,\r\n    ),\r\n  );\r\n}\r\n\r\n// When working with encoded uri's, the archive separator is part of the name\r\n// so we can manipulate paths with uriPathModule.  However, in `relative` if\r\n// one uri contains the other, we need the names seen by uriPathModule to agree\r\n// on whether there is an archive separator or not.  E.g. if we have:\r\n//    /etc/file.zip\r\n//    /etc/file.zip!abc\r\n// When we encode these, we get:\r\n//    /etc/file.zip\r\n//    /etc/file.zip!/abc\r\n// We need to add a trailing '!' to the first one so uriPathModule can see that\r\n// the first contains the second.\r\nfunction _matchTrailingArchive(uri: string, other: string): string {\r\n  if (\r\n    uri.length < other.length &&\r\n    other.startsWith(uri) &&\r\n    _isArchiveSeparator(other, uri.length)\r\n  ) {\r\n    return uri + ARCHIVE_SEPARATOR;\r\n  } else {\r\n    return uri;\r\n  }\r\n}\r\n\r\nfunction _trimArchiveSuffix(path: string): string {\r\n  if (_endsWithArchiveSeparator(path)) {\r\n    return path.substring(0, path.length - ARCHIVE_SEPARATOR.length);\r\n  } else {\r\n    return path;\r\n  }\r\n}\r\n\r\nfunction _endsWithArchiveSeparator(path: string): boolean {\r\n  return _isArchiveSeparator(path, path.length - 1);\r\n}\r\n\r\nfunction _isArchiveSeparator(path: string, index: number): boolean {\r\n  return (\r\n    path.length > index &&\r\n    path.charAt(index) === ARCHIVE_SEPARATOR &&\r\n    KNOWN_ARCHIVE_EXTENSIONS.some(ext => {\r\n      const extStart = index - ext.length;\r\n      return path.indexOf(ext, extStart) === extStart;\r\n    })\r\n  );\r\n}\r\n\r\nfunction _testForIllegalUri(uri: ?NuclideUri): void {\r\n  if (uri != null) {\r\n    if (_endsWithArchiveSeparator(uri)) {\r\n      throw new Error(\r\n        `Path operation invoked on URI ending with ${ARCHIVE_SEPARATOR}: ${uri}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nconst NUCLIDE_URI_TYPE_NAME = 'NuclideUri';\r\n\r\n// If mustBeRemote is present then remote-ness must match, otherwise remote-ness\r\n// is ignored.\r\nfunction validate(uri: NuclideUri, mustBeRemote?: boolean): void {\r\n  // Be a little extra paranoid to catch places where the type system may be weak.\r\n  invariant(uri != null, 'Unexpected null NuclideUri');\r\n  invariant(\r\n    typeof uri === 'string',\r\n    `Unexpected NuclideUri type: ${String(uri)}`,\r\n  );\r\n\r\n  if (isRemote(uri)) {\r\n    parse(uri);\r\n    invariant(mustBeRemote !== false, 'Expected remote NuclideUri');\r\n  } else {\r\n    invariant(uri !== '', 'NuclideUri must contain a non-empty path');\r\n    invariant(mustBeRemote !== true, 'Expected local NuclideUri');\r\n  }\r\n}\r\n\r\nconst IMAGE_EXTENSIONS = new Set([\r\n  '.bmp',\r\n  '.gif',\r\n  '.ico',\r\n  '.jpeg',\r\n  '.jpg',\r\n  '.png',\r\n  '.webp',\r\n]);\r\n\r\n/**\r\n * Returns true if this filename looks like an image that Nuclide can open; otherwise false.\r\n */\r\nfunction looksLikeImageUri(uri: NuclideUri): boolean {\r\n  const ext = extname(uri).toLowerCase();\r\n  return IMAGE_EXTENSIONS.has(ext);\r\n}\r\n\r\nexport default {\r\n  basename,\r\n  dirname,\r\n  extname,\r\n  stripExtension,\r\n  isRemote,\r\n  isLocal,\r\n  createRemoteUri,\r\n  isInArchive,\r\n  ancestorOutsideArchive,\r\n  parse,\r\n  parseRemoteUri,\r\n  validate,\r\n  getPath,\r\n  getHostname,\r\n  getHostnameOpt,\r\n  join,\r\n  joinArray,\r\n  archiveJoin,\r\n  relative,\r\n  looksLikeImageUri,\r\n  normalize,\r\n  normalizeDir,\r\n  getParent,\r\n  uriToNuclideUri,\r\n  nuclideUriToUri,\r\n  contains,\r\n  collapse,\r\n  nuclideUriToDisplayString,\r\n  nuclideUriToDisplayHostname,\r\n  hostnameToDisplayHostname,\r\n  registerHostnameFormatter,\r\n  ensureTrailingSeparator,\r\n  trimTrailingSeparator,\r\n  endsWithSeparator,\r\n  endsWithEdenDir,\r\n  isAbsolute,\r\n  isHomeRelative,\r\n  resolve,\r\n  expandHomeDir,\r\n  splitPathList,\r\n  joinPathList,\r\n  ensureLocalPrefix,\r\n  isRoot,\r\n  parsePath,\r\n  split,\r\n  pathSeparatorFor,\r\n  hasKnownArchiveExtension,\r\n  ARCHIVE_SEPARATOR,\r\n  KNOWN_ARCHIVE_EXTENSIONS,\r\n  NUCLIDE_URI_TYPE_NAME,\r\n};\r\n\r\nexport const __TEST__ = {\r\n  _pathModuleFor,\r\n};\r\n","import { Range, CompositeDisposable, TextEditor, TextChange, Disposable, BufferStoppedChangingEvent } from \"atom\"\nimport type { TextEdit, BusySignalService } from \"atom-ide-base\"\nimport type {\n  FileCodeFormatProvider,\n  OnSaveCodeFormatProvider,\n  OnTypeCodeFormatProvider,\n  RangeCodeFormatProvider,\n} from \"./types\"\n\nimport { registerOnWillSave } from \"@atom-ide-community/nuclide-commons-atom/FileEventHandlers\"\nimport { getFormatOnSave, getFormatOnType } from \"./config\"\nimport { getLogger } from \"log4js\"\nimport { ProviderRegistry } from \"atom-ide-base/commons-atom/ProviderRegistry\"\nimport { applyTextEditsToBuffer } from \"@atom-ide-community/nuclide-commons-atom/text-edit\"\nimport nuclideUri from \"@atom-ide-community/nuclide-commons/nuclideUri\"\n\n// Save events are critical, so don't allow providers to block them.\nexport const SAVE_TIMEOUT = 2500\n\nexport default class CodeFormatManager {\n  _subscriptions: CompositeDisposable\n  _rangeProviders: ProviderRegistry<RangeCodeFormatProvider>\n  _fileProviders: ProviderRegistry<FileCodeFormatProvider>\n  _onTypeProviders: ProviderRegistry<OnTypeCodeFormatProvider>\n  _onSaveProviders: ProviderRegistry<OnSaveCodeFormatProvider>\n  _busySignalService: BusySignalService | undefined\n\n  constructor() {\n    /**\n     * Subscribe to all formatting events (commands, saves, edits) and dispatch formatters as necessary. By handling all\n     * events in a central location, we ensure that no buffer runs into race conditions with simultaneous formatters.\n     */\n    this._subscriptions = new CompositeDisposable(\n      // Events from the explicit Atom command.\n      atom.commands.add(\"atom-text-editor\", \"code-format:format-code\", async (event) => {\n        const editorElement = event.currentTarget\n        const editor = editorElement.getModel()\n        // Make sure we halt everything when the editor gets destroyed.\n        const edits = await this._formatCodeInTextEditor(editor)\n        try {\n          const success = applyTextEditsToBuffer(editor.getBuffer(), edits) as boolean\n          if (!success) {\n            throw new Error(\"No code formatting providers found!\")\n          }\n        } catch (err) {\n          atom.notifications.addError(`Failed to format code: ${err.message}`, {\n            detail: err.detail,\n          })\n        }\n      }),\n\n      // Events from typing in the editor\n      atom.workspace.observeTextEditors((editor) => {\n        const onChangeSubs = editor.getBuffer().onDidStopChanging(async (event) => {\n          try {\n            await this._formatCodeOnTypeInTextEditor(editor, event)\n          } catch (err) {\n            getLogger(\"code-format\").warn(\"Failed to format code on type:\", err)\n          }\n        })\n        // Make sure we halt everything when the editor gets destroyed.\n        // We need to capture when editors are about to be destroyed in order to\n        // interrupt any pending formatting operations. (Otherwise, we may end up\n        // attempting to save a destroyed editor!)\n        editor.onDidDestroy(() => onChangeSubs.dispose())\n      }),\n\n      // Format on save\n      registerOnWillSave(() => ({\n        priority: 0,\n        timeout: SAVE_TIMEOUT,\n        callback: this._formatCodeOnSaveInTextEditor.bind(this),\n      }))\n    )\n\n    this._rangeProviders = new ProviderRegistry()\n    this._fileProviders = new ProviderRegistry()\n    this._onTypeProviders = new ProviderRegistry()\n    this._onSaveProviders = new ProviderRegistry()\n  }\n\n  // Return the text edits used to format code in the editor specified.\n  async _formatCodeInTextEditor(editor: TextEditor, range?: Range): Promise<Array<TextEdit>> {\n    const buffer = editor.getBuffer()\n    const selectionRange = range ?? editor.getSelectedBufferRange()\n    const { start: selectionStart, end: selectionEnd } = selectionRange\n    let formatRange: Range\n    if (selectionRange.isEmpty()) {\n      // If no selection is done, then, the whole file is wanted to be formatted.\n      formatRange = buffer.getRange()\n    } else {\n      // Format selections should start at the beginning of the line,\n      // and include the last selected line end.\n      // (If the user has already selected complete rows, then depending on how they\n      // did it, their caret might be either (1) at the end of their last selected line\n      // or (2) at the first column of the line AFTER their selection. In both cases\n      // we snap the formatRange to end at the first column of the line after their\n      // selection.)\n      formatRange = new Range(\n        [selectionStart.row, 0],\n        selectionEnd.column === 0 ? selectionEnd : [selectionEnd.row + 1, 0]\n      )\n    }\n    const rangeProviders = [...this._rangeProviders.getAllProvidersForEditor(editor)]\n    const fileProviders = [...this._fileProviders.getAllProvidersForEditor(editor)]\n    const contents = editor.getText()\n\n    const allEdits = await this._reportBusy(\n      editor,\n      Promise.all(rangeProviders.map((p) => p.formatCode(editor, formatRange)))\n    )\n    const rangeEdits = allEdits.filter((edits) => edits.length > 0)\n\n    const allResults = await this._reportBusy(\n      editor,\n      Promise.all(fileProviders.map((p) => p.formatEntireFile(editor, formatRange)))\n    )\n    const nonNullResults = allResults.filter((result) => result !== null && result !== undefined) as {\n      newCursor?: number\n      formatted: string\n    }[]\n    const fileEdits = nonNullResults.map(({ formatted }) => [\n      {\n        oldRange: editor.getBuffer().getRange(),\n        newText: formatted,\n        oldText: contents,\n      } as TextEdit,\n    ])\n\n    // When formatting the entire file, prefer file-based providers.\n    const preferFileEdits = formatRange.isEqual(buffer.getRange())\n    const edits = preferFileEdits ? fileEdits.concat(rangeEdits) : rangeEdits.concat(fileEdits)\n    return edits.flat() // TODO or [0]?\n  }\n\n  async _formatCodeOnTypeInTextEditor(\n    editor: TextEditor,\n    aggregatedEvent: BufferStoppedChangingEvent\n  ): Promise<Array<TextEdit>> {\n    // Don't try to format changes with multiple cursors.\n    if (aggregatedEvent.changes.length !== 1) {\n      return []\n    }\n    const event = aggregatedEvent.changes[0]\n    // This also ensures the non-emptiness of event.newText for below.\n    if (!shouldFormatOnType(event) || !getFormatOnType()) {\n      return []\n    }\n    // In the case of bracket-matching, we use the last character because that's\n    // the character that will usually cause a reformat (i.e. `}` instead of `{`).\n    const character = event.newText[event.newText.length - 1]\n\n    const providers = [...this._onTypeProviders.getAllProvidersForEditor(editor)]\n    if (providers.length === 0) {\n      return []\n    }\n\n    const contents = editor.getText()\n    const cursorPosition = editor.getCursorBufferPosition().copy()\n\n    // The bracket-matching package basically overwrites\n    //\n    //     editor.insertText('{');\n    //\n    // with\n    //\n    //     editor.insertText('{}');\n    //     cursor.moveLeft();\n    //\n    // We want to wait until the cursor has actually moved before we issue a\n    // format request, so that we format at the right position (and potentially\n    // also let any other event handlers have their go).\n    const allEdits = await Promise.all(\n      providers.map((p) => p.formatAtPosition(editor, editor.getCursorBufferPosition(), character))\n    )\n    const firstNonEmptyIndex = allEdits.findIndex((edits) => edits.length > 0)\n    if (firstNonEmptyIndex === -1) {\n      return []\n    } else {\n      const edits = allEdits[firstNonEmptyIndex]\n      const provider = providers[firstNonEmptyIndex]\n      _checkContentsAreSame(contents, editor.getText())\n      // Note that this modification is not in a transaction, so it applies as a\n      // separate editing event than the character typing. This means that you\n      // can undo just the formatting by attempting to undo once, and then undo\n      // your actual code by undoing again.\n      if (!applyTextEditsToBuffer(editor.getBuffer(), edits)) {\n        throw new Error(\"Could not apply edits to text buffer.\")\n      }\n\n      if (provider.keepCursorPosition) {\n        editor.setCursorBufferPosition(cursorPosition)\n      }\n      return edits\n    }\n  }\n\n  async _formatCodeOnSaveInTextEditor(editor: TextEditor): Promise<TextEdit[]> {\n    const saveProviders = [...this._onSaveProviders.getAllProvidersForEditor(editor)]\n    if (saveProviders.length > 0) {\n      const allEdits = await this._reportBusy(\n        editor,\n        Promise.all(saveProviders.map((p) => p.formatOnSave(editor))),\n        false\n      )\n      const edits = allEdits.filter((edits) => edits.length > 0)\n      return edits.flat()\n    } else if (getFormatOnSave(editor)) {\n      return this._formatCodeInTextEditor(editor, editor.getBuffer().getRange())\n    }\n    return []\n  }\n\n  _reportBusy<T>(editor: TextEditor, promise: Promise<T>, revealTooltip: boolean = true): Promise<T> {\n    const busySignalService = this._busySignalService\n    if (busySignalService !== undefined) {\n      const path = editor.getPath()\n      const displayPath = path !== undefined ? nuclideUri.basename(path) : \"<untitled>\"\n      return busySignalService.reportBusyWhile(`Formatting code in ${displayPath}`, () => promise, { revealTooltip })\n    }\n    return promise\n  }\n\n  addRangeProvider(provider: RangeCodeFormatProvider): Disposable {\n    return this._rangeProviders.addProvider(provider)\n  }\n\n  addFileProvider(provider: FileCodeFormatProvider): Disposable {\n    return this._fileProviders.addProvider(provider)\n  }\n\n  addOnTypeProvider(provider: OnTypeCodeFormatProvider): Disposable {\n    return this._onTypeProviders.addProvider(provider)\n  }\n\n  addOnSaveProvider(provider: OnSaveCodeFormatProvider): Disposable {\n    return this._onSaveProviders.addProvider(provider)\n  }\n\n  consumeBusySignal(busySignalService: BusySignalService): Disposable {\n    this._busySignalService = busySignalService\n    return new Disposable(() => {\n      this._busySignalService = undefined\n    })\n  }\n\n  dispose() {\n    this._subscriptions.dispose()\n  }\n}\n\nfunction shouldFormatOnType(event: TextChange): boolean {\n  // There's not a direct way to figure out what caused this edit event. There\n  // are three cases that we want to pay attention to:\n  //\n  // 1) The user typed a character.\n  // 2) The user typed a character, and bracket-matching kicked in, causing\n  //    there to be two characters typed.\n  // 3) The user pasted a string.\n  //\n  // We only want to trigger autoformatting in the first two cases. However,\n  // we can only look at what new string was inserted, and not what actually\n  // caused the event, so we just use some heuristics to determine which of\n  // these the event probably was depending on what was typed. This means, for\n  // example, we may issue spurious format requests when the user pastes a\n  // single character, but this is acceptable.\n  if (event.oldText !== \"\") {\n    // We either just deleted something or replaced a selection. For the time\n    // being, we're not going to issue a reformat in that case.\n    return false\n  } else if (event.newText === \"\") {\n    // Not sure what happened here; why did we get an event in this case? Bail\n    // for safety.\n    return false\n  } else if (event.newText.length > 1 && !isBracketPair(event.newText)) {\n    return false\n  }\n  return true\n}\n\n/**\n * We can't tell the difference between a paste and the bracket-matcher package inserting an extra bracket, so we just\n * assume that any pair of brackets that bracket-matcher recognizes was a pair matched by the package.\n */\nfunction isBracketPair(typedText: string): boolean {\n  if (atom.packages.getActivePackage(\"bracket-matcher\") === undefined) {\n    return false\n  }\n  const validBracketPairs = atom.config.get(\"bracket-matcher.autocompleteCharacters\") as Array<string>\n  return validBracketPairs.includes(typedText)\n}\n\n// Checks whether contents are same in the buffer post-format, throwing if\n// anything has changed.\nfunction _checkContentsAreSame(before: string, after: string): void {\n  if (before !== after) {\n    throw new Error(\"The file contents were changed before formatting was complete.\")\n  }\n}\n","import type { TextEditor } from \"atom\"\n\nexport function getFormatOnSave(editor: TextEditor): boolean {\n  return atom.config.get(\"atom-ide-code-format.formatOnSave\", {\n    scope: editor.getRootScopeDescriptor(),\n  }) as boolean\n}\n\nexport function getFormatOnType(): boolean {\n  return atom.config.get(\"atom-ide-code-format.formatOnType\") as boolean\n}\n","import type { Disposable } from \"atom\"\nimport type { BusySignalService } from \"atom-ide-base\"\nimport type {\n  RangeCodeFormatProvider,\n  FileCodeFormatProvider,\n  OnTypeCodeFormatProvider,\n  OnSaveCodeFormatProvider,\n} from \"./types\"\n\nimport CodeFormatManager from \"./CodeFormatManager\"\n\nexport { default as config } from \"./config.json\"\n\nlet codeFormatManager: CodeFormatManager\n\nexport function activate() {\n  codeFormatManager = new CodeFormatManager()\n}\n\nexport function consumeRangeProvider(provider: RangeCodeFormatProvider): Disposable {\n  return codeFormatManager.addRangeProvider(provider)\n}\n\nexport function consumeFileProvider(provider: FileCodeFormatProvider): Disposable {\n  return codeFormatManager.addFileProvider(provider)\n}\n\nexport function consumeOnTypeProvider(provider: OnTypeCodeFormatProvider): Disposable {\n  return codeFormatManager.addOnTypeProvider(provider)\n}\n\nexport function consumeOnSaveProvider(provider: OnSaveCodeFormatProvider): Disposable {\n  return codeFormatManager.addOnSaveProvider(provider)\n}\n\nexport function consumeBusySignal(busySignalService: BusySignalService): Disposable {\n  return codeFormatManager.consumeBusySignal(busySignalService)\n}\n\nexport function deactivate() {\n  codeFormatManager.dispose()\n}\n\n// TODO remove\nexport { consumeLegacyProvider } from \"./legacy-provider\"\n","// TODO Remove\n\nimport type { Disposable } from \"atom\"\nimport { consumeRangeProvider, consumeFileProvider, consumeOnSaveProvider, consumeOnTypeProvider } from \"./main\"\nimport type { CodeFormatProvider } from \"./types\"\n\nexport function consumeLegacyProvider(provider: CodeFormatProvider): Disposable {\n  // Legacy providers used `selector` / `inclusionPriority`.\n  // @ts-ignore legacy API compatability.\n  provider.grammarScopes =\n    provider.grammarScopes ||\n    // @ts-ignore\n    (provider.selector != null ? provider.selector.split(\", \") : null)\n  provider.priority =\n    provider.priority != null\n      ? provider.priority\n      : // @ts-ignore\n      provider.inclusionPriority != null\n      ? // @ts-ignore\n        provider.inclusionPriority\n      : 0\n  if (\"formatCode\" in provider) {\n    return consumeRangeProvider(provider)\n  } else if (\"formatEntireFile\" in provider) {\n    return consumeFileProvider(provider)\n  } else if (\"formatAtPosition\" in provider) {\n    return consumeOnTypeProvider(provider)\n  } else if (\"formatOnSave\" in provider) {\n    return consumeOnSaveProvider(provider)\n  }\n  throw new Error(\"Invalid code format provider\")\n}\n"],"names":["functionOrClass","displayName","name","UniversalDisposable","constructor","teardowns","disposed","Set","length","add","this","Error","i","assertTeardown","addUntilDestroyed","destructible","destroyDisposable","onDidDestroy","dispose","remove","teardown","delete","forEach","unsubscribe","destroy","clear","TypeError","Promise","resolve","process","nextTick","async","promise","milliSeconds","timeoutFn","cleanupFn","timeout","setTimeout","clearTimeout","delay","Date","now","deadline","timeoutPromise","retryFunction","validationFunction","maximumTries","retryIntervalMs","result","tries","lastError","error","sleep","asyncFun","scheduledCall","pendingCall","startAsyncCall","resultPromise","then","callNext","items_","test","thisArg","items","reject","slice","numItems","next","index","item","call","f","args","apply","concat","array","filterFunction","limit","filteredList","asyncLimit","push","obj","keys","Object","filteredObj","key","someFunction","resolved","object","Boolean","fn","ret","err","ms","_lastDispatchedOp","_lastFinishedOp","_latestPromise","_waitResolve","thisOp","status","lastPromise","isRunInProgress","TimedOutError","milliseconds","String","value","catch","mappingFunction","Array","parallelPromises","parallelLimit","Math","min","runPromise","e","_promise","_state","kind","getPromise","getState","performance","seconds","nanoseconds","hrtime","rawAnalyticsService","isTrackSupported","eventName","values","track","events","subscribe","trackEvent","analyticsService","ob","setApplicationSessionObservable","event","type","data","trackSampled","sampleRate","random","sample_rate","canMeasure","TimingTracker","_eventName","_startTime","_startMark","_values","eventCount","mark","onError","_trackTimingEvent","onCancel","onSuccess","exception","canceled","measure","clearMarks","clearMeasures","duration","round","toString","startTracking","trackTiming","operation","tracker","reason","decorateTrackTiming","decoratedTrackTiming","bind","trackTimingSampled","decorateTrackTimingSampled","decoratedTrackTimingSampled","_providers","addProvider","provider","findIndex","p","priority","splice","removeProvider","indexOf","getProviderForEditor","editor","grammar","getGrammar","scopeName","findProvider","getAllProvidersForEditor","findAllProviders","grammarScopes","emitter","callback","addListener","removeListener","Observable","create","observer","path","atom","workspace","getTextEditors","getPath","buffer","getBuffer","getViewOfEditor","getScrollTop","position","scrollTop","setCursorBufferPosition","autoscroll","setScrollTop","defer","cursor","getCursors","merge","of","getBufferPosition","onDidChangePosition","map","newBufferPosition","take","textEditor","readOnlyExceptions","getElement","setAttribute","removeAttribute","enforcedSoftWrap","setSoftWrapped","onDidChangeSoftWrapped","softWrapped","isDestroyed","TextEditor","textEditorElement","bufferLineNumber","getModel","pixelPositionForBufferPosition","top","getLineHeightInPixels","clientHeight","max","focus","views","getView","file","options","center","moveCursor","activatePane","activateItem","line","column","pending","currentEditor","getActiveTextEditor","paneContainer","paneContainerForItem","activate","goToLocationInEditor","open","initialLine","initialColumn","searchAllPanes","tmp","captureStackTrace","scrollToBufferPosition","goToLocationSubject","Subject","changes","paths","from","checkpoints","all","createCheckpoint","allOkay","reduce","successSoFar","edits","get","applyTextEdits","checkPoint","revertToCheckpoint","applySortedTextEditsToBuffer","sortEdits","sortedEdits","oldRange","end","isGreaterThan","start","editsOverlap","warn","isEqual","getRange","oldText","getText","setTextViaDiff","newText","checkpoint","applyToBuffer","groupChangesSinceCheckpoint","edit","row","lineLength","lineLengthForRow","getTextInRange","setTextInRange","sort","e1","i1","e2","i2","compare","onWillSaveProviders","disposables","observeTextEditors","realSave","save","editor_","setTime","getTime","empty","providers","toArray","race","onWillSave","toPromise","uri","patchEditorSave","ProviderRegistry","ProviderRegistry_2","atom_1","v","undefined","require","exports","_encode","ch","charCodeAt","toUpperCase","encodeURIComponent2","str","encodeURIComponent","replace","encodeNoop","defineProperty","isWindows","URI","_scheme","_empty","_authority","_path","_query","_fragment","_formatted","_fsPath","isUri","thing","authority","fragment","query","scheme","prototype","enumerable","configurable","_driveLetterPath","toLowerCase","substr","with","change","_validate","parse","_parseComponents","decodeURIComponent","_slash","idx","substring","match","_regexp","exec","components","_schemePattern","_singleSlashStart","_doubleSlashStart","skipEncoding","_asFormatted","encoder","parts","m","_upperCaseDrive","lastIdx","join","toJSON","res","fsPath","external","$mid","revive","default","platform","navigator","userAgent","factory","module","xs","s","op","CONTROL","BAREWORD","TOKEN","pow","env","opts","mapped","chunker","RegExp","filter","commented","j","charAt","comment","SQ","DQ","DS","BS","escape","quote","esc","out","isGlob","len","c","parseEnvVar","pattern","varend","varname","getVar","prev","arg","_","pre","r","JSON","stringify","acc","split","x","message","stack","input_","reference_","useShortVariant","useNumbersOnly","input","reference","delta","formats","shortFormats","longFormatsNumbers","longFormats","relativeFormat","remainder","haystack","char","count","code","a","b","maxLength","suffix","separator","level","repeat","noun","needle","ranges","matchIndex","prevRange","markdown","HOUR","DAY","WEEK","YEAR","MONTH","Number","MAX_VALUE","KNOWN_ARCHIVE_EXTENSIONS","URI_PREFIX_REGEX","isRemote","startsWith","isAtomUri","createRemoteUri","hostname","remotePath","hostAndPath","hostSep","_endsWithArchiveSeparator","parseRemoteUri","remoteUri","parsedUri","getHostname","relativePath","joinArray","_testForIllegalUri","uriPathModule","_pathModuleFor","_archiveEncodeArrayInPlace","_archiveDecode","normalize","_archiveEncode","basename","ext","dirname","extname","_getWindowsPathFromWindowsFileUri","prefix","pathModule","win32","_isWindowsPath","contains","parent","child","endsWithSeparator","_isArchiveSeparator","sep","hostFormatters","hostnameToDisplayHostname","current","formatter","nuclideUriToDisplayHostname","ensureTrailingSeparator","endsWith","isAbsolute","isRoot","posix","_matchTrailingArchive","other","some","extStart","IMAGE_EXTENSIONS","stripExtension","isLocal","isInArchive","ancestorOutsideArchive","validate","mustBeRemote","getHostnameOpt","archiveJoin","relative","remote","uriEncode","otherEncode","looksLikeImageUri","has","normalizeDir","getParent","uriToNuclideUri","windowsPathFromUri","lspUri","LspUri","nuclideUriToUri","collapse","fp","nuclideUriToDisplayString","registerHostnameFormatter","trimTrailingSeparator","stripped","endsWithEdenDir","isHomeRelative","expandHomeDir","HOME","UserProfile","os","homePath","splitPathList","delimiter","joinPathList","every","ensureLocalPrefix","localPrefix","parsePath","parsed","root","dir","base","reverse","pathSeparatorFor","hasKnownArchiveExtension","ARCHIVE_SEPARATOR","NUCLIDE_URI_TYPE_NAME","__TEST__","CodeFormatManager","_subscriptions","CompositeDisposable","commands","currentTarget","_formatCodeInTextEditor","applyTextEditsToBuffer","notifications","addError","detail","onChangeSubs","onDidStopChanging","_formatCodeOnTypeInTextEditor","getLogger","registerOnWillSave","_formatCodeOnSaveInTextEditor","_rangeProviders","_fileProviders","_onTypeProviders","_onSaveProviders","range","selectionRange","getSelectedBufferRange","selectionStart","selectionEnd","formatRange","isEmpty","Range","rangeProviders","fileProviders","contents","rangeEdits","_reportBusy","formatCode","fileEdits","formatEntireFile","formatted","flat","aggregatedEvent","typedText","packages","getActivePackage","config","includes","isBracketPair","shouldFormatOnType","character","cursorPosition","getCursorBufferPosition","copy","allEdits","formatAtPosition","firstNonEmptyIndex","before","after","_checkContentsAreSame","keepCursorPosition","saveProviders","formatOnSave","scope","getRootScopeDescriptor","getFormatOnSave","revealTooltip","busySignalService","_busySignalService","displayPath","nuclideUri","reportBusyWhile","addRangeProvider","addFileProvider","addOnTypeProvider","addOnSaveProvider","consumeBusySignal","Disposable","codeFormatManager","consumeRangeProvider","consumeFileProvider","consumeOnTypeProvider","consumeOnSaveProvider","selector","inclusionPriority"],"mappings":"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"}